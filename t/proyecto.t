
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;
  use strict;
  use warnings;
  package Capture::Tiny;
  # ABSTRACT: Capture STDOUT and STDERR from Perl, XS or external programs
  our $VERSION = '0.28';
  use Carp ();
  use Exporter ();
  use IO::Handle ();
  use File::Spec ();
  use File::Temp qw/tempfile tmpnam/;
  use Scalar::Util qw/reftype blessed/;
  # Get PerlIO or fake it
  BEGIN {
    local $@;
    eval { require PerlIO; PerlIO->can('get_layers') }
      or *PerlIO::get_layers = sub { return () };
  }
  
  #--------------------------------------------------------------------------#
  # create API subroutines and export them
  # [do STDOUT flag, do STDERR flag, do merge flag, do tee flag]
  #--------------------------------------------------------------------------#
  
  my %api = (
    capture         => [1,1,0,0],
    capture_stdout  => [1,0,0,0],
    capture_stderr  => [0,1,0,0],
    capture_merged  => [1,1,1,0],
    tee             => [1,1,0,1],
    tee_stdout      => [1,0,0,1],
    tee_stderr      => [0,1,0,1],
    tee_merged      => [1,1,1,1],
  );
  
  for my $sub ( keys %api ) {
    my $args = join q{, }, @{$api{$sub}};
    eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"; ## no critic
  }
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = keys %api;
  our %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  
  #--------------------------------------------------------------------------#
  # constants and fixtures
  #--------------------------------------------------------------------------#
  
  my $IS_WIN32 = $^O eq 'MSWin32';
  
  ##our $DEBUG = $ENV{PERL_CAPTURE_TINY_DEBUG};
  ##
  ##my $DEBUGFH;
  ##open $DEBUGFH, "> DEBUG" if $DEBUG;
  ##
  ##*_debug = $DEBUG ? sub(@) { print {$DEBUGFH} @_ } : sub(){0};
  
  our $TIMEOUT = 30;
  
  #--------------------------------------------------------------------------#
  # command to tee output -- the argument is a filename that must
  # be opened to signal that the process is ready to receive input.
  # This is annoying, but seems to be the best that can be done
  # as a simple, portable IPC technique
  #--------------------------------------------------------------------------#
  my @cmd = ($^X, '-C0', '-e', <<'HERE');
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
  
  #--------------------------------------------------------------------------#
  # filehandle manipulation
  #--------------------------------------------------------------------------#
  
  sub _relayer {
    my ($fh, $layers) = @_;
    # _debug("# requested layers (@{$layers}) for @{[fileno $fh]}\n");
    my %seen = ( unix => 1, perlio => 1 ); # filter these out
    my @unique = grep { !$seen{$_}++ } @$layers;
    # _debug("# applying unique layers (@unique) to @{[fileno $fh]}\n");
    binmode($fh, join(":", ":raw", @unique));
  }
  
  sub _name {
    my $glob = shift;
    no strict 'refs'; ## no critic
    return *{$glob}{NAME};
  }
  
  sub _open {
    open $_[0], $_[1] or Carp::confess "Error from open(" . join(q{, }, @_) . "): $!";
    # _debug( "# open " . join( ", " , map { defined $_ ? _name($_) : 'undef' } @_ ) . " as " . fileno( $_[0] ) . "\n" );
  }
  
  sub _close {
    # _debug( "# closing " . ( defined $_[0] ? _name($_[0]) : 'undef' )  . " on " . fileno( $_[0] ) . "\n" );
    close $_[0] or Carp::confess "Error from close(" . join(q{, }, @_) . "): $!";
  }
  
  my %dup; # cache this so STDIN stays fd0
  my %proxy_count;
  sub _proxy_std {
    my %proxies;
    if ( ! defined fileno STDIN ) {
      $proxy_count{stdin}++;
      if (defined $dup{stdin}) {
        _open \*STDIN, "<&=" . fileno($dup{stdin});
        # _debug( "# restored proxy STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
      }
      else {
        _open \*STDIN, "<" . File::Spec->devnull;
        # _debug( "# proxied STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
        _open $dup{stdin} = IO::Handle->new, "<&=STDIN";
      }
      $proxies{stdin} = \*STDIN;
      binmode(STDIN, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDOUT ) {
      $proxy_count{stdout}++;
      if (defined $dup{stdout}) {
        _open \*STDOUT, ">&=" . fileno($dup{stdout});
        # _debug( "# restored proxy STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
      }
      else {
        _open \*STDOUT, ">" . File::Spec->devnull;
         # _debug( "# proxied STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
        _open $dup{stdout} = IO::Handle->new, ">&=STDOUT";
      }
      $proxies{stdout} = \*STDOUT;
      binmode(STDOUT, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDERR ) {
      $proxy_count{stderr}++;
      if (defined $dup{stderr}) {
        _open \*STDERR, ">&=" . fileno($dup{stderr});
         # _debug( "# restored proxy STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
      }
      else {
        _open \*STDERR, ">" . File::Spec->devnull;
         # _debug( "# proxied STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
        _open $dup{stderr} = IO::Handle->new, ">&=STDERR";
      }
      $proxies{stderr} = \*STDERR;
      binmode(STDERR, ':utf8') if $] >= 5.008; ## no critic
    }
    return %proxies;
  }
  
  sub _unproxy {
    my (%proxies) = @_;
    # _debug( "# unproxying: " . join(" ", keys %proxies) . "\n" );
    for my $p ( keys %proxies ) {
      $proxy_count{$p}--;
      # _debug( "# unproxied " . uc($p) . " ($proxy_count{$p} left)\n" );
      if ( ! $proxy_count{$p} ) {
        _close $proxies{$p};
        _close $dup{$p} unless $] < 5.008; # 5.6 will have already closed this as dup
        delete $dup{$p};
      }
    }
  }
  
  sub _copy_std {
    my %handles;
    for my $h ( qw/stdout stderr stdin/ ) {
      next if $h eq 'stdin' && ! $IS_WIN32; # WIN32 hangs on tee without STDIN copied
      my $redir = $h eq 'stdin' ? "<&" : ">&";
      _open $handles{$h} = IO::Handle->new(), $redir . uc($h); # ">&STDOUT" or "<&STDIN"
    }
    return \%handles;
  }
  
  # In some cases we open all (prior to forking) and in others we only open
  # the output handles (setting up redirection)
  sub _open_std {
    my ($handles) = @_;
    _open \*STDIN, "<&" . fileno $handles->{stdin} if defined $handles->{stdin};
    _open \*STDOUT, ">&" . fileno $handles->{stdout} if defined $handles->{stdout};
    _open \*STDERR, ">&" . fileno $handles->{stderr} if defined $handles->{stderr};
  }
  
  #--------------------------------------------------------------------------#
  # private subs
  #--------------------------------------------------------------------------#
  
  sub _start_tee {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    # setup pipes
    $stash->{$_}{$which} = IO::Handle->new for qw/tee reader/;
    pipe $stash->{reader}{$which}, $stash->{tee}{$which};
    # _debug( "# pipe for $which\: " .  _name($stash->{tee}{$which}) . " " . fileno( $stash->{tee}{$which} ) . " => " . _name($stash->{reader}{$which}) . " " . fileno( $stash->{reader}{$which}) . "\n" );
    select((select($stash->{tee}{$which}), $|=1)[0]); # autoflush
    # setup desired redirection for parent and child
    $stash->{new}{$which} = $stash->{tee}{$which};
    $stash->{child}{$which} = {
      stdin   => $stash->{reader}{$which},
      stdout  => $stash->{old}{$which},
      stderr  => $stash->{capture}{$which},
    };
    # flag file is used to signal the child is ready
    $stash->{flag_files}{$which} = scalar tmpnam();
    # execute @cmd as a separate process
    if ( $IS_WIN32 ) {
      local $@;
      eval "use Win32API::File qw/CloseHandle GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";
      # _debug( "# Win32API::File loaded\n") unless $@;
      my $os_fhandle = GetOsFHandle( $stash->{tee}{$which} );
      # _debug( "# Couldn't get OS handle: " . fileLastError() . "\n") if ! defined $os_fhandle || $os_fhandle == INVALID_HANDLE_VALUE();
      my $result = SetHandleInformation( $os_fhandle, HANDLE_FLAG_INHERIT(), 0);
      # _debug( $result ? "# set no-inherit flag on $which tee\n" : ("# can't disable tee handle flag inherit: " . fileLastError() . "\n"));
      _open_std( $stash->{child}{$which} );
      $stash->{pid}{$which} = system(1, @cmd, $stash->{flag_files}{$which});
      # not restoring std here as it all gets redirected again shortly anyway
    }
    else { # use fork
      _fork_exec( $which, $stash );
    }
  }
  
  sub _fork_exec {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    my $pid = fork;
    if ( not defined $pid ) {
      Carp::confess "Couldn't fork(): $!";
    }
    elsif ($pid == 0) { # child
      # _debug( "# in child process ...\n" );
      untie *STDIN; untie *STDOUT; untie *STDERR;
      _close $stash->{tee}{$which};
      # _debug( "# redirecting handles in child ...\n" );
      _open_std( $stash->{child}{$which} );
      # _debug( "# calling exec on command ...\n" );
      exec @cmd, $stash->{flag_files}{$which};
    }
    $stash->{pid}{$which} = $pid
  }
  
  my $have_usleep = eval "use Time::HiRes 'usleep'; 1";
  sub _files_exist {
    return 1 if @_ == grep { -f } @_;
    Time::HiRes::usleep(1000) if $have_usleep;
    return 0;
  }
  
  sub _wait_for_tees {
    my ($stash) = @_;
    my $start = time;
    my @files = values %{$stash->{flag_files}};
    my $timeout = defined $ENV{PERL_CAPTURE_TINY_TIMEOUT}
                ? $ENV{PERL_CAPTURE_TINY_TIMEOUT} : $TIMEOUT;
    1 until _files_exist(@files) || ($timeout && (time - $start > $timeout));
    Carp::confess "Timed out waiting for subprocesses to start" if ! _files_exist(@files);
    unlink $_ for @files;
  }
  
  sub _kill_tees {
    my ($stash) = @_;
    if ( $IS_WIN32 ) {
      # _debug( "# closing handles with CloseHandle\n");
      CloseHandle( GetOsFHandle($_) ) for values %{ $stash->{tee} };
      # _debug( "# waiting for subprocesses to finish\n");
      my $start = time;
      1 until wait == -1 || (time - $start > 30);
    }
    else {
      _close $_ for values %{ $stash->{tee} };
      waitpid $_, 0 for values %{ $stash->{pid} };
    }
  }
  
  sub _slurp {
    my ($name, $stash) = @_;
    my ($fh, $pos) = map { $stash->{$_}{$name} } qw/capture pos/;
    # _debug( "# slurping captured $name from " . fileno($fh) . " at pos $pos with layers: @{[PerlIO::get_layers($fh)]}\n");
    seek( $fh, $pos, 0 ) or die "Couldn't seek on capture handle for $name\n";
    my $text = do { local $/; scalar readline $fh };
    return defined($text) ? $text : "";
  }
  
  #--------------------------------------------------------------------------#
  # _capture_tee() -- generic main sub for capturing or teeing
  #--------------------------------------------------------------------------#
  
  sub _capture_tee {
    # _debug( "# starting _capture_tee with (@_)...\n" );
    my ($do_stdout, $do_stderr, $do_merge, $do_tee, $code, @opts) = @_;
    my %do = ($do_stdout ? (stdout => 1) : (),  $do_stderr ? (stderr => 1) : ());
    Carp::confess("Custom capture options must be given as key/value pairs\n")
      unless @opts % 2 == 0;
    my $stash = { capture => { @opts } };
    for ( keys %{$stash->{capture}} ) {
      my $fh = $stash->{capture}{$_};
      Carp::confess "Custom handle for $_ must be seekable\n"
        unless ref($fh) eq 'GLOB' || (blessed($fh) && $fh->isa("IO::Seekable"));
    }
    # save existing filehandles and setup captures
    local *CT_ORIG_STDIN  = *STDIN ;
    local *CT_ORIG_STDOUT = *STDOUT;
    local *CT_ORIG_STDERR = *STDERR;
    # find initial layers
    my %layers = (
      stdin   => [PerlIO::get_layers(\*STDIN) ],
      stdout  => [PerlIO::get_layers(\*STDOUT, output => 1)],
      stderr  => [PerlIO::get_layers(\*STDERR, output => 1)],
    );
    # _debug( "# existing layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # get layers from underlying glob of tied filehandles if we can
    # (this only works for things that work like Tie::StdHandle)
    $layers{stdout} = [PerlIO::get_layers(tied *STDOUT)]
      if tied(*STDOUT) && (reftype tied *STDOUT eq 'GLOB');
    $layers{stderr} = [PerlIO::get_layers(tied *STDERR)]
      if tied(*STDERR) && (reftype tied *STDERR eq 'GLOB');
    # _debug( "# tied object corrected layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # bypass scalar filehandles and tied handles
    # localize scalar STDIN to get a proxy to pick up FD0, then restore later to CT_ORIG_STDIN
    my %localize;
    $localize{stdin}++,  local(*STDIN)
      if grep { $_ eq 'scalar' } @{$layers{stdin}};
    $localize{stdout}++, local(*STDOUT)
      if $do_stdout && grep { $_ eq 'scalar' } @{$layers{stdout}};
    $localize{stderr}++, local(*STDERR)
      if ($do_stderr || $do_merge) && grep { $_ eq 'scalar' } @{$layers{stderr}};
    $localize{stdin}++, local(*STDIN), _open( \*STDIN, "<&=0")
      if tied *STDIN && $] >= 5.008;
    $localize{stdout}++, local(*STDOUT), _open( \*STDOUT, ">&=1")
      if $do_stdout && tied *STDOUT && $] >= 5.008;
    $localize{stderr}++, local(*STDERR), _open( \*STDERR, ">&=2")
      if ($do_stderr || $do_merge) && tied *STDERR && $] >= 5.008;
    # _debug( "# localized $_\n" ) for keys %localize;
    # proxy any closed/localized handles so we don't use fds 0, 1 or 2
    my %proxy_std = _proxy_std();
    # _debug( "# proxy std: @{ [%proxy_std] }\n" );
    # update layers after any proxying
    $layers{stdout} = [PerlIO::get_layers(\*STDOUT, output => 1)] if $proxy_std{stdout};
    $layers{stderr} = [PerlIO::get_layers(\*STDERR, output => 1)] if $proxy_std{stderr};
    # _debug( "# post-proxy layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # store old handles and setup handles for capture
    $stash->{old} = _copy_std();
    $stash->{new} = { %{$stash->{old}} }; # default to originals
    for ( keys %do ) {
      $stash->{new}{$_} = ($stash->{capture}{$_} ||= File::Temp->new);
      seek( $stash->{capture}{$_}, 0, 2 ) or die "Could not seek on capture handle for $_\n";
      $stash->{pos}{$_} = tell $stash->{capture}{$_};
      # _debug("# will capture $_ on " . fileno($stash->{capture}{$_})."\n" );
      _start_tee( $_ => $stash ) if $do_tee; # tees may change $stash->{new}
    }
    _wait_for_tees( $stash ) if $do_tee;
    # finalize redirection
    $stash->{new}{stderr} = $stash->{new}{stdout} if $do_merge;
    # _debug( "# redirecting in parent ...\n" );
    _open_std( $stash->{new} );
    # execute user provided code
    my ($exit_code, $inner_error, $outer_error, @result);
    {
      local *STDIN = *CT_ORIG_STDIN if $localize{stdin}; # get original, not proxy STDIN
      # _debug( "# finalizing layers ...\n" );
      _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
      _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
      # _debug( "# running code $code ...\n" );
      local $@;
      eval { @result = $code->(); $inner_error = $@ };
      $exit_code = $?; # save this for later
      $outer_error = $@; # save this for later
      STDOUT->flush if $do_stdout;
      STDERR->flush if $do_stderr;
    }
    # restore prior filehandles and shut down tees
    # _debug( "# restoring filehandles ...\n" );
    _open_std( $stash->{old} );
    _close( $_ ) for values %{$stash->{old}}; # don't leak fds
    # shouldn't need relayering originals, but see rt.perl.org #114404
    _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
    _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
    _unproxy( %proxy_std );
    # _debug( "# killing tee subprocesses ...\n" ) if $do_tee;
    _kill_tees( $stash ) if $do_tee;
    # return captured output, but shortcut in void context
    # unless we have to echo output to tied/scalar handles;
    my %got;
    if ( defined wantarray or ($do_tee && keys %localize) ) {
      for ( keys %do ) {
        _relayer($stash->{capture}{$_}, $layers{$_});
        $got{$_} = _slurp($_, $stash);
        # _debug("# slurped " . length($got{$_}) . " bytes from $_\n");
      }
      print CT_ORIG_STDOUT $got{stdout}
        if $do_stdout && $do_tee && $localize{stdout};
      print CT_ORIG_STDERR $got{stderr}
        if $do_stderr && $do_tee && $localize{stderr};
    }
    $? = $exit_code;
    $@ = $inner_error if $inner_error;
    die $outer_error if $outer_error;
    # _debug( "# ending _capture_tee with (@_)...\n" );
    return unless defined wantarray;
    my @return;
    push @return, $got{stdout} if $do_stdout;
    push @return, $got{stderr} if $do_stderr && ! $do_merge;
    push @return, @result;
    return wantarray ? @return : $return[0];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Capture::Tiny - Capture STDOUT and STDERR from Perl, XS or external programs
  
  =head1 VERSION
  
  version 0.28
  
  =head1 SYNOPSIS
  
     use Capture::Tiny ':all';
   
     # capture from external command
   
     ($stdout, $stderr, $exit) = capture {
       system( $cmd, @args );
     };
   
     # capture from arbitrary code (Perl or external)
   
     ($stdout, $stderr, @result) = capture {
       # your code here
     };
   
     # capture partial or merged output
   
     $stdout = capture_stdout { ... };
     $stderr = capture_stderr { ... };
     $merged = capture_merged { ... };
   
     # tee output
   
     ($stdout, $stderr) = tee {
       # your code here
     };
   
     $stdout = tee_stdout { ... };
     $stderr = tee_stderr { ... };
     $merged = tee_merged { ... };
  
  =head1 DESCRIPTION
  
  Capture::Tiny provides a simple, portable way to capture almost anything sent
  to STDOUT or STDERR, regardless of whether it comes from Perl, from XS code or
  from an external program.  Optionally, output can be teed so that it is
  captured while being passed through to the original filehandles.  Yes, it even
  works on Windows (usually).  Stop guessing which of a dozen capturing modules
  to use in any particular situation and just use this one.
  
  =head1 USAGE
  
  The following functions are available.  None are exported by default.
  
  =head2 capture
  
     ($stdout, $stderr, @result) = capture \&code;
     $stdout = capture \&code;
  
  The C<<< capture >>> function takes a code reference and returns what is sent to
  STDOUT and STDERR as well as any return values from the code reference.  In
  scalar context, it returns only STDOUT.  If no output was received for a
  filehandle, it returns an empty string for that filehandle.  Regardless of calling
  context, all output is captured -- nothing is passed to the existing filehandles.
  
  It is prototyped to take a subroutine reference as an argument. Thus, it
  can be called in block form:
  
     ($stdout, $stderr) = capture {
       # your code here ...
     };
  
  Note that the coderef is evaluated in list context.  If you wish to force
  scalar context on the return value, you must use the C<<< scalar >>> keyword.
  
     ($stdout, $stderr, $count) = capture {
       my @list = qw/one two three/;
       return scalar @list; # $count will be 3
     };
  
  Also note that within the coderef, the C<<< @_ >>> variable will be empty.  So don't
  use arguments from a surrounding subroutine without copying them to an array
  first:
  
     sub wont_work {
       my ($stdout, $stderr) = capture { do_stuff( @_ ) };    # WRONG
       ...
     }
   
     sub will_work {
       my @args = @_;
       my ($stdout, $stderr) = capture { do_stuff( @args ) }; # RIGHT
       ...
     }
  
  Captures are normally done to an anonymous temporary filehandle.  To
  capture via a named file (e.g. to externally monitor a long-running capture),
  provide custom filehandles as a trailing list of option pairs:
  
     my $out_fh = IO::File->new("out.txt", "w+");
     my $err_fh = IO::File->new("out.txt", "w+");
     capture { ... } stdout => $out_fh, stderr => $err_fh;
  
  The filehandles must be readE<sol>write and seekable.  Modifying the files or
  filehandles during a capture operation will give unpredictable results.
  Existing IO layers on them may be changed by the capture.
  
  When called in void context, C<<< capture >>> saves memory and time by
  not reading back from the capture handles.
  
  =head2 capture_stdout
  
     ($stdout, @result) = capture_stdout \&code;
     $stdout = capture_stdout \&code;
  
  The C<<< capture_stdout >>> function works just like C<<< capture >>> except only
  STDOUT is captured.  STDERR is not captured.
  
  =head2 capture_stderr
  
     ($stderr, @result) = capture_stderr \&code;
     $stderr = capture_stderr \&code;
  
  The C<<< capture_stderr >>> function works just like C<<< capture >>> except only
  STDERR is captured.  STDOUT is not captured.
  
  =head2 capture_merged
  
     ($merged, @result) = capture_merged \&code;
     $merged = capture_merged \&code;
  
  The C<<< capture_merged >>> function works just like C<<< capture >>> except STDOUT and
  STDERR are merged. (Technically, STDERR is redirected to the same capturing
  handle as STDOUT before executing the function.)
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head2 tee
  
     ($stdout, $stderr, @result) = tee \&code;
     $stdout = tee \&code;
  
  The C<<< tee >>> function works just like C<<< capture >>>, except that output is captured
  as well as passed on to the original STDOUT and STDERR.
  
  When called in void context, C<<< tee >>> saves memory and time by
  not reading back from the capture handles, except when the
  original STDOUT OR STDERR were tied or opened to a scalar
  handle.
  
  =head2 tee_stdout
  
     ($stdout, @result) = tee_stdout \&code;
     $stdout = tee_stdout \&code;
  
  The C<<< tee_stdout >>> function works just like C<<< tee >>> except only
  STDOUT is teed.  STDERR is not teed (output goes to STDERR as usual).
  
  =head2 tee_stderr
  
     ($stderr, @result) = tee_stderr \&code;
     $stderr = tee_stderr \&code;
  
  The C<<< tee_stderr >>> function works just like C<<< tee >>> except only
  STDERR is teed.  STDOUT is not teed (output goes to STDOUT as usual).
  
  =head2 tee_merged
  
     ($merged, @result) = tee_merged \&code;
     $merged = tee_merged \&code;
  
  The C<<< tee_merged >>> function works just like C<<< capture_merged >>> except that output
  is captured as well as passed on to STDOUT.
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head1 LIMITATIONS
  
  =head2 Portability
  
  Portability is a goal, not a guarantee.  C<<< tee >>> requires fork, except on
  Windows where C<<< system(1, @cmd) >>> is used instead.  Not tested on any
  particularly esoteric platforms yet.  See the
  L<CPAN Testers Matrix|http://matrix.cpantesters.org/?dist=Capture-Tiny>
  for test result by platform.
  
  =head2 PerlIO layers
  
  Capture::Tiny does it's best to preserve PerlIO layers such as ':utf8' or
  ':crlf' when capturing (only for Perl 5.8.1+) .  Layers should be applied to
  STDOUT or STDERR I<before> the call to C<<< capture >>> or C<<< tee >>>.  This may not work
  for tied filehandles (see below).
  
  =head2 Modifying filehandles before capturing
  
  Generally speaking, you should do little or no manipulation of the standard IO
  filehandles prior to using Capture::Tiny.  In particular, closing, reopening,
  localizing or tying standard filehandles prior to capture may cause a variety of
  unexpected, undesirable andE<sol>or unreliable behaviors, as described below.
  Capture::Tiny does its best to compensate for these situations, but the
  results may not be what you desire.
  
  B<Closed filehandles>
  
  Capture::Tiny will work even if STDIN, STDOUT or STDERR have been previously
  closed.  However, since they will be reopened to capture or tee output, any
  code within the captured block that depends on finding them closed will, of
  course, not find them to be closed.  If they started closed, Capture::Tiny will
  close them again when the capture block finishes.
  
  Note that this reopening will happen even for STDIN or a filehandle not being
  captured to ensure that the filehandle used for capture is not opened to file
  descriptor 0, as this causes problems on various platforms.
  
  Prior to Perl 5.12, closed STDIN combined with PERL_UNICODE=D leaks filehandles
  and also breaks tee() for undiagnosed reasons.  So don't do that.
  
  B<Localized filehandles>
  
  If code localizes any of Perl's standard filehandles before capturing, the capture
  will affect the localized filehandles and not the original ones.  External system
  calls are not affected by localizing a filehandle in Perl and will continue
  to send output to the original filehandles (which will thus not be captured).
  
  B<Scalar filehandles>
  
  If STDOUT or STDERR are reopened to scalar filehandles prior to the call to
  C<<< capture >>> or C<<< tee >>>, then Capture::Tiny will override the output filehandle for
  the duration of the C<<< capture >>> or C<<< tee >>> call and then, for C<<< tee >>>, send captured
  output to the output filehandle after the capture is complete.  (Requires Perl
  5.8)
  
  Capture::Tiny attempts to preserve the semantics of STDIN opened to a scalar
  reference, but note that external processes will not be able to read from such
  a handle.  Capture::Tiny tries to ensure that external processes will read from
  the null device instead, but this is not guaranteed.
  
  B<Tied output filehandles>
  
  If STDOUT or STDERR are tied prior to the call to C<<< capture >>> or C<<< tee >>>, then
  Capture::Tiny will attempt to override the tie for the duration of the
  C<<< capture >>> or C<<< tee >>> call and then send captured output to the tied filehandle after
  the capture is complete.  (Requires Perl 5.8)
  
  Capture::Tiny may not succeed resending UTF-8 encoded data to a tied
  STDOUT or STDERR filehandle.  Characters may appear as bytes.  If the tied filehandle
  is based on L<Tie::StdHandle>, then Capture::Tiny will attempt to determine
  appropriate layers like C<<< :utf8 >>> from the underlying filehandle and do the right
  thing.
  
  B<Tied input filehandle>
  
  Capture::Tiny attempts to preserve the semantics of tied STDIN, but this
  requires Perl 5.8 and is not entirely predictable.  External processes
  will not be able to read from such a handle.
  
  Unless having STDIN tied is crucial, it may be safest to localize STDIN when
  capturing:
  
     my ($out, $err) = do { local *STDIN; capture { ... } };
  
  =head2 Modifying filehandles during a capture
  
  Attempting to modify STDIN, STDOUT or STDERR I<during> C<<< capture >>> or C<<< tee >>> is
  almost certainly going to cause problems.  Don't do that.
  
  =head2 No support for Perl 5.8.0
  
  It's just too buggy when it comes to layers and UTF-8.  Perl 5.8.1 or later
  is recommended.
  
  =head2 Limited support for Perl 5.6
  
  Perl 5.6 predates PerlIO.  UTF-8 data may not be captured correctly.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_CAPTURE_TINY_TIMEOUT
  
  Capture::Tiny uses subprocesses internally for C<<< tee >>>.  By default,
  Capture::Tiny will timeout with an error if such subprocesses are not ready to
  receive data within 30 seconds (or whatever is the value of
  C<<< $Capture::Tiny::TIMEOUT >>>).  An alternate timeout may be specified by setting
  the C<<< PERL_CAPTURE_TINY_TIMEOUT >>> environment variable.  Setting it to zero will
  disable timeouts.  BE<lt>NOTEE<gt>, this does not timeout the code reference being
  captured -- this only prevents Capture::Tiny itself from hanging your process
  waiting for its child processes to be ready to proceed.
  
  =head1 SEE ALSO
  
  This module was, inspired by L<IO::CaptureOutput>, which provides
  similar functionality without the ability to tee output and with more
  complicated code and API.  L<IO::CaptureOutput> does not handle layers
  or most of the unusual cases described in the L</Limitations> section and
  I no longer recommend it.
  
  There are many other CPAN modules that provide some sort of output capture,
  albeit with various limitations that make them appropriate only in particular
  circumstances.  I'm probably missing some.  The long list is provided to show
  why I felt Capture::Tiny was necessary.
  
  =over
  
  =item *
  
  L<IO::Capture>
  
  =item *
  
  L<IO::Capture::Extended>
  
  =item *
  
  L<IO::CaptureOutput>
  
  =item *
  
  L<IPC::Capture>
  
  =item *
  
  L<IPC::Cmd>
  
  =item *
  
  L<IPC::Open2>
  
  =item *
  
  L<IPC::Open3>
  
  =item *
  
  L<IPC::Open3::Simple>
  
  =item *
  
  L<IPC::Open3::Utils>
  
  =item *
  
  L<IPC::Run>
  
  =item *
  
  L<IPC::Run::SafeHandles>
  
  =item *
  
  L<IPC::Run::Simple>
  
  =item *
  
  L<IPC::Run3>
  
  =item *
  
  L<IPC::System::Simple>
  
  =item *
  
  L<Tee>
  
  =item *
  
  L<IO::Tee>
  
  =item *
  
  L<File::Tee>
  
  =item *
  
  L<Filter::Handle>
  
  =item *
  
  L<Tie::STDERR>
  
  =item *
  
  L<Tie::STDOUT>
  
  =item *
  
  L<Test::Output>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Capture-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Capture-Tiny>
  
    git clone https://github.com/dagolden/Capture-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David E. Wheeler
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2009 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
CAPTURE_TINY

$fatpacked{"Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.17022";
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub _throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&_throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  use Scalar::Util ();
  
  sub import {
      shift;
      my @tags = @_;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
  
      @tags = grep {
         if( $_ eq ':warndie' ) {
            Error::WarnDie->import();
            0;
         }
         else {
            1;
         }
      } @tags;
  
      Error::subs->import(@tags);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
  
      unless (@_) {
         $LAST = undef;
         return;
      }
  
      my $pkg = shift;
      return unless ref($pkg);
  
      undef $ERROR{$pkg} if defined $ERROR{$pkg};
  }
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
  
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->($err));
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(Scalar::Util::blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN, $@);
  			my $ok = eval {
  			    $@ = $err;
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = $@ || $Error::THROWN;
  				$err = $Error::ObjectifyCallback->({'text' =>$err})
  					unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
          local($Error::THROWN, $@);
  	    my $ok = eval {
  		$@ = $err;
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = $@ || $Error::THROWN;
  
  		$err = $Error::ObjectifyCallback->({'text' =>$err})
  			unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
  	local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = $@ || $Error::THROWN
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
      unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (Scalar::Util::blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  
  package Error::WarnDie;
  
  sub gen_callstack($)
  {
      my ( $start ) = @_;
  
      require Carp;
      local $Carp::CarpLevel = $start;
      my $trace = Carp::longmess("");
      # Remove try calls from the trace
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      my @callstack = split( m/\n/, $trace );
      return @callstack;
  }
  
  my $old_DIE;
  my $old_WARN;
  
  sub DEATH
  {
      my ( $e ) = @_;
  
      local $SIG{__DIE__} = $old_DIE if( defined $old_DIE );
  
      die @_ if $^S;
  
      my ( $etype, $message, $location, @callstack );
      if ( ref($e) && $e->isa( "Error" ) ) {
          $etype = "exception of type " . ref( $e );
          $message = $e->text;
          $location = $e->file . ":" . $e->line;
          @callstack = split( m/\n/, $e->stacktrace );
      }
      else {
          # Don't apply subsequent layer of message formatting
          die $e if( $e =~ m/^\nUnhandled perl error caught at toplevel:\n\n/ );
          $etype = "perl error";
          my $stackdepth = 0;
          while( caller( $stackdepth ) =~ m/^Error(?:$|::)/ ) {
              $stackdepth++
          }
  
          @callstack = gen_callstack( $stackdepth + 1 );
  
          $message = "$e";
          chomp $message;
  
          if ( $message =~ s/ at (.*?) line (\d+)\.$// ) {
              $location = $1 . ":" . $2;
          }
          else {
              my @caller = caller( $stackdepth );
              $location = $caller[1] . ":" . $caller[2];
          }
      }
  
      shift @callstack;
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      die "\nUnhandled $etype caught at toplevel:\n\n  $message\n\nThrown from: $location\n\nFull stack trace:\n\n$callstack\n";
  }
  
  sub TAXES
  {
      my ( $message ) = @_;
  
      local $SIG{__WARN__} = $old_WARN if( defined $old_WARN );
  
      $message =~ s/ at .*? line \d+\.$//;
      chomp $message;
  
      my @callstack = gen_callstack( 1 );
      my $location = shift @callstack;
  
      # $location already starts in a leading space
      $message .= $location;
  
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      warn "$message:\n$callstack";
  }
  
  sub import
  {
      $old_DIE  = $SIG{__DIE__};
      $old_WARN = $SIG{__WARN__};
  
      $SIG{__DIE__}  = \&DEATH;
      $SIG{__WARN__} = \&TAXES;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 WARNING
  
  Using the "Error" module is B<no longer recommended> due to the black-magical
  nature of its syntactic sugar, which often tends to break. Its maintainers
  have stopped actively writing code that uses it, and discourage people
  from doing so. See the "SEE ALSO" section below for better recommendations.
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
  
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found. The error will also be available in C<$@>.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed. The error will also be available in C<$@>.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 COMPATIBILITY
  
  L<Moose> exports a keyword called C<with> which clashes with Error's. This
  example returns a prototype mismatch error:
  
      package MyTest;
  
      use warnings;
      use Moose;
      use Error qw(:try);
  
  (Thanks to C<maik.hentsche@amd.com> for the report.).
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to it's constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item Error->new()
  
  See the Error::Simple documentation.
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =item $err->associate($obj)
  
  Associates an error with an object to allow error propagation. I.e:
  
      $ber->encode(...) or
          return Error->prior($ber)->associate($ldap);
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =head2 Error::Simple
  
  This class can be used to hold simple error strings and values. It's
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this information will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overridden by the user.
  
  It accepts a single argument which is a hash reference to named parameters.
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =cut
  
  =head1 MESSAGE HANDLERS
  
  C<Error> also provides handlers to extend the output of the C<warn()> perl
  function, and to handle the printing of a thrown C<Error> that is not caught
  or otherwise handled. These are not installed by default, but are requested
  using the C<:warndie> tag in the C<use> line.
  
   use Error qw( :warndie );
  
  These new error handlers are installed in C<$SIG{__WARN__}> and
  C<$SIG{__DIE__}>. If these handlers are already defined when the tag is
  imported, the old values are stored, and used during the new code. Thus, to
  arrange for custom handling of warnings and errors, you will need to perform
  something like the following:
  
   BEGIN {
     $SIG{__WARN__} = sub {
       print STDERR "My special warning handler: $_[0]"
     };
   }
  
   use Error qw( :warndie );
  
  Note that setting C<$SIG{__WARN__}> after the C<:warndie> tag has been
  imported will overwrite the handler that C<Error> provides. If this cannot be
  avoided, then the tag can be explicitly C<import>ed later
  
   use Error;
  
   $SIG{__WARN__} = ...;
  
   import Error qw( :warndie );
  
  =head2 EXAMPLE
  
  The C<__DIE__> handler turns messages such as
  
   Can't call method "foo" on an undefined value at examples/warndie.pl line 16.
  
  into
  
   Unhandled perl error caught at toplevel:
  
     Can't call method "foo" on an undefined value
  
   Thrown from: examples/warndie.pl:16
  
   Full stack trace:
  
           main::inner('undef') called at examples/warndie.pl line 20
           main::outer('undef') called at examples/warndie.pl line 23
  
  =cut
  
  =head1 SEE ALSO
  
  See L<Exception::Class> for a different module providing Object-Oriented
  exception handling, along with a convenient syntax for declaring hierarchies
  for them. It doesn't provide Error's syntactic sugar of C<try { ... }>,
  C<catch { ... }>, etc. which may be a good thing or a bad thing based
  on what you want. (Because Error's syntactic sugar tends to break.)
  
  L<Error::Exception> aims to combine L<Error> and L<Exception::Class>
  "with correct stringification".
  
  L<TryCatch> and L<Try::Tiny> are similar in concept to Error.pm only providing
  a syntax that hopefully breaks less.
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  C<:warndie> handlers added by Paul Evans <leonerd@leonerd.org.uk>
  
  =head1 MAINTAINER
  
  Shlomi Fish, L<http://www.shlomifish.org/> .
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8  Graham Barr. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
ERROR

$fatpacked{"Error/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_SIMPLE';
  # Error/Simple.pm
  #
  # Copyright (c) 2006 Shlomi Fish <shlomif@shlomifish.org>.
  # This file is free software; you can redistribute it and/or
  # modify it under the terms of the MIT/X11 license (whereas the licence
  # of the Error distribution as a whole is the GPLv1+ and the Artistic
  # licence).
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  use Error;
  
  1;
  __END__
  
  =head1 NAME
  
  Error::Simple - the simple error sub-class of Error
  
  =head1 SYNOPSIS
  
      use base 'Error::Simple';
  
  =head1 DESCRIPTION
  
  The only purpose of this module is to allow one to say:
  
      use base 'Error::Simple';
  
  and the only thing it does is "use" Error.pm. Refer to the documentation
  of L<Error> for more information about Error::Simple.
  
  =head1 METHODS
  
  =head2 Error::Simple->new($text [, $value])
  
  Constructs an Error::Simple with the text C<$text> and the optional value
  C<$value>.
  
  =head2 $err->stringify()
  
  Error::Simple overloads this method.
  
  =head1 KNOWN BUGS
  
  None.
  
  =head1 AUTHORS
  
  Shlomi Fish ( L<http://www.shlomifish.org/> )
  
  =head1 SEE ALSO
  
  L<Error>
  
ERROR_SIMPLE

$fatpacked{"File/Slurper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURPER';
  package File::Slurper;
  $File::Slurper::VERSION = '0.009';
  use strict;
  use warnings;
  
  use Carp 'croak';
  use Exporter 5.57 'import';
  
  use Encode qw(:fallbacks);
  use PerlIO::encoding;
  
  our @EXPORT_OK = qw/read_binary read_text read_lines write_binary write_text read_dir/;
  
  sub read_binary {
  	my $filename = shift;
  
  	# This logic is a bit ugly, but gives a significant speed boost
  	# because slurpy readline is not optimized for non-buffered usage
  	open my $fh, '<:unix', $filename or croak "Couldn't open $filename: $!";
  	if (my $size = -s $fh) {
  		my $buf;
  		my ($pos, $read) = 0;
  		do {
  			defined($read = read $fh, ${$buf}, $size - $pos, $pos) or croak "Couldn't read $filename: $!";
  			$pos += $read;
  		} while ($read && $pos < $size);
  		return ${$buf};
  	}
  	else {
  		return do { local $/; <$fh> };
  	}
  }
  
  use constant {
  	CRLF_DEFAULT => $^O eq 'MSWin32',
  	HAS_UTF8_STRICT => scalar do { local $@; eval { require PerlIO::utf8_strict } },
  };
  
  sub _text_layers {
  	my ($encoding, $crlf) = @_;
  	$crlf = CRLF_DEFAULT if $crlf && $crlf eq 'auto';
  
  	if ($encoding =~ /^(latin|iso-8859-)1$/i) {
  		return $crlf ? ':unix:crlf' : ':raw';
  	}
  	elsif (HAS_UTF8_STRICT && $encoding =~ /^utf-?8\b/i) {
  		return $crlf ? ':unix:utf8_strict:crlf' : ':unix:utf8_strict';
  	}
  	else {
  		# non-ascii compatible encodings such as UTF-16 need encoding before crlf
  		return $crlf ? ":raw:encoding($encoding):crlf" : ":raw:encoding($encoding)";
  	}
  }
  
  sub read_text {
  	my ($filename, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  	return read_binary($filename) if $layer eq ':raw';
  
  	local $PerlIO::encoding::fallback = FB_CROAK;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return do { local $/; <$fh> };
  }
  
  sub write_text {
  	my ($filename, undef, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = FB_CROAK;
  	open my $fh, ">$layer", $filename or croak "Couldn't open $filename: $!";
  	print $fh $_[1] or croak "Couldn't write to $filename: $!";
  	close $fh or croak "Couldn't write to $filename: $!";
  	return;
  }
  
  sub write_binary {
  	return write_text(@_[0,1], 'latin-1');
  }
  
  sub read_lines {
  	my ($filename, $encoding, $crlf, $skip_chomp) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = FB_CROAK;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return <$fh> if $skip_chomp;
  	my @buf = <$fh>;
  	close $fh;
  	chomp @buf;
  	return @buf;
  }
  
  sub read_dir {
  	my ($dirname) = @_;
  	opendir my ($dir), $dirname or croak "Could not open $dirname: $!";
  	return grep { not m/ \A \.\.? \z /x } readdir $dir;
  }
  
  1;
  
  # ABSTRACT: A simple, sane and efficient module to slurp a file
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Slurper - A simple, sane and efficient module to slurp a file
  
  =head1 VERSION
  
  version 0.009
  
  =head1 SYNOPSIS
  
   use File::Slurper 'read_text';
   my $content = read_text($filename);
  
  =head1 DESCRIPTION
  
  This module provides functions for fast and correct slurping and spewing. All functions are optionally exported.
  
  =head1 FUNCTIONS
  
  =head2 read_text($filename, $encoding, $crlf)
  
  Reads file C<$filename> into a scalar and decodes it from C<$encoding> (which defaults to UTF-8). If C<$crlf> is true, crlf translation is performed. The default for this argument is off. The special value C<'auto'> will set it to a platform specific default value.
  
  =head2 read_binary($filename)
  
  Reads file C<$filename> into a scalar without any decoding or transformation.
  
  =head2 read_lines($filename, $encoding, $crlf, $skip_chomp)
  
  Reads file C<$filename> into a list/array line-by-line, after decoding from C<$encoding>, optional crlf translation and chomping.
  
  =head2 write_text($filename, $content, $encoding, $crlf)
  
  Writes C<$content> to file C<$filename>, encoding it to C<$encoding> (which defaults to UTF-8). It can also take a C<crlf> argument that works exactly as in read_text.
  
  =head2 write_binary($filename, $content)
  
  Writes C<$content> to file C<$filename> as binary data.
  
  =head2 read_dir($dirname)
  
  Open C<dirname> and return all entries except C<.> and C<..>.
  
  =head1 RATIONALE
  
  This module tries to make it as easy as possible to read and write files correctly and fast. The most correct way of doing this is not always obvious (e.g. L<#83126|https://rt.cpan.org/Public/Bug/Display.html?id=83126>), and just as often the most obvious correct way is not the fastest correct way. This module hides away all such complications behind an easy intuitive interface.
  
  =head1 DEPENDENCIES
  
  This module has an optional dependency on L<PerlIO::utf8_strict|PerlIO::utf8_strict>. Installing this will make UTF-8 encoded IO significantly faster, but should not otherwise affect the operation of this module. This may change into a dependency on the related Unicode::UTF8 in the future.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Path::Tiny|Path::Tiny>
  
  A minimalistic abstraction handling not only IO but also paths.
  
  =item * L<IO::All|IO::All>
  
  An attempt to expose as many IO related features as possible via a single API.
  
  =item * L<File::Slurp|File::Slurp>
  
  This is previous generation file slurping module. It has a number of issues, as described L<here|http://blogs.perl.org/users/leon_timmermans/2015/08/fileslurp-is-broken-and-wrong.html>
  
  =item * L<File::Slurp::Tiny|File::Slurp::Tiny>
  
  This was my previous attempt at a better file slurping module. It's mostly (but not entirely) a drop-in replacement for File::Slurp, which is both a feature (easy conversion) and a bug (interface issues).
  
  =back
  
  =head1 TODO
  
  =over 4
  
  =item * C<open_text>/C<open_binary>?
  
  =item * C<drain_handle>?
  
  =back
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_SLURPER

$fatpacked{"Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT';
  =head1 NAME
  
  Git - Perl interface to the Git version control system
  
  =cut
  
  
  package Git;
  
  use 5.008;
  use strict;
  
  
  BEGIN {
  
  our ($VERSION, @ISA, @EXPORT, @EXPORT_OK);
  
  # Totally unstable API.
  $VERSION = '0.42';
  # pulled from github, commit 217f2767cbcb562872437eed4dec62e00846d90c
  
  
  =head1 SYNOPSIS
  
    use Git;
  
    my $version = Git::command_oneline('version');
  
    git_cmd_try { Git::command_noisy('update-server-info') }
                '%s failed w/ code %d';
  
    my $repo = Git->repository (Directory => '/srv/git/cogito.git');
  
  
    my @revs = $repo->command('rev-list', '--since=last monday', '--all');
  
    my ($fh, $c) = $repo->command_output_pipe('rev-list', '--since=last monday', '--all');
    my $lastrev = <$fh>; chomp $lastrev;
    $repo->command_close_pipe($fh, $c);
  
    my $lastrev = $repo->command_oneline( [ 'rev-list', '--all' ],
                                          STDERR => 0 );
  
    my $sha1 = $repo->hash_and_insert_object('file.txt');
    my $tempfile = tempfile();
    my $size = $repo->cat_blob($sha1, $tempfile);
  
  =cut
  
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(git_cmd_try);
  
  # Methods which can be called as standalone functions as well:
  @EXPORT_OK = qw(command command_oneline command_noisy
                  command_output_pipe command_input_pipe command_close_pipe
                  command_bidi_pipe command_close_bidi_pipe
                  version exec_path html_path hash_object git_cmd_try
                  remote_refs prompt
                  get_tz_offset get_record
                  credential credential_read credential_write
                  temp_acquire temp_is_locked temp_release temp_reset temp_path
                  unquote_path);
  
  
  =head1 DESCRIPTION
  
  [MAINTAINER NOTE: This is Git.pm, plus the other files in the perl/Git directory,
  from github's git/git, which is a mirror of the git source.  I (cpan msouth, or
  current maintainer) update the VERSION string (necessary on CPAN because of another
  CPAN distribution that confused the CPAN toolchain about which was the actual
  official Git.pm), add this explanatory paragraph, and use Dist::Zilla to package
  and release on CPAN.  The only reason that I know of that you would need this is
  if you are using something like Git::Hooks and you are using a perlbrewed (or
  otherwise separate) perl from the one git is using on your system (e.g. if you
  have a dev perl that’s separate from system perl, and git uses the system perl.
  Then the Git.pm gets installed in the system lib and you have no way of getting
  it from CPAN, so your code--that uses modules that depend on Git.pm--doesn’t work).
  I try to keep this up to date, so that if you do pull this from CPAN it will be,
  hopefully, identical in functionality to the Git.pm and Git/*.pm from the git
  distribution.  If that is not the case, contact me and I'll look into it.]
  
  This module provides Perl scripts easy way to interface the Git version control
  system. The modules have an easy and well-tested way to call arbitrary Git
  commands; in the future, the interface will also provide specialized methods
  for doing easily operations which are not totally trivial to do over
  the generic command interface.
  
  While some commands can be executed outside of any context (e.g. 'version'
  or 'init'), most operations require a repository context, which in practice
  means getting an instance of the Git object using the repository() constructor.
  (In the future, we will also get a new_repository() constructor.) All commands
  called as methods of the object are then executed in the context of the
  repository.
  
  Part of the "repository state" is also information about path to the attached
  working copy (unless you work with a bare repository). You can also navigate
  inside of the working copy using the C<wc_chdir()> method. (Note that
  the repository object is self-contained and will not change working directory
  of your process.)
  
  TODO: In the future, we might also do
  
  	my $remoterepo = $repo->remote_repository (Name => 'cogito', Branch => 'master');
  	$remoterepo ||= Git->remote_repository ('http://git.or.cz/cogito.git/');
  	my @refs = $remoterepo->refs();
  
  Currently, the module merely wraps calls to external Git tools. In the future,
  it will provide a much faster way to interact with Git by linking directly
  to libgit. This should be completely opaque to the user, though (performance
  increase notwithstanding).
  
  =cut
  
  
  use Carp qw(carp croak); # but croak is bad - throw instead
  use Error qw(:try);
  use Cwd qw(abs_path cwd);
  use IPC::Open2 qw(open2);
  use Fcntl qw(SEEK_SET SEEK_CUR);
  use Time::Local qw(timegm);
  }
  
  
  =head1 CONSTRUCTORS
  
  =over 4
  
  =item repository ( OPTIONS )
  
  =item repository ( DIRECTORY )
  
  =item repository ()
  
  Construct a new repository object.
  C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
  Possible options are:
  
  B<Repository> - Path to the Git repository.
  
  B<WorkingCopy> - Path to the associated working copy; not strictly required
  as many commands will happily crunch on a bare repository.
  
  B<WorkingSubdir> - Subdirectory in the working copy to work inside.
  Just left undefined if you do not want to limit the scope of operations.
  
  B<Directory> - Path to the Git working directory in its usual setup.
  The C<.git> directory is searched in the directory and all the parent
  directories; if found, C<WorkingCopy> is set to the directory containing
  it and C<Repository> to the C<.git> directory itself. If no C<.git>
  directory was found, the C<Directory> is assumed to be a bare repository,
  C<Repository> is set to point at it and C<WorkingCopy> is left undefined.
  If the C<$GIT_DIR> environment variable is set, things behave as expected
  as well.
  
  You should not use both C<Directory> and either of C<Repository> and
  C<WorkingCopy> - the results of that are undefined.
  
  Alternatively, a directory path may be passed as a single scalar argument
  to the constructor; it is equivalent to setting only the C<Directory> option
  field.
  
  Calling the constructor with no options whatsoever is equivalent to
  calling it with C<< Directory => '.' >>. In general, if you are building
  a standard porcelain command, simply doing C<< Git->repository() >> should
  do the right thing and setup the object to reflect exactly where the user
  is right now.
  
  =cut
  
  sub repository {
  	my $class = shift;
  	my @args = @_;
  	my %opts = ();
  	my $self;
  
  	if (defined $args[0]) {
  		if ($#args % 2 != 1) {
  			# Not a hash.
  			$#args == 0 or throw Error::Simple("bad usage");
  			%opts = ( Directory => $args[0] );
  		} else {
  			%opts = @args;
  		}
  	}
  
  	if (not defined $opts{Repository} and not defined $opts{WorkingCopy}
  		and not defined $opts{Directory}) {
  		$opts{Directory} = '.';
  	}
  
  	if (defined $opts{Directory}) {
  		-d $opts{Directory} or throw Error::Simple("Directory not found: $opts{Directory} $!");
  
  		my $search = Git->repository(WorkingCopy => $opts{Directory});
  		my $dir;
  		try {
  			$dir = $search->command_oneline(['rev-parse', '--git-dir'],
  			                                STDERR => 0);
  		} catch Git::Error::Command with {
  			$dir = undef;
  		};
  
  		if ($dir) {
  			_verify_require();
  			File::Spec->file_name_is_absolute($dir) or $dir = $opts{Directory} . '/' . $dir;
  			$opts{Repository} = abs_path($dir);
  
  			# If --git-dir went ok, this shouldn't die either.
  			my $prefix = $search->command_oneline('rev-parse', '--show-prefix');
  			$dir = abs_path($opts{Directory}) . '/';
  			if ($prefix) {
  				if (substr($dir, -length($prefix)) ne $prefix) {
  					throw Error::Simple("rev-parse confused me - $dir does not have trailing $prefix");
  				}
  				substr($dir, -length($prefix)) = '';
  			}
  			$opts{WorkingCopy} = $dir;
  			$opts{WorkingSubdir} = $prefix;
  
  		} else {
  			# A bare repository? Let's see...
  			$dir = $opts{Directory};
  
  			unless (-d "$dir/refs" and -d "$dir/objects" and -e "$dir/HEAD") {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  			my $search = Git->repository(Repository => $dir);
  			try {
  				$search->command('symbolic-ref', 'HEAD');
  			} catch Git::Error::Command with {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  
  			$opts{Repository} = abs_path($dir);
  		}
  
  		delete $opts{Directory};
  	}
  
  	$self = { opts => \%opts };
  	bless $self, $class;
  }
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item command ( COMMAND [, ARGUMENTS... ] )
  
  =item command ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given Git C<COMMAND> (specify it without the 'git-'
  prefix), optionally with the specified extra C<ARGUMENTS>.
  
  The second more elaborate form can be used if you want to further adjust
  the command execution. Currently, only one option is supported:
  
  B<STDERR> - How to deal with the command's error output. By default (C<undef>)
  it is delivered to the caller's C<STDERR>. A false value (0 or '') will cause
  it to be thrown away. If you want to process it, you can get it in a filehandle
  you specify, but you must be extremely careful; if the error output is not
  very short and you want to read it in the same process as where you called
  C<command()>, you are set up for a nice deadlock!
  
  The method can be called without any instance or on a specified Git repository
  (in that case the command will be run in the repository context).
  
  In scalar context, it returns all the command output in a single string
  (verbatim).
  
  In array context, it returns an array containing lines printed to the
  command's stdout (without trailing newlines).
  
  In both cases, the command's stdin and stderr are the same as the caller's.
  
  =cut
  
  sub command {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	if (not defined wantarray) {
  		# Nothing to pepper the possible exception with.
  		_cmd_close($ctx, $fh);
  
  	} elsif (not wantarray) {
  		local $/;
  		my $text = <$fh>;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			# Pepper with the output:
  			my $E = shift;
  			$E->{'-outputref'} = \$text;
  			throw $E;
  		};
  		return $text;
  
  	} else {
  		my @lines = <$fh>;
  		defined and chomp for @lines;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			my $E = shift;
  			$E->{'-outputref'} = \@lines;
  			throw $E;
  		};
  		return @lines;
  	}
  }
  
  
  =item command_oneline ( COMMAND [, ARGUMENTS... ] )
  
  =item command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but always return a scalar string containing the first line
  of the command's standard output.
  
  =cut
  
  sub command_oneline {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	my $line = <$fh>;
  	defined $line and chomp $line;
  	try {
  		_cmd_close($ctx, $fh);
  	} catch Git::Error::Command with {
  		# Pepper with the output:
  		my $E = shift;
  		$E->{'-outputref'} = \$line;
  		throw $E;
  	};
  	return $line;
  }
  
  
  =item command_output_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but return a pipe filehandle from which the command output can be
  read.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_output_pipe {
  	_command_common_pipe('-|', @_);
  }
  
  
  =item command_input_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return an input pipe filehandle instead; the command output
  is not captured.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_input_pipe {
  	_command_common_pipe('|-', @_);
  }
  
  
  =item command_close_pipe ( PIPE [, CTX ] )
  
  Close the C<PIPE> as returned from C<command_*_pipe()>, checking
  whether the command finished successfully. The optional C<CTX> argument
  is required if you want to see the command name in the error message,
  and it is the second value returned by C<command_*_pipe()> when
  called in array context. The call idiom is:
  
  	my ($fh, $ctx) = $r->command_output_pipe('status');
  	while (<$fh>) { ... }
  	$r->command_close_pipe($fh, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  =cut
  
  sub command_close_pipe {
  	my ($self, $fh, $ctx) = _maybe_self(@_);
  	$ctx ||= '<unknown>';
  	_cmd_close($ctx, $fh);
  }
  
  =item command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return both an input pipe filehandle and an output pipe filehandle.
  
  The function will return C<($pid, $pipe_in, $pipe_out, $ctx)>.
  See C<command_close_bidi_pipe()> for details.
  
  =cut
  
  sub command_bidi_pipe {
  	my ($pid, $in, $out);
  	my ($self) = _maybe_self(@_);
  	local %ENV = %ENV;
  	my $cwd_save = undef;
  	if ($self) {
  		shift;
  		$cwd_save = cwd();
  		_setup_git_cmd_env($self);
  	}
  	$pid = open2($in, $out, 'git', @_);
  	chdir($cwd_save) if $cwd_save;
  	return ($pid, $in, $out, join(' ', @_));
  }
  
  =item command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )
  
  Close the C<PIPE_IN> and C<PIPE_OUT> as returned from C<command_bidi_pipe()>,
  checking whether the command finished successfully. The optional C<CTX>
  argument is required if you want to see the command name in the error message,
  and it is the fourth value returned by C<command_bidi_pipe()>.  The call idiom
  is:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, $out, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  C<PIPE_IN> and C<PIPE_OUT> may be C<undef> if they have been closed prior to
  calling this function.  This may be useful in a query-response type of
  commands where caller first writes a query and later reads response, eg:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	close $out;
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, undef, $ctx);
  
  This idiom may prevent potential dead locks caused by data sent to the output
  pipe not being flushed and thus not reaching the executed command.
  
  =cut
  
  sub command_close_bidi_pipe {
  	local $?;
  	my ($self, $pid, $in, $out, $ctx) = _maybe_self(@_);
  	_cmd_close($ctx, (grep { defined } ($in, $out)));
  	waitpid $pid, 0;
  	if ($? >> 8) {
  		throw Git::Error::Command($ctx, $? >>8);
  	}
  }
  
  
  =item command_noisy ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command() does but do not
  capture the command output - the standard output is not redirected and goes
  to the standard output of the caller application.
  
  While the method is called command_noisy(), you might want to as well use
  it for the most silent Git commands which you know will never pollute your
  stdout but you want to avoid the overhead of the pipe setup when calling them.
  
  The function returns only after the command has finished running.
  
  =cut
  
  sub command_noisy {
  	my ($self, $cmd, @args) = _maybe_self(@_);
  	_check_valid_cmd($cmd);
  
  	my $pid = fork;
  	if (not defined $pid) {
  		throw Error::Simple("fork failed: $!");
  	} elsif ($pid == 0) {
  		_cmd_exec($self, $cmd, @args);
  	}
  	if (waitpid($pid, 0) > 0 and $?>>8 != 0) {
  		throw Git::Error::Command(join(' ', $cmd, @args), $? >> 8);
  	}
  }
  
  
  =item version ()
  
  Return the Git version in use.
  
  =cut
  
  sub version {
  	my $verstr = command_oneline('--version');
  	$verstr =~ s/^git version //;
  	$verstr;
  }
  
  
  =item exec_path ()
  
  Return path to the Git sub-command executables (the same as
  C<git --exec-path>). Useful mostly only internally.
  
  =cut
  
  sub exec_path { command_oneline('--exec-path') }
  
  
  =item html_path ()
  
  Return path to the Git html documentation (the same as
  C<git --html-path>). Useful mostly only internally.
  
  =cut
  
  sub html_path { command_oneline('--html-path') }
  
  
  =item get_tz_offset ( TIME )
  
  Return the time zone offset from GMT in the form +/-HHMM where HH is
  the number of hours from GMT and MM is the number of minutes.  This is
  the equivalent of what strftime("%z", ...) would provide on a GNU
  platform.
  
  If TIME is not supplied, the current local time is used.
  
  =cut
  
  sub get_tz_offset {
  	# some systems don't handle or mishandle %z, so be creative.
  	my $t = shift || time;
  	my $gm = timegm(localtime($t));
  	my $sign = qw( + + - )[ $gm <=> $t ];
  	return sprintf("%s%02d%02d", $sign, (gmtime(abs($t - $gm)))[2,1]);
  }
  
  =item get_record ( FILEHANDLE, INPUT_RECORD_SEPARATOR )
  
  Read one record from FILEHANDLE delimited by INPUT_RECORD_SEPARATOR,
  removing any trailing INPUT_RECORD_SEPARATOR.
  
  =cut
  
  sub get_record {
  	my ($fh, $rs) = @_;
  	local $/ = $rs;
  	my $rec = <$fh>;
  	chomp $rec if defined $rs;
  	$rec;
  }
  
  =item prompt ( PROMPT , ISPASSWORD  )
  
  Query user C<PROMPT> and return answer from user.
  
  Honours GIT_ASKPASS and SSH_ASKPASS environment variables for querying
  the user. If no *_ASKPASS variable is set or an error occoured,
  the terminal is tried as a fallback.
  If C<ISPASSWORD> is set and true, the terminal disables echo.
  
  =cut
  
  sub prompt {
  	my ($prompt, $isPassword) = @_;
  	my $ret;
  	if (exists $ENV{'GIT_ASKPASS'}) {
  		$ret = _prompt($ENV{'GIT_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret && exists $ENV{'SSH_ASKPASS'}) {
  		$ret = _prompt($ENV{'SSH_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret) {
  		print STDERR $prompt;
  		STDERR->flush;
  		if (defined $isPassword && $isPassword) {
  			require Term::ReadKey;
  			Term::ReadKey::ReadMode('noecho');
  			$ret = '';
  			while (defined(my $key = Term::ReadKey::ReadKey(0))) {
  				last if $key =~ /[\012\015]/; # \n\r
  				$ret .= $key;
  			}
  			Term::ReadKey::ReadMode('restore');
  			print STDERR "\n";
  			STDERR->flush;
  		} else {
  			chomp($ret = <STDIN>);
  		}
  	}
  	return $ret;
  }
  
  sub _prompt {
  	my ($askpass, $prompt) = @_;
  	return unless length $askpass;
  	$prompt =~ s/\n/ /g;
  	my $ret;
  	open my $fh, "-|", $askpass, $prompt or return;
  	$ret = <$fh>;
  	$ret =~ s/[\015\012]//g; # strip \r\n, chomp does not work on all systems (i.e. windows) as expected
  	close ($fh);
  	return $ret;
  }
  
  =item repo_path ()
  
  Return path to the git repository. Must be called on a repository instance.
  
  =cut
  
  sub repo_path { $_[0]->{opts}->{Repository} }
  
  
  =item wc_path ()
  
  Return path to the working copy. Must be called on a repository instance.
  
  =cut
  
  sub wc_path { $_[0]->{opts}->{WorkingCopy} }
  
  
  =item wc_subdir ()
  
  Return path to the subdirectory inside of a working copy. Must be called
  on a repository instance.
  
  =cut
  
  sub wc_subdir { $_[0]->{opts}->{WorkingSubdir} ||= '' }
  
  
  =item wc_chdir ( SUBDIR )
  
  Change the working copy subdirectory to work within. The C<SUBDIR> is
  relative to the working copy root directory (not the current subdirectory).
  Must be called on a repository instance attached to a working copy
  and the directory must exist.
  
  =cut
  
  sub wc_chdir {
  	my ($self, $subdir) = @_;
  	$self->wc_path()
  		or throw Error::Simple("bare repository");
  
  	-d $self->wc_path().'/'.$subdir
  		or throw Error::Simple("subdir not found: $subdir $!");
  	# Of course we will not "hold" the subdirectory so anyone
  	# can delete it now and we will never know. But at least we tried.
  
  	$self->{opts}->{WorkingSubdir} = $subdir;
  }
  
  
  =item config ( VARIABLE )
  
  Retrieve the configuration C<VARIABLE> in the same manner as C<config>
  does. In scalar context requires the variable to be set only one time
  (exception is thrown otherwise), in array context returns allows the
  variable to be set multiple times and returns all the values.
  
  =cut
  
  sub config {
  	return _config_common({}, @_);
  }
  
  
  =item config_bool ( VARIABLE )
  
  Retrieve the bool configuration C<VARIABLE>. The return value
  is usable as a boolean in perl (and C<undef> if it's not defined,
  of course).
  
  =cut
  
  sub config_bool {
  	my $val = scalar _config_common({'kind' => '--bool'}, @_);
  
  	# Do not rewrite this as return (defined $val && $val eq 'true')
  	# as some callers do care what kind of falsehood they receive.
  	if (!defined $val) {
  		return undef;
  	} else {
  		return $val eq 'true';
  	}
  }
  
  
  =item config_path ( VARIABLE )
  
  Retrieve the path configuration C<VARIABLE>. The return value
  is an expanded path or C<undef> if it's not defined.
  
  =cut
  
  sub config_path {
  	return _config_common({'kind' => '--path'}, @_);
  }
  
  
  =item config_int ( VARIABLE )
  
  Retrieve the integer configuration C<VARIABLE>. The return value
  is simple decimal number.  An optional value suffix of 'k', 'm',
  or 'g' in the config file will cause the value to be multiplied
  by 1024, 1048576 (1024^2), or 1073741824 (1024^3) prior to output.
  It would return C<undef> if configuration variable is not defined.
  
  =cut
  
  sub config_int {
  	return scalar _config_common({'kind' => '--int'}, @_);
  }
  
  # Common subroutine to implement bulk of what the config* family of methods
  # do. This currently wraps command('config') so it is not so fast.
  sub _config_common {
  	my ($opts) = shift @_;
  	my ($self, $var) = _maybe_self(@_);
  
  	try {
  		my @cmd = ('config', $opts->{'kind'} ? $opts->{'kind'} : ());
  		unshift @cmd, $self if $self;
  		if (wantarray) {
  			return command(@cmd, '--get-all', $var);
  		} else {
  			return command_oneline(@cmd, '--get', $var);
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		if ($E->value() == 1) {
  			# Key not found.
  			return;
  		} else {
  			throw $E;
  		}
  	};
  }
  
  =item get_colorbool ( NAME )
  
  Finds if color should be used for NAMEd operation from the configuration,
  and returns boolean (true for "use color", false for "do not use color").
  
  =cut
  
  sub get_colorbool {
  	my ($self, $var) = @_;
  	my $stdout_to_tty = (-t STDOUT) ? "true" : "false";
  	my $use_color = $self->command_oneline('config', '--get-colorbool',
  					       $var, $stdout_to_tty);
  	return ($use_color eq 'true');
  }
  
  =item get_color ( SLOT, COLOR )
  
  Finds color for SLOT from the configuration, while defaulting to COLOR,
  and returns the ANSI color escape sequence:
  
  	print $repo->get_color("color.interactive.prompt", "underline blue white");
  	print "some text";
  	print $repo->get_color("", "normal");
  
  =cut
  
  sub get_color {
  	my ($self, $slot, $default) = @_;
  	my $color = $self->command_oneline('config', '--get-color', $slot, $default);
  	if (!defined $color) {
  		$color = "";
  	}
  	return $color;
  }
  
  =item remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )
  
  This function returns a hashref of refs stored in a given remote repository.
  The hash is in the format C<refname =\> hash>. For tags, the C<refname> entry
  contains the tag object while a C<refname^{}> entry gives the tagged objects.
  
  C<REPOSITORY> has the same meaning as the appropriate C<git-ls-remote>
  argument; either a URL or a remote name (if called on a repository instance).
  C<GROUPS> is an optional arrayref that can contain 'tags' to return all the
  tags and/or 'heads' to return all the heads. C<REFGLOB> is an optional array
  of strings containing a shell-like glob to further limit the refs returned in
  the hash; the meaning is again the same as the appropriate C<git-ls-remote>
  argument.
  
  This function may or may not be called on a repository instance. In the former
  case, remote names as defined in the repository are recognized as repository
  specifiers.
  
  =cut
  
  sub remote_refs {
  	my ($self, $repo, $groups, $refglobs) = _maybe_self(@_);
  	my @args;
  	if (ref $groups eq 'ARRAY') {
  		foreach (@$groups) {
  			if ($_ eq 'heads') {
  				push (@args, '--heads');
  			} elsif ($_ eq 'tags') {
  				push (@args, '--tags');
  			} else {
  				# Ignore unknown groups for future
  				# compatibility
  			}
  		}
  	}
  	push (@args, $repo);
  	if (ref $refglobs eq 'ARRAY') {
  		push (@args, @$refglobs);
  	}
  
  	my @self = $self ? ($self) : (); # Ultra trickery
  	my ($fh, $ctx) = Git::command_output_pipe(@self, 'ls-remote', @args);
  	my %refs;
  	while (<$fh>) {
  		chomp;
  		my ($hash, $ref) = split(/\t/, $_, 2);
  		$refs{$ref} = $hash;
  	}
  	Git::command_close_pipe(@self, $fh, $ctx);
  	return \%refs;
  }
  
  
  =item ident ( TYPE | IDENTSTR )
  
  =item ident_person ( TYPE | IDENTSTR | IDENTARRAY )
  
  This suite of functions retrieves and parses ident information, as stored
  in the commit and tag objects or produced by C<var GIT_type_IDENT> (thus
  C<TYPE> can be either I<author> or I<committer>; case is insignificant).
  
  The C<ident> method retrieves the ident information from C<git var>
  and either returns it as a scalar string or as an array with the fields parsed.
  Alternatively, it can take a prepared ident string (e.g. from the commit
  object) and just parse it.
  
  C<ident_person> returns the person part of the ident - name and email;
  it can take the same arguments as C<ident> or the array returned by C<ident>.
  
  The synopsis is like:
  
  	my ($name, $email, $time_tz) = ident('author');
  	"$name <$email>" eq ident_person('author');
  	"$name <$email>" eq ident_person($name);
  	$time_tz =~ /^\d+ [+-]\d{4}$/;
  
  =cut
  
  sub ident {
  	my ($self, $type) = _maybe_self(@_);
  	my $identstr;
  	if (lc $type eq lc 'committer' or lc $type eq lc 'author') {
  		my @cmd = ('var', 'GIT_'.uc($type).'_IDENT');
  		unshift @cmd, $self if $self;
  		$identstr = command_oneline(@cmd);
  	} else {
  		$identstr = $type;
  	}
  	if (wantarray) {
  		return $identstr =~ /^(.*) <(.*)> (\d+ [+-]\d{4})$/;
  	} else {
  		return $identstr;
  	}
  }
  
  sub ident_person {
  	my ($self, @ident) = _maybe_self(@_);
  	$#ident == 0 and @ident = $self ? $self->ident($ident[0]) : ident($ident[0]);
  	return "$ident[0] <$ident[1]>";
  }
  
  =item parse_mailboxes
  
  Return an array of mailboxes extracted from a string.
  
  =cut
  
  # Very close to Mail::Address's parser, but we still have minor
  # differences in some cases (see t9000 for examples).
  sub parse_mailboxes {
  	my $re_comment = qr/\((?:[^)]*)\)/;
  	my $re_quote = qr/"(?:[^\"\\]|\\.)*"/;
  	my $re_word = qr/(?:[^]["\s()<>:;@\\,.]|\\.)+/;
  
  	# divide the string in tokens of the above form
  	my $re_token = qr/(?:$re_quote|$re_word|$re_comment|\S)/;
  	my @tokens = map { $_ =~ /\s*($re_token)\s*/g } @_;
  	my $end_of_addr_seen = 0;
  
  	# add a delimiter to simplify treatment for the last mailbox
  	push @tokens, ",";
  
  	my (@addr_list, @phrase, @address, @comment, @buffer) = ();
  	foreach my $token (@tokens) {
  		if ($token =~ /^[,;]$/) {
  			# if buffer still contains undeterminated strings
  			# append it at the end of @address or @phrase
  			if ($end_of_addr_seen) {
  				push @phrase, @buffer;
  			} else {
  				push @address, @buffer;
  			}
  
  			my $str_phrase = join ' ', @phrase;
  			my $str_address = join '', @address;
  			my $str_comment = join ' ', @comment;
  
  			# quote are necessary if phrase contains
  			# special characters
  			if ($str_phrase =~ /[][()<>:;@\\,.\000-\037\177]/) {
  				$str_phrase =~ s/(^|[^\\])"/$1/g;
  				$str_phrase = qq["$str_phrase"];
  			}
  
  			# add "<>" around the address if necessary
  			if ($str_address ne "" && $str_phrase ne "") {
  				$str_address = qq[<$str_address>];
  			}
  
  			my $str_mailbox = "$str_phrase $str_address $str_comment";
  			$str_mailbox =~ s/^\s*|\s*$//g;
  			push @addr_list, $str_mailbox if ($str_mailbox);
  
  			@phrase = @address = @comment = @buffer = ();
  			$end_of_addr_seen = 0;
  		} elsif ($token =~ /^\(/) {
  			push @comment, $token;
  		} elsif ($token eq "<") {
  			push @phrase, (splice @address), (splice @buffer);
  		} elsif ($token eq ">") {
  			$end_of_addr_seen = 1;
  			push @address, (splice @buffer);
  		} elsif ($token eq "@" && !$end_of_addr_seen) {
  			push @address, (splice @buffer), "@";
  		} else {
  			push @buffer, $token;
  		}
  	}
  
  	return @addr_list;
  }
  
  =item hash_object ( TYPE, FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> considering it is
  of the C<TYPE> object type (C<blob>, C<commit>, C<tree>).
  
  The method can be called without any instance or on a specified Git repository,
  it makes zero difference.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_object {
  	my ($self, $type, $file) = _maybe_self(@_);
  	command_oneline('hash-object', '-t', $type, $file);
  }
  
  
  =item hash_and_insert_object ( FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> and add the object to the
  object database.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_and_insert_object {
  	my ($self, $filename) = @_;
  
  	carp "Bad filename \"$filename\"" if $filename =~ /[\r\n]/;
  
  	$self->_open_hash_and_insert_object_if_needed();
  	my ($in, $out) = ($self->{hash_object_in}, $self->{hash_object_out});
  
  	unless (print $out $filename, "\n") {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	chomp(my $hash = <$in>);
  	unless (defined($hash)) {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("in pipe went bad");
  	}
  
  	return $hash;
  }
  
  sub _open_hash_and_insert_object_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{hash_object_pid});
  
  	($self->{hash_object_pid}, $self->{hash_object_in},
  	 $self->{hash_object_out}, $self->{hash_object_ctx}) =
  		$self->command_bidi_pipe(qw(hash-object -w --stdin-paths --no-filters));
  }
  
  sub _close_hash_and_insert_object {
  	my ($self) = @_;
  
  	return unless defined($self->{hash_object_pid});
  
  	my @vars = map { 'hash_object_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  =item cat_blob ( SHA1, FILEHANDLE )
  
  Prints the contents of the blob identified by C<SHA1> to C<FILEHANDLE> and
  returns the number of bytes printed.
  
  =cut
  
  sub cat_blob {
  	my ($self, $sha1, $fh) = @_;
  
  	$self->_open_cat_blob_if_needed();
  	my ($in, $out) = ($self->{cat_blob_in}, $self->{cat_blob_out});
  
  	unless (print $out $sha1, "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	my $description = <$in>;
  	if ($description =~ / missing$/) {
  		carp "$sha1 doesn't exist in the repository";
  		return -1;
  	}
  
  	if ($description !~ /^[0-9a-fA-F]{40} \S+ (\d+)$/) {
  		carp "Unexpected result returned from git cat-file";
  		return -1;
  	}
  
  	my $size = $1;
  
  	my $blob;
  	my $bytesLeft = $size;
  
  	while (1) {
  		last unless $bytesLeft;
  
  		my $bytesToRead = $bytesLeft < 1024 ? $bytesLeft : 1024;
  		my $read = read($in, $blob, $bytesToRead);
  		unless (defined($read)) {
  			$self->_close_cat_blob();
  			throw Error::Simple("in pipe went bad");
  		}
  		unless (print $fh $blob) {
  			$self->_close_cat_blob();
  			throw Error::Simple("couldn't write to passed in filehandle");
  		}
  		$bytesLeft -= $read;
  	}
  
  	# Skip past the trailing newline.
  	my $newline;
  	my $read = read($in, $newline, 1);
  	unless (defined($read)) {
  		$self->_close_cat_blob();
  		throw Error::Simple("in pipe went bad");
  	}
  	unless ($read == 1 && $newline eq "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("didn't find newline after blob");
  	}
  
  	return $size;
  }
  
  sub _open_cat_blob_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{cat_blob_pid});
  
  	($self->{cat_blob_pid}, $self->{cat_blob_in},
  	 $self->{cat_blob_out}, $self->{cat_blob_ctx}) =
  		$self->command_bidi_pipe(qw(cat-file --batch));
  }
  
  sub _close_cat_blob {
  	my ($self) = @_;
  
  	return unless defined($self->{cat_blob_pid});
  
  	my @vars = map { 'cat_blob_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  
  =item credential_read( FILEHANDLE )
  
  Reads credential key-value pairs from C<FILEHANDLE>.  Reading stops at EOF or
  when an empty line is encountered.  Each line must be of the form C<key=value>
  with a non-empty key.  Function returns hash with all read values.  Any white
  space (other than new-line character) is preserved.
  
  =cut
  
  sub credential_read {
  	my ($self, $reader) = _maybe_self(@_);
  	my %credential;
  	while (<$reader>) {
  		chomp;
  		if ($_ eq '') {
  			last;
  		} elsif (!/^([^=]+)=(.*)$/) {
  			throw Error::Simple("unable to parse git credential data:\n$_");
  		}
  		$credential{$1} = $2;
  	}
  	return %credential;
  }
  
  =item credential_write( FILEHANDLE, CREDENTIAL_HASHREF )
  
  Writes credential key-value pairs from hash referenced by
  C<CREDENTIAL_HASHREF> to C<FILEHANDLE>.  Keys and values cannot contain
  new-lines or NUL bytes characters, and key cannot contain equal signs nor be
  empty (if they do Error::Simple is thrown).  Any white space is preserved.  If
  value for a key is C<undef>, it will be skipped.
  
  If C<'url'> key exists it will be written first.  (All the other key-value
  pairs are written in sorted order but you should not depend on that).  Once
  all lines are written, an empty line is printed.
  
  =cut
  
  sub credential_write {
  	my ($self, $writer, $credential) = _maybe_self(@_);
  	my ($key, $value);
  
  	# Check if $credential is valid prior to writing anything
  	while (($key, $value) = each %$credential) {
  		if (!defined $key || !length $key) {
  			throw Error::Simple("credential key empty or undefined");
  		} elsif ($key =~ /[=\n\0]/) {
  			throw Error::Simple("credential key contains invalid characters: $key");
  		} elsif (defined $value && $value =~ /[\n\0]/) {
  			throw Error::Simple("credential value for key=$key contains invalid characters: $value");
  		}
  	}
  
  	for $key (sort {
  		# url overwrites other fields, so it must come first
  		return -1 if $a eq 'url';
  		return  1 if $b eq 'url';
  		return $a cmp $b;
  	} keys %$credential) {
  		if (defined $credential->{$key}) {
  			print $writer $key, '=', $credential->{$key}, "\n";
  		}
  	}
  	print $writer "\n";
  }
  
  sub _credential_run {
  	my ($self, $credential, $op) = _maybe_self(@_);
  	my ($pid, $reader, $writer, $ctx) = command_bidi_pipe('credential', $op);
  
  	credential_write $writer, $credential;
  	close $writer;
  
  	if ($op eq "fill") {
  		%$credential = credential_read $reader;
  	}
  	if (<$reader>) {
  		throw Error::Simple("unexpected output from git credential $op response:\n$_\n");
  	}
  
  	command_close_bidi_pipe($pid, $reader, undef, $ctx);
  }
  
  =item credential( CREDENTIAL_HASHREF [, OPERATION ] )
  
  =item credential( CREDENTIAL_HASHREF, CODE )
  
  Executes C<git credential> for a given set of credentials and specified
  operation.  In both forms C<CREDENTIAL_HASHREF> needs to be a reference to
  a hash which stores credentials.  Under certain conditions the hash can
  change.
  
  In the first form, C<OPERATION> can be C<'fill'>, C<'approve'> or C<'reject'>,
  and function will execute corresponding C<git credential> sub-command.  If
  it's omitted C<'fill'> is assumed.  In case of C<'fill'> the values stored in
  C<CREDENTIAL_HASHREF> will be changed to the ones returned by the C<git
  credential fill> command.  The usual usage would look something like:
  
  	my %cred = (
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	);
  	Git::credential \%cred;
  	if (try_to_authenticate($cred{'username'}, $cred{'password'})) {
  		Git::credential \%cred, 'approve';
  		... do more stuff ...
  	} else {
  		Git::credential \%cred, 'reject';
  	}
  
  In the second form, C<CODE> needs to be a reference to a subroutine.  The
  function will execute C<git credential fill> to fill the provided credential
  hash, then call C<CODE> with C<CREDENTIAL_HASHREF> as the sole argument.  If
  C<CODE>'s return value is defined, the function will execute C<git credential
  approve> (if return value yields true) or C<git credential reject> (if return
  value is false).  If the return value is undef, nothing at all is executed;
  this is useful, for example, if the credential could neither be verified nor
  rejected due to an unrelated network error.  The return value is the same as
  what C<CODE> returns.  With this form, the usage might look as follows:
  
  	if (Git::credential {
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	}, sub {
  		my $cred = shift;
  		return !!try_to_authenticate($cred->{'username'},
  		                             $cred->{'password'});
  	}) {
  		... do more stuff ...
  	}
  
  =cut
  
  sub credential {
  	my ($self, $credential, $op_or_code) = (_maybe_self(@_), 'fill');
  
  	if ('CODE' eq ref $op_or_code) {
  		_credential_run $credential, 'fill';
  		my $ret = $op_or_code->($credential);
  		if (defined $ret) {
  			_credential_run $credential, $ret ? 'approve' : 'reject';
  		}
  		return $ret;
  	} else {
  		_credential_run $credential, $op_or_code;
  	}
  }
  
  { # %TEMP_* Lexical Context
  
  my (%TEMP_FILEMAP, %TEMP_FILES);
  
  =item temp_acquire ( NAME )
  
  Attempts to retrieve the temporary file mapped to the string C<NAME>. If an
  associated temp file has not been created this session or was closed, it is
  created, cached, and set for autoflush and binmode.
  
  Internally locks the file mapped to C<NAME>. This lock must be released with
  C<temp_release()> when the temp file is no longer needed. Subsequent attempts
  to retrieve temporary files mapped to the same C<NAME> while still locked will
  cause an error. This locking mechanism provides a weak guarantee and is not
  threadsafe. It does provide some error checking to help prevent temp file refs
  writing over one another.
  
  In general, the L<File::Handle> returned should not be closed by consumers as
  it defeats the purpose of this caching mechanism. If you need to close the temp
  file handle, then you should use L<File::Temp> or another temp file faculty
  directly. If a handle is closed and then requested again, then a warning will
  issue.
  
  =cut
  
  sub temp_acquire {
  	my $temp_fd = _temp_cache(@_);
  
  	$TEMP_FILES{$temp_fd}{locked} = 1;
  	$temp_fd;
  }
  
  =item temp_is_locked ( NAME )
  
  Returns true if the internal lock created by a previous C<temp_acquire()>
  call with C<NAME> is still in effect.
  
  When temp_acquire is called on a C<NAME>, it internally locks the temporary
  file mapped to C<NAME>.  That lock will not be released until C<temp_release()>
  is called with either the original C<NAME> or the L<File::Handle> that was
  returned from the original call to temp_acquire.
  
  Subsequent attempts to call C<temp_acquire()> with the same C<NAME> will fail
  unless there has been an intervening C<temp_release()> call for that C<NAME>
  (or its corresponding L<File::Handle> that was returned by the original
  C<temp_acquire()> call).
  
  If true is returned by C<temp_is_locked()> for a C<NAME>, an attempt to
  C<temp_acquire()> the same C<NAME> will cause an error unless
  C<temp_release> is first called on that C<NAME> (or its corresponding
  L<File::Handle> that was returned by the original C<temp_acquire()> call).
  
  =cut
  
  sub temp_is_locked {
  	my ($self, $name) = _maybe_self(@_);
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  
  	defined $$temp_fd && $$temp_fd->opened && $TEMP_FILES{$$temp_fd}{locked};
  }
  
  =item temp_release ( NAME )
  
  =item temp_release ( FILEHANDLE )
  
  Releases a lock acquired through C<temp_acquire()>. Can be called either with
  the C<NAME> mapping used when acquiring the temp file or with the C<FILEHANDLE>
  referencing a locked temp file.
  
  Warns if an attempt is made to release a file that is not locked.
  
  The temp file will be truncated before being released. This can help to reduce
  disk I/O where the system is smart enough to detect the truncation while data
  is in the output buffers. Beware that after the temp file is released and
  truncated, any operations on that file may fail miserably until it is
  re-acquired. All contents are lost between each release and acquire mapped to
  the same string.
  
  =cut
  
  sub temp_release {
  	my ($self, $temp_fd, $trunc) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILES{$temp_fd};
  	}
  	unless ($TEMP_FILES{$temp_fd}{locked}) {
  		carp "Attempt to release temp file '",
  			$temp_fd, "' that has not been locked";
  	}
  	temp_reset($temp_fd) if $trunc and $temp_fd->opened;
  
  	$TEMP_FILES{$temp_fd}{locked} = 0;
  	undef;
  }
  
  sub _temp_cache {
  	my ($self, $name) = _maybe_self(@_);
  
  	_verify_require();
  
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  	if (defined $$temp_fd and $$temp_fd->opened) {
  		if ($TEMP_FILES{$$temp_fd}{locked}) {
  			throw Error::Simple("Temp file with moniker '" .
  				$name . "' already in use");
  		}
  	} else {
  		if (defined $$temp_fd) {
  			# then we're here because of a closed handle.
  			carp "Temp file '", $name,
  				"' was closed. Opening replacement.";
  		}
  		my $fname;
  
  		my $tmpdir;
  		if (defined $self) {
  			$tmpdir = $self->repo_path();
  		}
  
  		my $n = $name;
  		$n =~ s/\W/_/g; # no strange chars
  
  		($$temp_fd, $fname) = File::Temp::tempfile(
  			"Git_${n}_XXXXXX", UNLINK => 1, DIR => $tmpdir,
  			) or throw Error::Simple("couldn't open new temp file");
  
  		$$temp_fd->autoflush;
  		binmode $$temp_fd;
  		$TEMP_FILES{$$temp_fd}{fname} = $fname;
  	}
  	$$temp_fd;
  }
  
  sub _verify_require {
  	eval { require File::Temp; require File::Spec; };
  	$@ and throw Error::Simple($@);
  }
  
  =item temp_reset ( FILEHANDLE )
  
  Truncates and resets the position of the C<FILEHANDLE>.
  
  =cut
  
  sub temp_reset {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	truncate $temp_fd, 0
  		or throw Error::Simple("couldn't truncate file");
  	sysseek($temp_fd, 0, SEEK_SET) and seek($temp_fd, 0, SEEK_SET)
  		or throw Error::Simple("couldn't seek to beginning of file");
  	sysseek($temp_fd, 0, SEEK_CUR) == 0 and tell($temp_fd) == 0
  		or throw Error::Simple("expected file position to be reset");
  }
  
  =item temp_path ( NAME )
  
  =item temp_path ( FILEHANDLE )
  
  Returns the filename associated with the given tempfile.
  
  =cut
  
  sub temp_path {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILEMAP{$temp_fd};
  	}
  	$TEMP_FILES{$temp_fd}{fname};
  }
  
  sub END {
  	unlink values %TEMP_FILEMAP if %TEMP_FILEMAP;
  }
  
  } # %TEMP_* Lexical Context
  
  =item prefix_lines ( PREFIX, STRING [, STRING... ])
  
  Prefixes lines in C<STRING> with C<PREFIX>.
  
  =cut
  
  sub prefix_lines {
  	my $prefix = shift;
  	my $string = join("\n", @_);
  	$string =~ s/^/$prefix/mg;
  	return $string;
  }
  
  =item unquote_path ( PATH )
  
  Unquote a quoted path containing c-escapes as returned by ls-files etc.
  when not using -z or when parsing the output of diff -u.
  
  =cut
  
  {
  	my %cquote_map = (
  		"a" => chr(7),
  		"b" => chr(8),
  		"t" => chr(9),
  		"n" => chr(10),
  		"v" => chr(11),
  		"f" => chr(12),
  		"r" => chr(13),
  		"\\" => "\\",
  		"\042" => "\042",
  	);
  
  	sub unquote_path {
  		local ($_) = @_;
  		my ($retval, $remainder);
  		if (!/^\042(.*)\042$/) {
  			return $_;
  		}
  		($_, $retval) = ($1, "");
  		while (/^([^\\]*)\\(.*)$/) {
  			$remainder = $2;
  			$retval .= $1;
  			for ($remainder) {
  				if (/^([0-3][0-7][0-7])(.*)$/) {
  					$retval .= chr(oct($1));
  					$_ = $2;
  					last;
  				}
  				if (/^([\\\042abtnvfr])(.*)$/) {
  					$retval .= $cquote_map{$1};
  					$_ = $2;
  					last;
  				}
  				# This is malformed
  				throw Error::Simple("invalid quoted path $_[0]");
  			}
  			$_ = $remainder;
  		}
  		$retval .= $_;
  		return $retval;
  	}
  }
  
  =item get_comment_line_char ( )
  
  Gets the core.commentchar configuration value.
  The value falls-back to '#' if core.commentchar is set to 'auto'.
  
  =cut
  
  sub get_comment_line_char {
  	my $comment_line_char = config("core.commentchar") || '#';
  	$comment_line_char = '#' if ($comment_line_char eq 'auto');
  	$comment_line_char = '#' if (length($comment_line_char) != 1);
  	return $comment_line_char;
  }
  
  =item comment_lines ( STRING [, STRING... ])
  
  Comments lines following core.commentchar configuration.
  
  =cut
  
  sub comment_lines {
  	my $comment_line_char = get_comment_line_char;
  	return prefix_lines("$comment_line_char ", @_);
  }
  
  =back
  
  =head1 ERROR HANDLING
  
  All functions are supposed to throw Perl exceptions in case of errors.
  See the L<Error> module on how to catch those. Most exceptions are mere
  L<Error::Simple> instances.
  
  However, the C<command()>, C<command_oneline()> and C<command_noisy()>
  functions suite can throw C<Git::Error::Command> exceptions as well: those are
  thrown when the external command returns an error code and contain the error
  code as well as access to the captured command's output. The exception class
  provides the usual C<stringify> and C<value> (command's exit code) methods and
  in addition also a C<cmd_output> method that returns either an array or a
  string with the captured command output (depending on the original function
  call context; C<command_noisy()> returns C<undef>) and $<cmdline> which
  returns the command and its arguments (but without proper quoting).
  
  Note that the C<command_*_pipe()> functions cannot throw this exception since
  it has no idea whether the command failed or not. You will only find out
  at the time you C<close> the pipe; if you want to have that automated,
  use C<command_close_pipe()>, which can throw the exception.
  
  =cut
  
  {
  	package Git::Error::Command;
  
  	@Git::Error::Command::ISA = qw(Error);
  
  	sub new {
  		my $self = shift;
  		my $cmdline = '' . shift;
  		my $value = 0 + shift;
  		my $outputref = shift;
  		my(@args) = ();
  
  		local $Error::Depth = $Error::Depth + 1;
  
  		push(@args, '-cmdline', $cmdline);
  		push(@args, '-value', $value);
  		push(@args, '-outputref', $outputref);
  
  		$self->SUPER::new(-text => 'command returned error', @args);
  	}
  
  	sub stringify {
  		my $self = shift;
  		my $text = $self->SUPER::stringify;
  		$self->cmdline() . ': ' . $text . ': ' . $self->value() . "\n";
  	}
  
  	sub cmdline {
  		my $self = shift;
  		$self->{'-cmdline'};
  	}
  
  	sub cmd_output {
  		my $self = shift;
  		my $ref = $self->{'-outputref'};
  		defined $ref or undef;
  		if (ref $ref eq 'ARRAY') {
  			return @$ref;
  		} else { # SCALAR
  			return $$ref;
  		}
  	}
  }
  
  =over 4
  
  =item git_cmd_try { CODE } ERRMSG
  
  This magical statement will automatically catch any C<Git::Error::Command>
  exceptions thrown by C<CODE> and make your program die with C<ERRMSG>
  on its lips; the message will have %s substituted for the command line
  and %d for the exit status. This statement is useful mostly for producing
  more user-friendly error messages.
  
  In case of no exception caught the statement returns C<CODE>'s return value.
  
  Note that this is the only auto-exported function.
  
  =cut
  
  sub git_cmd_try(&$) {
  	my ($code, $errmsg) = @_;
  	my @result;
  	my $err;
  	my $array = wantarray;
  	try {
  		if ($array) {
  			@result = &$code;
  		} else {
  			$result[0] = &$code;
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		$err = $errmsg;
  		$err =~ s/\%s/$E->cmdline()/ge;
  		$err =~ s/\%d/$E->value()/ge;
  		# We can't croak here since Error.pm would mangle
  		# that to Error::Simple.
  	};
  	$err and croak $err;
  	return $array ? @result : $result[0];
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2006 by Petr Baudis E<lt>pasky@suse.czE<gt>.
  
  This module is free software; it may be used, copied, modified
  and distributed under the terms of the GNU General Public Licence,
  either version 2, or (at your option) any later version.
  
  =cut
  
  
  # Take raw method argument list and return ($obj, @args) in case
  # the method was called upon an instance and (undef, @args) if
  # it was called directly.
  sub _maybe_self {
  	UNIVERSAL::isa($_[0], 'Git') ? @_ : (undef, @_);
  }
  
  # Check if the command id is something reasonable.
  sub _check_valid_cmd {
  	my ($cmd) = @_;
  	$cmd =~ /^[a-z0-9A-Z_-]+$/ or throw Error::Simple("bad command: $cmd");
  }
  
  # Common backend for the pipe creators.
  sub _command_common_pipe {
  	my $direction = shift;
  	my ($self, @p) = _maybe_self(@_);
  	my (%opts, $cmd, @args);
  	if (ref $p[0]) {
  		($cmd, @args) = @{shift @p};
  		%opts = ref $p[0] ? %{$p[0]} : @p;
  	} else {
  		($cmd, @args) = @p;
  	}
  	_check_valid_cmd($cmd);
  
  	my $fh;
  	if ($^O eq 'MSWin32') {
  		# ActiveState Perl
  		#defined $opts{STDERR} and
  		#	warn 'ignoring STDERR option - running w/ ActiveState';
  		$direction eq '-|' or
  			die 'input pipe for ActiveState not implemented';
  		# the strange construction with *ACPIPE is just to
  		# explain the tie below that we want to bind to
  		# a handle class, not scalar. It is not known if
  		# it is something specific to ActiveState Perl or
  		# just a Perl quirk.
  		tie (*ACPIPE, 'Git::activestate_pipe', $cmd, @args);
  		$fh = *ACPIPE;
  
  	} else {
  		my $pid = open($fh, $direction);
  		if (not defined $pid) {
  			throw Error::Simple("open failed: $!");
  		} elsif ($pid == 0) {
  			if ($opts{STDERR}) {
  				open (STDERR, '>&', $opts{STDERR})
  					or die "dup failed: $!";
  			} elsif (defined $opts{STDERR}) {
  				open (STDERR, '>', '/dev/null')
  					or die "opening /dev/null failed: $!";
  			}
  			_cmd_exec($self, $cmd, @args);
  		}
  	}
  	return wantarray ? ($fh, join(' ', $cmd, @args)) : $fh;
  }
  
  # When already in the subprocess, set up the appropriate state
  # for the given repository and execute the git command.
  sub _cmd_exec {
  	my ($self, @args) = @_;
  	_setup_git_cmd_env($self);
  	_execv_git_cmd(@args);
  	die qq[exec "@args" failed: $!];
  }
  
  # set up the appropriate state for git command
  sub _setup_git_cmd_env {
  	my $self = shift;
  	if ($self) {
  		$self->repo_path() and $ENV{'GIT_DIR'} = $self->repo_path();
  		$self->repo_path() and $self->wc_path()
  			and $ENV{'GIT_WORK_TREE'} = $self->wc_path();
  		$self->wc_path() and chdir($self->wc_path());
  		$self->wc_subdir() and chdir($self->wc_subdir());
  	}
  }
  
  # Execute the given Git command ($_[0]) with arguments ($_[1..])
  # by searching for it at proper places.
  sub _execv_git_cmd { exec('git', @_); }
  
  # Close pipe to a subprocess.
  sub _cmd_close {
  	my $ctx = shift @_;
  	foreach my $fh (@_) {
  		if (close $fh) {
  			# nop
  		} elsif ($!) {
  			# It's just close, no point in fatalities
  			carp "error closing pipe: $!";
  		} elsif ($? >> 8) {
  			# The caller should pepper this.
  			throw Git::Error::Command($ctx, $? >> 8);
  		}
  		# else we might e.g. closed a live stream; the command
  		# dying of SIGPIPE would drive us here.
  	}
  }
  
  
  sub DESTROY {
  	my ($self) = @_;
  	$self->_close_hash_and_insert_object();
  	$self->_close_cat_blob();
  }
  
  
  # Pipe implementation for ActiveState Perl.
  
  package Git::activestate_pipe;
  use strict;
  
  sub TIEHANDLE {
  	my ($class, @params) = @_;
  	# FIXME: This is probably horrible idea and the thing will explode
  	# at the moment you give it arguments that require some quoting,
  	# but I have no ActiveState clue... --pasky
  	# Let's just hope ActiveState Perl does at least the quoting
  	# correctly.
  	my @data = qx{git @params};
  	bless { i => 0, data => \@data }, $class;
  }
  
  sub READLINE {
  	my $self = shift;
  	if ($self->{i} >= scalar @{$self->{data}}) {
  		return undef;
  	}
  	my $i = $self->{i};
  	if (wantarray) {
  		$self->{i} = $#{$self->{'data'}} + 1;
  		return splice(@{$self->{'data'}}, $i);
  	}
  	$self->{i} = $i + 1;
  	return $self->{'data'}->[ $i ];
  }
  
  sub CLOSE {
  	my $self = shift;
  	delete $self->{data};
  	delete $self->{i};
  }
  
  sub EOF {
  	my $self = shift;
  	return ($self->{i} >= scalar @{$self->{data}});
  }
  
  
  1; # Famous last words
GIT

$fatpacked{"Git/I18N.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_I18N';
  package Git::I18N;
  use 5.008;
  use strict;
  use warnings;
  BEGIN {
  	require Exporter;
  	if ($] < 5.008003) {
  		*import = \&Exporter::import;
  	} else {
  		# Exporter 5.57 which supports this invocation was
  		# released with perl 5.8.3
  		Exporter->import('import');
  	}
  }
  
  our @EXPORT = qw(__ __n N__);
  our @EXPORT_OK = @EXPORT;
  
  sub __bootstrap_locale_messages {
  	our $TEXTDOMAIN = 'git';
  	our $TEXTDOMAINDIR = $ENV{GIT_TEXTDOMAINDIR} || '++LOCALEDIR++';
  
  	require POSIX;
  	POSIX->import(qw(setlocale));
  	# Non-core prerequisite module
  	require Locale::Messages;
  	Locale::Messages->import(qw(:locale_h :libintl_h));
  
  	setlocale(LC_MESSAGES(), '');
  	setlocale(LC_CTYPE(), '');
  	textdomain($TEXTDOMAIN);
  	bindtextdomain($TEXTDOMAIN => $TEXTDOMAINDIR);
  
  	return;
  }
  
  BEGIN
  {
  	# Used by our test script to see if it should test fallbacks or
  	# not.
  	our $__HAS_LIBRARY = 1;
  
  	local $@;
  	eval {
  		__bootstrap_locale_messages();
  		*__ = \&Locale::Messages::gettext;
  		*__n = \&Locale::Messages::ngettext;
  		1;
  	} or do {
  		# Tell test.pl that we couldn't load the gettext library.
  		$Git::I18N::__HAS_LIBRARY = 0;
  
  		# Just a fall-through no-op
  		*__ = sub ($) { $_[0] };
  		*__n = sub ($$$) { $_[2] == 1 ? $_[0] : $_[1] };
  	};
  
  	sub N__($) { return shift; }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Git::I18N - Perl interface to Git's Gettext localizations
  
  =head1 SYNOPSIS
  
  	use Git::I18N;
  
  	print __("Welcome to Git!\n");
  
  	printf __("The following error occurred: %s\n"), $error;
  
  	printf __n("committed %d file\n", "committed %d files\n", $files), $files;
  
  
  =head1 DESCRIPTION
  
  Git's internal Perl interface to gettext via L<Locale::Messages>. If
  L<Locale::Messages> can't be loaded (it's not a core module) we
  provide stub passthrough fallbacks.
  
  This is a distilled interface to gettext, see C<info '(gettext)Perl'>
  for the full interface. This module implements only a small part of
  it.
  
  =head1 FUNCTIONS
  
  =head2 __($)
  
  L<Locale::Messages>'s gettext function if all goes well, otherwise our
  passthrough fallback function.
  
  =head2 __n($$$)
  
  L<Locale::Messages>'s ngettext function or passthrough fallback function.
  
  =head2 N__($)
  
  No-operation that only returns its argument. Use this if you want xgettext to
  extract the text to the pot template but do not want to trigger retrival of the
  translation at run time.
  
  =head1 AUTHOR
  
  E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avarab@gmail.com>
  
  =head1 COPYRIGHT
  
  Copyright 2010 E<AElig>var ArnfjE<ouml>rE<eth> Bjarmason <avarab@gmail.com>
  
  =cut
GIT_I18N

$fatpacked{"Git/IndexInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_INDEXINFO';
  package Git::IndexInfo;
  use strict;
  use warnings;
  use Git qw/command_input_pipe command_close_pipe/;
  
  sub new {
  	my ($class) = @_;
  	my ($gui, $ctx) = command_input_pipe(qw/update-index -z --index-info/);
  	bless { gui => $gui, ctx => $ctx, nr => 0}, $class;
  }
  
  sub remove {
  	my ($self, $path) = @_;
  	if (print { $self->{gui} } '0 ', 0 x 40, "\t", $path, "\0") {
  		return ++$self->{nr};
  	}
  	undef;
  }
  
  sub update {
  	my ($self, $mode, $hash, $path) = @_;
  	if (print { $self->{gui} } $mode, ' ', $hash, "\t", $path, "\0") {
  		return ++$self->{nr};
  	}
  	undef;
  }
  
  sub DESTROY {
  	my ($self) = @_;
  	command_close_pipe($self->{gui}, $self->{ctx});
  }
  
  1;
GIT_INDEXINFO

$fatpacked{"Git/SVN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN';
  package Git::SVN;
  use strict;
  use warnings;
  use Fcntl qw/:DEFAULT :seek/;
  use constant rev_map_fmt => 'NH40';
  use vars qw/$_no_metadata
              $_repack $_repack_flags $_use_svm_props $_head
              $_use_svnsync_props $no_reuse_existing
  	    $_use_log_author $_add_author_from $_localtime/;
  use Carp qw/croak/;
  use File::Path qw/mkpath/;
  use IPC::Open3;
  use Memoize;  # core since 5.8.0, Jul 2002
  use POSIX qw(:signal_h);
  use Time::Local;
  
  use Git qw(
      command
      command_oneline
      command_noisy
      command_output_pipe
      command_close_pipe
      get_tz_offset
  );
  use Git::SVN::Utils qw(
  	fatal
  	can_compress
  	join_paths
  	canonicalize_path
  	canonicalize_url
  	add_path_to_url
  );
  
  my $memo_backend;
  our $_follow_parent  = 1;
  our $_minimize_url   = 'unset';
  our $default_repo_id = 'svn';
  our $default_ref_id  = $ENV{GIT_SVN_ID} || 'git-svn';
  
  my ($_gc_nr, $_gc_period);
  
  # properties that we do not log:
  my %SKIP_PROP;
  BEGIN {
  	%SKIP_PROP = map { $_ => 1 } qw/svn:wc:ra_dav:version-url
  	                                svn:special svn:executable
  	                                svn:entry:committed-rev
  	                                svn:entry:last-author
  	                                svn:entry:uuid
  	                                svn:entry:committed-date/;
  
  	# some options are read globally, but can be overridden locally
  	# per [svn-remote "..."] section.  Command-line options will *NOT*
  	# override options set in an [svn-remote "..."] section
  	no strict 'refs';
  	for my $option (qw/follow_parent no_metadata use_svm_props
  			   use_svnsync_props/) {
  		my $key = $option;
  		$key =~ tr/_//d;
  		my $prop = "-$option";
  		*$option = sub {
  			my ($self) = @_;
  			return $self->{$prop} if exists $self->{$prop};
  			my $k = "svn-remote.$self->{repo_id}.$key";
  			eval { command_oneline(qw/config --get/, $k) };
  			if ($@) {
  				$self->{$prop} = ${"Git::SVN::_$option"};
  			} else {
  				my $v = command_oneline(qw/config --bool/,$k);
  				$self->{$prop} = $v eq 'false' ? 0 : 1;
  			}
  			return $self->{$prop};
  		}
  	}
  }
  
  
  my (%LOCKFILES, %INDEX_FILES);
  END {
  	unlink keys %LOCKFILES if %LOCKFILES;
  	unlink keys %INDEX_FILES if %INDEX_FILES;
  }
  
  sub resolve_local_globs {
  	my ($url, $fetch, $glob_spec) = @_;
  	return unless defined $glob_spec;
  	my $ref = $glob_spec->{ref};
  	my $path = $glob_spec->{path};
  	foreach (command(qw#for-each-ref --format=%(refname) refs/#)) {
  		next unless m#^$ref->{regex}$#;
  		my $p = $1;
  		my $pathname = desanitize_refname($path->full_path($p));
  		my $refname = desanitize_refname($ref->full_path($p));
  		if (my $existing = $fetch->{$pathname}) {
  			if ($existing ne $refname) {
  				die "Refspec conflict:\n",
  				    "existing: $existing\n",
  				    " globbed: $refname\n";
  			}
  			my $u = (::cmt_metadata("$refname"))[0];
  			if (!defined($u)) {
  				warn
  "W: $refname: no associated commit metadata from SVN, skipping\n";
  				next;
  			}
  			$u =~ s!^\Q$url\E(/|$)!! or die
  			  "$refname: '$url' not found in '$u'\n";
  			if ($pathname ne $u) {
  				warn "W: Refspec glob conflict ",
  				     "(ref: $refname):\n",
  				     "expected path: $pathname\n",
  				     "    real path: $u\n",
  				     "Continuing ahead with $u\n";
  				next;
  			}
  		} else {
  			$fetch->{$pathname} = $refname;
  		}
  	}
  }
  
  sub parse_revision_argument {
  	my ($base, $head) = @_;
  	if (!defined $::_revision || $::_revision eq 'BASE:HEAD') {
  		return ($base, $head);
  	}
  	return ($1, $2) if ($::_revision =~ /^(\d+):(\d+)$/);
  	return ($::_revision, $::_revision) if ($::_revision =~ /^\d+$/);
  	return ($head, $head) if ($::_revision eq 'HEAD');
  	return ($base, $1) if ($::_revision =~ /^BASE:(\d+)$/);
  	return ($1, $head) if ($::_revision =~ /^(\d+):HEAD$/);
  	die "revision argument: $::_revision not understood by git-svn\n";
  }
  
  sub fetch_all {
  	my ($repo_id, $remotes) = @_;
  	if (ref $repo_id) {
  		my $gs = $repo_id;
  		$repo_id = undef;
  		$repo_id = $gs->{repo_id};
  	}
  	$remotes ||= read_all_remotes();
  	my $remote = $remotes->{$repo_id} or
  	             die "[svn-remote \"$repo_id\"] unknown\n";
  	my $fetch = $remote->{fetch};
  	my $url = $remote->{url} or die "svn-remote.$repo_id.url not defined\n";
  	my (@gs, @globs);
  	my $ra = Git::SVN::Ra->new($url);
  	my $uuid = $ra->get_uuid;
  	my $head = $ra->get_latest_revnum;
  
  	# ignore errors, $head revision may not even exist anymore
  	eval { $ra->get_log("", $head, 0, 1, 0, 1, sub { $head = $_[1] }) };
  	warn "W: $@\n" if $@;
  
  	my $base = defined $fetch ? $head : 0;
  
  	# read the max revs for wildcard expansion (branches/*, tags/*)
  	foreach my $t (qw/branches tags/) {
  		defined $remote->{$t} or next;
  		push @globs, @{$remote->{$t}};
  
  		my $max_rev = eval { tmp_config(qw/--int --get/,
  		                         "svn-remote.$repo_id.${t}-maxRev") };
  		if (defined $max_rev && ($max_rev < $base)) {
  			$base = $max_rev;
  		} elsif (!defined $max_rev) {
  			$base = 0;
  		}
  	}
  
  	if ($fetch) {
  		foreach my $p (sort keys %$fetch) {
  			my $gs = Git::SVN->new($fetch->{$p}, $repo_id, $p);
  			my $lr = $gs->rev_map_max;
  			if (defined $lr) {
  				$base = $lr if ($lr < $base);
  			}
  			push @gs, $gs;
  		}
  	}
  
  	($base, $head) = parse_revision_argument($base, $head);
  	$ra->gs_fetch_loop_common($base, $head, \@gs, \@globs);
  }
  
  sub read_all_remotes {
  	my $r = {};
  	my $use_svm_props = eval { command_oneline(qw/config --bool
  	    svn.useSvmProps/) };
  	$use_svm_props = $use_svm_props eq 'true' if $use_svm_props;
  	my $svn_refspec = qr{\s*(.*?)\s*:\s*(.+?)\s*};
  	foreach (grep { s/^svn-remote\.// } command(qw/config -l/)) {
  		if (m!^(.+)\.fetch=$svn_refspec$!) {
  			my ($remote, $local_ref, $remote_ref) = ($1, $2, $3);
  			die("svn-remote.$remote: remote ref '$remote_ref' "
  			    . "must start with 'refs/'\n")
  				unless $remote_ref =~ m{^refs/};
  			$local_ref = uri_decode($local_ref);
  			$r->{$remote}->{fetch}->{$local_ref} = $remote_ref;
  			$r->{$remote}->{svm} = {} if $use_svm_props;
  		} elsif (m!^(.+)\.usesvmprops=\s*(.*)\s*$!) {
  			$r->{$1}->{svm} = {};
  		} elsif (m!^(.+)\.url=\s*(.*)\s*$!) {
  			$r->{$1}->{url} = canonicalize_url($2);
  		} elsif (m!^(.+)\.pushurl=\s*(.*)\s*$!) {
  			$r->{$1}->{pushurl} = canonicalize_url($2);
  		} elsif (m!^(.+)\.ignore-refs=\s*(.*)\s*$!) {
  			$r->{$1}->{ignore_refs_regex} = $2;
  		} elsif (m!^(.+)\.(branches|tags)=$svn_refspec$!) {
  			my ($remote, $t, $local_ref, $remote_ref) =
  			                                     ($1, $2, $3, $4);
  			die("svn-remote.$remote: remote ref '$remote_ref' ($t) "
  			    . "must start with 'refs/'\n")
  				unless $remote_ref =~ m{^refs/};
  			$local_ref = uri_decode($local_ref);
  
  			require Git::SVN::GlobSpec;
  			my $rs = {
  			    t => $t,
  			    remote => $remote,
  			    path => Git::SVN::GlobSpec->new($local_ref, 1),
  			    ref => Git::SVN::GlobSpec->new($remote_ref, 0) };
  			if (length($rs->{ref}->{right}) != 0) {
  				die "The '*' glob character must be the last ",
  				    "character of '$remote_ref'\n";
  			}
  			push @{ $r->{$remote}->{$t} }, $rs;
  		}
  	}
  
  	map {
  		if (defined $r->{$_}->{svm}) {
  			my $svm;
  			eval {
  				my $section = "svn-remote.$_";
  				$svm = {
  					source => tmp_config('--get',
  					    "$section.svm-source"),
  					replace => tmp_config('--get',
  					    "$section.svm-replace"),
  				}
  			};
  			$r->{$_}->{svm} = $svm;
  		}
  	} keys %$r;
  
  	foreach my $remote (keys %$r) {
  		foreach ( grep { defined $_ }
  			  map { $r->{$remote}->{$_} } qw(branches tags) ) {
  			foreach my $rs ( @$_ ) {
  				$rs->{ignore_refs_regex} =
  				    $r->{$remote}->{ignore_refs_regex};
  			}
  		}
  	}
  
  	$r;
  }
  
  sub init_vars {
  	$_gc_nr = $_gc_period = 1000;
  	if (defined $_repack || defined $_repack_flags) {
  	       warn "Repack options are obsolete; they have no effect.\n";
  	}
  }
  
  sub verify_remotes_sanity {
  	return unless -d $ENV{GIT_DIR};
  	my %seen;
  	foreach (command(qw/config -l/)) {
  		if (m!^svn-remote\.(?:.+)\.fetch=.*:refs/remotes/(\S+)\s*$!) {
  			if ($seen{$1}) {
  				die "Remote ref refs/remote/$1 is tracked by",
  				    "\n  \"$_\"\nand\n  \"$seen{$1}\"\n",
  				    "Please resolve this ambiguity in ",
  				    "your git configuration file before ",
  				    "continuing\n";
  			}
  			$seen{$1} = $_;
  		}
  	}
  }
  
  sub find_existing_remote {
  	my ($url, $remotes) = @_;
  	return undef if $no_reuse_existing;
  	my $existing;
  	foreach my $repo_id (keys %$remotes) {
  		my $u = $remotes->{$repo_id}->{url} or next;
  		next if $u ne $url;
  		$existing = $repo_id;
  		last;
  	}
  	$existing;
  }
  
  sub init_remote_config {
  	my ($self, $url, $no_write) = @_;
  	$url = canonicalize_url($url);
  	my $r = read_all_remotes();
  	my $existing = find_existing_remote($url, $r);
  	if ($existing) {
  		unless ($no_write) {
  			print STDERR "Using existing ",
  				     "[svn-remote \"$existing\"]\n";
  		}
  		$self->{repo_id} = $existing;
  	} elsif ($_minimize_url) {
  		my $min_url = Git::SVN::Ra->new($url)->minimize_url;
  		$existing = find_existing_remote($min_url, $r);
  		if ($existing) {
  			unless ($no_write) {
  				print STDERR "Using existing ",
  					     "[svn-remote \"$existing\"]\n";
  			}
  			$self->{repo_id} = $existing;
  		}
  		if ($min_url ne $url) {
  			unless ($no_write) {
  				print STDERR "Using higher level of URL: ",
  					     "$url => $min_url\n";
  			}
  			my $old_path = $self->path;
  			$url =~ s!^\Q$min_url\E(/|$)!!;
  			$url = join_paths($url, $old_path);
  			$self->path($url);
  			$url = $min_url;
  		}
  	}
  	my $orig_url;
  	if (!$existing) {
  		# verify that we aren't overwriting anything:
  		$orig_url = eval {
  			command_oneline('config', '--get',
  					"svn-remote.$self->{repo_id}.url")
  		};
  		if ($orig_url && ($orig_url ne $url)) {
  			die "svn-remote.$self->{repo_id}.url already set: ",
  			    "$orig_url\nwanted to set to: $url\n";
  		}
  	}
  	my ($xrepo_id, $xpath) = find_ref($self->refname);
  	if (!$no_write && defined $xpath) {
  		die "svn-remote.$xrepo_id.fetch already set to track ",
  		    "$xpath:", $self->refname, "\n";
  	}
  	unless ($no_write) {
  		command_noisy('config',
  			      "svn-remote.$self->{repo_id}.url", $url);
  		my $path = $self->path;
  		$path =~ s{^/}{};
  		$path =~ s{%([0-9A-F]{2})}{chr hex($1)}ieg;
  		$self->path($path);
  		command_noisy('config', '--add',
  			      "svn-remote.$self->{repo_id}.fetch",
  			      $self->path.":".$self->refname);
  	}
  	$self->url($url);
  }
  
  sub find_by_url { # repos_root and, path are optional
  	my ($class, $full_url, $repos_root, $path) = @_;
  
  	$full_url = canonicalize_url($full_url);
  
  	return undef unless defined $full_url;
  	remove_username($full_url);
  	remove_username($repos_root) if defined $repos_root;
  	my $remotes = read_all_remotes();
  	if (defined $full_url && defined $repos_root && !defined $path) {
  		$path = $full_url;
  		$path =~ s#^\Q$repos_root\E(?:/|$)##;
  	}
  	foreach my $repo_id (keys %$remotes) {
  		my $u = $remotes->{$repo_id}->{url} or next;
  		remove_username($u);
  		next if defined $repos_root && $repos_root ne $u;
  
  		my $fetch = $remotes->{$repo_id}->{fetch} || {};
  		foreach my $t (qw/branches tags/) {
  			foreach my $globspec (@{$remotes->{$repo_id}->{$t}}) {
  				resolve_local_globs($u, $fetch, $globspec);
  			}
  		}
  		my $p = $path;
  		my $rwr = rewrite_root({repo_id => $repo_id});
  		my $svm = $remotes->{$repo_id}->{svm}
  			if defined $remotes->{$repo_id}->{svm};
  		unless (defined $p) {
  			$p = $full_url;
  			my $z = $u;
  			my $prefix = '';
  			if ($rwr) {
  				$z = $rwr;
  				remove_username($z);
  			} elsif (defined $svm) {
  				$z = $svm->{source};
  				$prefix = $svm->{replace};
  				$prefix =~ s#^\Q$u\E(?:/|$)##;
  				$prefix =~ s#/$##;
  			}
  			$p =~ s#^\Q$z\E(?:/|$)#$prefix# or next;
  		}
  
  		# remote fetch paths are not URI escaped.  Decode ours
  		# so they match
  		$p = uri_decode($p);
  
  		foreach my $f (keys %$fetch) {
  			next if $f ne $p;
  			return Git::SVN->new($fetch->{$f}, $repo_id, $f);
  		}
  	}
  	undef;
  }
  
  sub init {
  	my ($class, $url, $path, $repo_id, $ref_id, $no_write) = @_;
  	my $self = _new($class, $repo_id, $ref_id, $path);
  	if (defined $url) {
  		$self->init_remote_config($url, $no_write);
  	}
  	$self;
  }
  
  sub find_ref {
  	my ($ref_id) = @_;
  	foreach (command(qw/config -l/)) {
  		next unless m!^svn-remote\.(.+)\.fetch=
  		              \s*(.*?)\s*:\s*(.+?)\s*$!x;
  		my ($repo_id, $path, $ref) = ($1, $2, $3);
  		if ($ref eq $ref_id) {
  			$path = '' if ($path =~ m#^\./?#);
  			return ($repo_id, $path);
  		}
  	}
  	(undef, undef, undef);
  }
  
  sub new {
  	my ($class, $ref_id, $repo_id, $path) = @_;
  	if (defined $ref_id && !defined $repo_id && !defined $path) {
  		($repo_id, $path) = find_ref($ref_id);
  		if (!defined $repo_id) {
  			die "Could not find a \"svn-remote.*.fetch\" key ",
  			    "in the repository configuration matching: ",
  			    "$ref_id\n";
  		}
  	}
  	my $self = _new($class, $repo_id, $ref_id, $path);
  	if (!defined $self->path || !length $self->path) {
  		my $fetch = command_oneline('config', '--get',
  		                            "svn-remote.$repo_id.fetch",
  		                            ":$ref_id\$") or
  		     die "Failed to read \"svn-remote.$repo_id.fetch\" ",
  		         "\":$ref_id\$\" in config\n";
  		my($path) = split(/\s*:\s*/, $fetch);
  		$self->path($path);
  	}
  	{
  		my $path = $self->path;
  		$path =~ s{\A/}{};
  		$path =~ s{/\z}{};
  		$self->path($path);
  	}
  	my $url = command_oneline('config', '--get',
  	                          "svn-remote.$repo_id.url") or
                    die "Failed to read \"svn-remote.$repo_id.url\" in config\n";
  	$self->url($url);
  	$self->{pushurl} = eval { command_oneline('config', '--get',
  	                          "svn-remote.$repo_id.pushurl") };
  	$self->rebuild;
  	$self;
  }
  
  sub refname {
  	my ($refname) = $_[0]->{ref_id} ;
  
  	# It cannot end with a slash /, we'll throw up on this because
  	# SVN can't have directories with a slash in their name, either:
  	if ($refname =~ m{/$}) {
  		die "ref: '$refname' ends with a trailing slash; this is ",
  		    "not permitted by git or Subversion\n";
  	}
  
  	# It cannot have ASCII control character space, tilde ~, caret ^,
  	# colon :, question-mark ?, asterisk *, space, or open bracket [
  	# anywhere.
  	#
  	# Additionally, % must be escaped because it is used for escaping
  	# and we want our escaped refname to be reversible
  	$refname =~ s{([ \%~\^:\?\*\[\t\\])}{sprintf('%%%02X',ord($1))}eg;
  
  	# no slash-separated component can begin with a dot .
  	# /.* becomes /%2E*
  	$refname =~ s{/\.}{/%2E}g;
  
  	# It cannot have two consecutive dots .. anywhere
  	# .. becomes %2E%2E
  	$refname =~ s{\.\.}{%2E%2E}g;
  
  	# trailing dots and .lock are not allowed
  	# .$ becomes %2E and .lock becomes %2Elock
  	$refname =~ s{\.(?=$|lock$)}{%2E};
  
  	# the sequence @{ is used to access the reflog
  	# @{ becomes %40{
  	$refname =~ s{\@\{}{%40\{}g;
  
  	return $refname;
  }
  
  sub desanitize_refname {
  	my ($refname) = @_;
  	$refname =~ s{%(?:([0-9A-F]{2}))}{chr hex($1)}eg;
  	return $refname;
  }
  
  sub svm_uuid {
  	my ($self) = @_;
  	return $self->{svm}->{uuid} if $self->svm;
  	$self->ra;
  	unless ($self->{svm}) {
  		die "SVM UUID not cached, and reading remotely failed\n";
  	}
  	$self->{svm}->{uuid};
  }
  
  sub svm {
  	my ($self) = @_;
  	return $self->{svm} if $self->{svm};
  	my $svm;
  	# see if we have it in our config, first:
  	eval {
  		my $section = "svn-remote.$self->{repo_id}";
  		$svm = {
  		  source => tmp_config('--get', "$section.svm-source"),
  		  uuid => tmp_config('--get', "$section.svm-uuid"),
  		  replace => tmp_config('--get', "$section.svm-replace"),
  		}
  	};
  	if ($svm && $svm->{source} && $svm->{uuid} && $svm->{replace}) {
  		$self->{svm} = $svm;
  	}
  	$self->{svm};
  }
  
  sub _set_svm_vars {
  	my ($self, $ra) = @_;
  	return $ra if $self->svm;
  
  	my @err = ( "useSvmProps set, but failed to read SVM properties\n",
  		    "(svm:source, svm:uuid) ",
  		    "from the following URLs:\n" );
  	sub read_svm_props {
  		my ($self, $ra, $path, $r) = @_;
  		my $props = ($ra->get_dir($path, $r))[2];
  		my $src = $props->{'svm:source'};
  		my $uuid = $props->{'svm:uuid'};
  		return undef if (!$src || !$uuid);
  
  		chomp($src, $uuid);
  
  		$uuid =~ m{^[0-9a-f\-]{30,}$}i
  		    or die "doesn't look right - svm:uuid is '$uuid'\n";
  
  		# the '!' is used to mark the repos_root!/relative/path
  		$src =~ s{/?!/?}{/};
  		$src =~ s{/+$}{}; # no trailing slashes please
  		# username is of no interest
  		$src =~ s{(^[a-z\+]*://)[^/@]*@}{$1};
  
  		my $replace = add_path_to_url($ra->url, $path);
  
  		my $section = "svn-remote.$self->{repo_id}";
  		tmp_config("$section.svm-source", $src);
  		tmp_config("$section.svm-replace", $replace);
  		tmp_config("$section.svm-uuid", $uuid);
  		$self->{svm} = {
  			source => $src,
  			uuid => $uuid,
  			replace => $replace
  		};
  	}
  
  	my $r = $ra->get_latest_revnum;
  	my $path = $self->path;
  	my %tried;
  	while (length $path) {
  		my $try = add_path_to_url($self->url, $path);
  		unless ($tried{$try}) {
  			return $ra if $self->read_svm_props($ra, $path, $r);
  			$tried{$try} = 1;
  		}
  		$path =~ s#/?[^/]+$##;
  	}
  	die "Path: '$path' should be ''\n" if $path ne '';
  	return $ra if $self->read_svm_props($ra, $path, $r);
  	$tried{ add_path_to_url($self->url, $path) } = 1;
  
  	if ($ra->{repos_root} eq $self->url) {
  		die @err, (map { "  $_\n" } keys %tried), "\n";
  	}
  
  	# nope, make sure we're connected to the repository root:
  	my $ok;
  	my @tried_b;
  	$path = $ra->{svn_path};
  	$ra = Git::SVN::Ra->new($ra->{repos_root});
  	while (length $path) {
  		my $try = add_path_to_url($ra->url, $path);
  		unless ($tried{$try}) {
  			$ok = $self->read_svm_props($ra, $path, $r);
  			last if $ok;
  			$tried{$try} = 1;
  		}
  		$path =~ s#/?[^/]+$##;
  	}
  	die "Path: '$path' should be ''\n" if $path ne '';
  	$ok ||= $self->read_svm_props($ra, $path, $r);
  	$tried{ add_path_to_url($ra->url, $path) } = 1;
  	if (!$ok) {
  		die @err, (map { "  $_\n" } keys %tried), "\n";
  	}
  	Git::SVN::Ra->new($self->url);
  }
  
  sub svnsync {
  	my ($self) = @_;
  	return $self->{svnsync} if $self->{svnsync};
  
  	if ($self->no_metadata) {
  		die "Can't have both 'noMetadata' and ",
  		    "'useSvnsyncProps' options set!\n";
  	}
  	if ($self->rewrite_root) {
  		die "Can't have both 'useSvnsyncProps' and 'rewriteRoot' ",
  		    "options set!\n";
  	}
  	if ($self->rewrite_uuid) {
  		die "Can't have both 'useSvnsyncProps' and 'rewriteUUID' ",
  		    "options set!\n";
  	}
  
  	my $svnsync;
  	# see if we have it in our config, first:
  	eval {
  		my $section = "svn-remote.$self->{repo_id}";
  
  		my $url = tmp_config('--get', "$section.svnsync-url");
  		($url) = ($url =~ m{^([a-z\+]+://\S+)$}) or
  		   die "doesn't look right - svn:sync-from-url is '$url'\n";
  
  		my $uuid = tmp_config('--get', "$section.svnsync-uuid");
  		($uuid) = ($uuid =~ m{^([0-9a-f\-]{30,})$}i) or
  		   die "doesn't look right - svn:sync-from-uuid is '$uuid'\n";
  
  		$svnsync = { url => $url, uuid => $uuid }
  	};
  	if ($svnsync && $svnsync->{url} && $svnsync->{uuid}) {
  		return $self->{svnsync} = $svnsync;
  	}
  
  	my $err = "useSvnsyncProps set, but failed to read " .
  	          "svnsync property: svn:sync-from-";
  	my $rp = $self->ra->rev_proplist(0);
  
  	my $url = $rp->{'svn:sync-from-url'} or die $err . "url\n";
  	($url) = ($url =~ m{^([a-z\+]+://\S+)$}) or
  	           die "doesn't look right - svn:sync-from-url is '$url'\n";
  
  	my $uuid = $rp->{'svn:sync-from-uuid'} or die $err . "uuid\n";
  	($uuid) = ($uuid =~ m{^([0-9a-f\-]{30,})$}i) or
  	           die "doesn't look right - svn:sync-from-uuid is '$uuid'\n";
  
  	my $section = "svn-remote.$self->{repo_id}";
  	tmp_config('--add', "$section.svnsync-uuid", $uuid);
  	tmp_config('--add', "$section.svnsync-url", $url);
  	return $self->{svnsync} = { url => $url, uuid => $uuid };
  }
  
  # this allows us to memoize our SVN::Ra UUID locally and avoid a
  # remote lookup (useful for 'git svn log').
  sub ra_uuid {
  	my ($self) = @_;
  	unless ($self->{ra_uuid}) {
  		my $key = "svn-remote.$self->{repo_id}.uuid";
  		my $uuid = eval { tmp_config('--get', $key) };
  		if (!$@ && $uuid && $uuid =~ /^([a-f\d\-]{30,})$/i) {
  			$self->{ra_uuid} = $uuid;
  		} else {
  			die "ra_uuid called without URL\n" unless $self->url;
  			$self->{ra_uuid} = $self->ra->get_uuid;
  			tmp_config('--add', $key, $self->{ra_uuid});
  		}
  	}
  	$self->{ra_uuid};
  }
  
  sub _set_repos_root {
  	my ($self, $repos_root) = @_;
  	my $k = "svn-remote.$self->{repo_id}.reposRoot";
  	$repos_root ||= $self->ra->{repos_root};
  	tmp_config($k, $repos_root);
  	$repos_root;
  }
  
  sub repos_root {
  	my ($self) = @_;
  	my $k = "svn-remote.$self->{repo_id}.reposRoot";
  	eval { tmp_config('--get', $k) } || $self->_set_repos_root;
  }
  
  sub ra {
  	my ($self) = shift;
  	my $ra = Git::SVN::Ra->new($self->url);
  	$self->_set_repos_root($ra->{repos_root});
  	if ($self->use_svm_props && !$self->{svm}) {
  		if ($self->no_metadata) {
  			die "Can't have both 'noMetadata' and ",
  			    "'useSvmProps' options set!\n";
  		} elsif ($self->use_svnsync_props) {
  			die "Can't have both 'useSvnsyncProps' and ",
  			    "'useSvmProps' options set!\n";
  		}
  		$ra = $self->_set_svm_vars($ra);
  		$self->{-want_revprops} = 1;
  	}
  	$ra;
  }
  
  # prop_walk(PATH, REV, SUB)
  # -------------------------
  # Recursively traverse PATH at revision REV and invoke SUB for each
  # directory that contains a SVN property.  SUB will be invoked as
  # follows:  &SUB(gs, path, props);  where `gs' is this instance of
  # Git::SVN, `path' the path to the directory where the properties
  # `props' were found.  The `path' will be relative to point of checkout,
  # that is, if url://repo/trunk is the current Git branch, and that
  # directory contains a sub-directory `d', SUB will be invoked with `/d/'
  # as `path' (note the trailing `/').
  sub prop_walk {
  	my ($self, $path, $rev, $sub) = @_;
  
  	$path =~ s#^/##;
  	my ($dirent, undef, $props) = $self->ra->get_dir($path, $rev);
  	$path =~ s#^/*#/#g;
  	my $p = $path;
  	# Strip the irrelevant part of the path.
  	$p =~ s#^/+\Q@{[$self->path]}\E(/|$)#/#;
  	# Ensure the path is terminated by a `/'.
  	$p =~ s#/*$#/#;
  
  	# The properties contain all the internal SVN stuff nobody
  	# (usually) cares about.
  	my $interesting_props = 0;
  	foreach (keys %{$props}) {
  		# If it doesn't start with `svn:', it must be a
  		# user-defined property.
  		++$interesting_props and next if $_ !~ /^svn:/;
  		# FIXME: Fragile, if SVN adds new public properties,
  		# this needs to be updated.
  		++$interesting_props if /^svn:(?:ignore|keywords|executable
  		                                 |eol-style|mime-type
  						 |externals|needs-lock)$/x;
  	}
  	&$sub($self, $p, $props) if $interesting_props;
  
  	foreach (sort keys %$dirent) {
  		next if $dirent->{$_}->{kind} != $SVN::Node::dir;
  		$self->prop_walk($self->path . $p . $_, $rev, $sub);
  	}
  }
  
  sub last_rev { ($_[0]->last_rev_commit)[0] }
  sub last_commit { ($_[0]->last_rev_commit)[1] }
  
  # returns the newest SVN revision number and newest commit SHA1
  sub last_rev_commit {
  	my ($self) = @_;
  	if (defined $self->{last_rev} && defined $self->{last_commit}) {
  		return ($self->{last_rev}, $self->{last_commit});
  	}
  	my $c = ::verify_ref($self->refname.'^0');
  	if ($c && !$self->use_svm_props && !$self->no_metadata) {
  		my $rev = (::cmt_metadata($c))[1];
  		if (defined $rev) {
  			($self->{last_rev}, $self->{last_commit}) = ($rev, $c);
  			return ($rev, $c);
  		}
  	}
  	my $map_path = $self->map_path;
  	unless (-e $map_path) {
  		($self->{last_rev}, $self->{last_commit}) = (undef, undef);
  		return (undef, undef);
  	}
  	my ($rev, $commit) = $self->rev_map_max(1);
  	($self->{last_rev}, $self->{last_commit}) = ($rev, $commit);
  	return ($rev, $commit);
  }
  
  sub get_fetch_range {
  	my ($self, $min, $max) = @_;
  	$max ||= $self->ra->get_latest_revnum;
  	$min ||= $self->rev_map_max;
  	(++$min, $max);
  }
  
  sub svn_dir {
  	command_oneline(qw(rev-parse --git-path svn));
  }
  
  sub tmp_config {
  	my (@args) = @_;
  	my $svn_dir = svn_dir();
  	my $old_def_config = "$svn_dir/config";
  	my $config = "$svn_dir/.metadata";
  	if (! -f $config && -f $old_def_config) {
  		rename $old_def_config, $config or
  		       die "Failed rename $old_def_config => $config: $!\n";
  	}
  	my $old_config = $ENV{GIT_CONFIG};
  	$ENV{GIT_CONFIG} = $config;
  	$@ = undef;
  	my @ret = eval {
  		unless (-f $config) {
  			mkfile($config);
  			open my $fh, '>', $config or
  			    die "Can't open $config: $!\n";
  			print $fh "; This file is used internally by ",
  			          "git-svn\n" or die
  				  "Couldn't write to $config: $!\n";
  			print $fh "; You should not have to edit it\n" or
  			      die "Couldn't write to $config: $!\n";
  			close $fh or die "Couldn't close $config: $!\n";
  		}
  		command('config', @args);
  	};
  	my $err = $@;
  	if (defined $old_config) {
  		$ENV{GIT_CONFIG} = $old_config;
  	} else {
  		delete $ENV{GIT_CONFIG};
  	}
  	die $err if $err;
  	wantarray ? @ret : $ret[0];
  }
  
  sub tmp_index_do {
  	my ($self, $sub) = @_;
  	my $old_index = $ENV{GIT_INDEX_FILE};
  	$ENV{GIT_INDEX_FILE} = $self->{index};
  	$@ = undef;
  	my @ret = eval {
  		my ($dir, $base) = ($self->{index} =~ m#^(.*?)/?([^/]+)$#);
  		mkpath([$dir]) unless -d $dir;
  		&$sub;
  	};
  	my $err = $@;
  	if (defined $old_index) {
  		$ENV{GIT_INDEX_FILE} = $old_index;
  	} else {
  		delete $ENV{GIT_INDEX_FILE};
  	}
  	die $err if $err;
  	wantarray ? @ret : $ret[0];
  }
  
  sub assert_index_clean {
  	my ($self, $treeish) = @_;
  
  	$self->tmp_index_do(sub {
  		command_noisy('read-tree', $treeish) unless -e $self->{index};
  		my $x = command_oneline('write-tree');
  		my ($y) = (command(qw/cat-file commit/, $treeish) =~
  		           /^tree ($::sha1)/mo);
  		return if $y eq $x;
  
  		warn "Index mismatch: $y != $x\nrereading $treeish\n";
  		unlink $self->{index} or die "unlink $self->{index}: $!\n";
  		command_noisy('read-tree', $treeish);
  		$x = command_oneline('write-tree');
  		if ($y ne $x) {
  			fatal "trees ($treeish) $y != $x\n",
  			      "Something is seriously wrong...";
  		}
  	});
  }
  
  sub get_commit_parents {
  	my ($self, $log_entry) = @_;
  	my (%seen, @ret, @tmp);
  	# legacy support for 'set-tree'; this is only used by set_tree_cb:
  	if (my $ip = $self->{inject_parents}) {
  		if (my $commit = delete $ip->{$log_entry->{revision}}) {
  			push @tmp, $commit;
  		}
  	}
  	if (my $cur = ::verify_ref($self->refname.'^0')) {
  		push @tmp, $cur;
  	}
  	if (my $ipd = $self->{inject_parents_dcommit}) {
  		if (my $commit = delete $ipd->{$log_entry->{revision}}) {
  			push @tmp, @$commit;
  		}
  	}
  	push @tmp, $_ foreach (@{$log_entry->{parents}}, @tmp);
  	while (my $p = shift @tmp) {
  		next if $seen{$p};
  		$seen{$p} = 1;
  		push @ret, $p;
  	}
  	@ret;
  }
  
  sub rewrite_root {
  	my ($self) = @_;
  	return $self->{-rewrite_root} if exists $self->{-rewrite_root};
  	my $k = "svn-remote.$self->{repo_id}.rewriteRoot";
  	my $rwr = eval { command_oneline(qw/config --get/, $k) };
  	if ($rwr) {
  		$rwr =~ s#/+$##;
  		if ($rwr !~ m#^[a-z\+]+://#) {
  			die "$rwr is not a valid URL (key: $k)\n";
  		}
  	}
  	$self->{-rewrite_root} = $rwr;
  }
  
  sub rewrite_uuid {
  	my ($self) = @_;
  	return $self->{-rewrite_uuid} if exists $self->{-rewrite_uuid};
  	my $k = "svn-remote.$self->{repo_id}.rewriteUUID";
  	my $rwid = eval { command_oneline(qw/config --get/, $k) };
  	if ($rwid) {
  		$rwid =~ s#/+$##;
  		if ($rwid !~ m#^[a-f0-9]{8}-(?:[a-f0-9]{4}-){3}[a-f0-9]{12}$#) {
  			die "$rwid is not a valid UUID (key: $k)\n";
  		}
  	}
  	$self->{-rewrite_uuid} = $rwid;
  }
  
  sub metadata_url {
  	my ($self) = @_;
  	my $url = $self->rewrite_root || $self->url;
  	return canonicalize_url( add_path_to_url( $url, $self->path ) );
  }
  
  sub full_url {
  	my ($self) = @_;
  	return canonicalize_url( add_path_to_url( $self->url, $self->path ) );
  }
  
  sub full_pushurl {
  	my ($self) = @_;
  	if ($self->{pushurl}) {
  		return canonicalize_url( add_path_to_url( $self->{pushurl}, $self->path ) );
  	} else {
  		return $self->full_url;
  	}
  }
  
  sub set_commit_header_env {
  	my ($log_entry) = @_;
  	my %env;
  	foreach my $ned (qw/NAME EMAIL DATE/) {
  		foreach my $ac (qw/AUTHOR COMMITTER/) {
  			$env{"GIT_${ac}_${ned}"} = $ENV{"GIT_${ac}_${ned}"};
  		}
  	}
  
  	$ENV{GIT_AUTHOR_NAME} = $log_entry->{name};
  	$ENV{GIT_AUTHOR_EMAIL} = $log_entry->{email};
  	$ENV{GIT_AUTHOR_DATE} = $ENV{GIT_COMMITTER_DATE} = $log_entry->{date};
  
  	$ENV{GIT_COMMITTER_NAME} = (defined $log_entry->{commit_name})
  						? $log_entry->{commit_name}
  						: $log_entry->{name};
  	$ENV{GIT_COMMITTER_EMAIL} = (defined $log_entry->{commit_email})
  						? $log_entry->{commit_email}
  						: $log_entry->{email};
  	\%env;
  }
  
  sub restore_commit_header_env {
  	my ($env) = @_;
  	foreach my $ned (qw/NAME EMAIL DATE/) {
  		foreach my $ac (qw/AUTHOR COMMITTER/) {
  			my $k = "GIT_${ac}_${ned}";
  			if (defined $env->{$k}) {
  				$ENV{$k} = $env->{$k};
  			} else {
  				delete $ENV{$k};
  			}
  		}
  	}
  }
  
  sub gc {
  	command_noisy('gc', '--auto');
  };
  
  sub do_git_commit {
  	my ($self, $log_entry) = @_;
  	my $lr = $self->last_rev;
  	if (defined $lr && $lr >= $log_entry->{revision}) {
  		die "Last fetched revision of ", $self->refname,
  		    " was r$lr, but we are about to fetch: ",
  		    "r$log_entry->{revision}!\n";
  	}
  	if (my $c = $self->rev_map_get($log_entry->{revision})) {
  		croak "$log_entry->{revision} = $c already exists! ",
  		      "Why are we refetching it?\n";
  	}
  	my $old_env = set_commit_header_env($log_entry);
  	my $tree = $log_entry->{tree};
  	if (!defined $tree) {
  		$tree = $self->tmp_index_do(sub {
  		                            command_oneline('write-tree') });
  	}
  	die "Tree is not a valid sha1: $tree\n" if $tree !~ /^$::sha1$/o;
  
  	my @exec = ('git', 'commit-tree', $tree);
  	foreach ($self->get_commit_parents($log_entry)) {
  		push @exec, '-p', $_;
  	}
  	defined(my $pid = open3(my $msg_fh, my $out_fh, '>&STDERR', @exec))
  	                                                           or croak $!;
  	binmode $msg_fh;
  
  	# we always get UTF-8 from SVN, but we may want our commits in
  	# a different encoding.
  	if (my $enc = Git::config('i18n.commitencoding')) {
  		require Encode;
  		Encode::from_to($log_entry->{log}, 'UTF-8', $enc);
  	}
  	print $msg_fh $log_entry->{log} or croak $!;
  	restore_commit_header_env($old_env);
  	unless ($self->no_metadata) {
  		print $msg_fh "\ngit-svn-id: $log_entry->{metadata}\n"
  		              or croak $!;
  	}
  	$msg_fh->flush == 0 or croak $!;
  	close $msg_fh or croak $!;
  	chomp(my $commit = do { local $/; <$out_fh> });
  	close $out_fh or croak $!;
  	waitpid $pid, 0;
  	croak $? if $?;
  	if ($commit !~ /^$::sha1$/o) {
  		die "Failed to commit, invalid sha1: $commit\n";
  	}
  
  	$self->rev_map_set($log_entry->{revision}, $commit, 1);
  
  	$self->{last_rev} = $log_entry->{revision};
  	$self->{last_commit} = $commit;
  	print "r$log_entry->{revision}" unless $::_q > 1;
  	if (defined $log_entry->{svm_revision}) {
  		 print " (\@$log_entry->{svm_revision})" unless $::_q > 1;
  		 $self->rev_map_set($log_entry->{svm_revision}, $commit,
  		                   0, $self->svm_uuid);
  	}
  	print " = $commit ($self->{ref_id})\n" unless $::_q > 1;
  	if (--$_gc_nr == 0) {
  		$_gc_nr = $_gc_period;
  		gc();
  	}
  	return $commit;
  }
  
  sub match_paths {
  	my ($self, $paths, $r) = @_;
  	return 1 if $self->path eq '';
  	if (my $path = $paths->{"/".$self->path}) {
  		return ($path->{action} eq 'D') ? 0 : 1;
  	}
  	$self->{path_regex} ||= qr{^/\Q@{[$self->path]}\E/};
  	if (grep /$self->{path_regex}/, keys %$paths) {
  		return 1;
  	}
  	my $c = '';
  	foreach (split m#/#, $self->path) {
  		$c .= "/$_";
  		next unless ($paths->{$c} &&
  		             ($paths->{$c}->{action} =~ /^[AR]$/));
  		if ($self->ra->check_path($self->path, $r) ==
  		    $SVN::Node::dir) {
  			return 1;
  		}
  	}
  	return 0;
  }
  
  sub find_parent_branch {
  	my ($self, $paths, $rev) = @_;
  	return undef unless $self->follow_parent;
  	unless (defined $paths) {
  		my $err_handler = $SVN::Error::handler;
  		$SVN::Error::handler = \&Git::SVN::Ra::skip_unknown_revs;
  		$self->ra->get_log([$self->path], $rev, $rev, 0, 1, 1,
  				   sub { $paths = $_[0] });
  		$SVN::Error::handler = $err_handler;
  	}
  	return undef unless defined $paths;
  
  	# look for a parent from another branch:
  	my @b_path_components = split m#/#, $self->path;
  	my @a_path_components;
  	my $i;
  	while (@b_path_components) {
  		$i = $paths->{'/'.join('/', @b_path_components)};
  		last if $i && defined $i->{copyfrom_path};
  		unshift(@a_path_components, pop(@b_path_components));
  	}
  	return undef unless defined $i && defined $i->{copyfrom_path};
  	my $branch_from = $i->{copyfrom_path};
  	if (@a_path_components) {
  		print STDERR "branch_from: $branch_from => ";
  		$branch_from .= '/'.join('/', @a_path_components);
  		print STDERR $branch_from, "\n";
  	}
  	my $r = $i->{copyfrom_rev};
  	my $repos_root = $self->ra->{repos_root};
  	my $url = $self->ra->url;
  	my $new_url = canonicalize_url( add_path_to_url( $url, $branch_from ) );
  	print STDERR  "Found possible branch point: ",
  	              "$new_url => ", $self->full_url, ", $r\n"
  	              unless $::_q > 1;
  	$branch_from =~ s#^/##;
  	my $gs = $self->other_gs($new_url, $url,
  		                 $branch_from, $r, $self->{ref_id});
  	my ($r0, $parent) = $gs->find_rev_before($r, 1);
  	{
  		my ($base, $head);
  		if (!defined $r0 || !defined $parent) {
  			($base, $head) = parse_revision_argument(0, $r);
  		} else {
  			if ($r0 < $r) {
  				$gs->ra->get_log([$gs->path], $r0 + 1, $r, 1,
  					0, 1, sub { $base = $_[1] - 1 });
  			}
  		}
  		if (defined $base && $base <= $r) {
  			$gs->fetch($base, $r);
  		}
  		($r0, $parent) = $gs->find_rev_before($r, 1);
  	}
  	if (defined $r0 && defined $parent) {
  		print STDERR "Found branch parent: ($self->{ref_id}) $parent\n"
  		             unless $::_q > 1;
  		my $ed;
  		if ($self->ra->can_do_switch) {
  			$self->assert_index_clean($parent);
  			print STDERR "Following parent with do_switch\n"
  			             unless $::_q > 1;
  			# do_switch works with svn/trunk >= r22312, but that
  			# is not included with SVN 1.4.3 (the latest version
  			# at the moment), so we can't rely on it
  			$self->{last_rev} = $r0;
  			$self->{last_commit} = $parent;
  			$ed = Git::SVN::Fetcher->new($self, $gs->path);
  			$gs->ra->gs_do_switch($r0, $rev, $gs,
  					      $self->full_url, $ed)
  			  or die "SVN connection failed somewhere...\n";
  		} elsif ($self->ra->trees_match($new_url, $r0,
  			                        $self->full_url, $rev)) {
  			print STDERR "Trees match:\n",
  			             "  $new_url\@$r0\n",
  			             "  ${\$self->full_url}\@$rev\n",
  			             "Following parent with no changes\n"
  			             unless $::_q > 1;
  			$self->tmp_index_do(sub {
  			    command_noisy('read-tree', $parent);
  			});
  			$self->{last_commit} = $parent;
  		} else {
  			print STDERR "Following parent with do_update\n"
  			             unless $::_q > 1;
  			$ed = Git::SVN::Fetcher->new($self);
  			$self->ra->gs_do_update($rev, $rev, $self, $ed)
  			  or die "SVN connection failed somewhere...\n";
  		}
  		print STDERR "Successfully followed parent\n" unless $::_q > 1;
  		return $self->make_log_entry($rev, [$parent], $ed, $r0, $branch_from);
  	}
  	return undef;
  }
  
  sub do_fetch {
  	my ($self, $paths, $rev) = @_;
  	my $ed;
  	my ($last_rev, @parents);
  	if (my $lc = $self->last_commit) {
  		# we can have a branch that was deleted, then re-added
  		# under the same name but copied from another path, in
  		# which case we'll have multiple parents (we don't
  		# want to break the original ref or lose copypath info):
  		if (my $log_entry = $self->find_parent_branch($paths, $rev)) {
  			push @{$log_entry->{parents}}, $lc;
  			return $log_entry;
  		}
  		$ed = Git::SVN::Fetcher->new($self);
  		$last_rev = $self->{last_rev};
  		$ed->{c} = $lc;
  		@parents = ($lc);
  	} else {
  		$last_rev = $rev;
  		if (my $log_entry = $self->find_parent_branch($paths, $rev)) {
  			return $log_entry;
  		}
  		$ed = Git::SVN::Fetcher->new($self);
  	}
  	unless ($self->ra->gs_do_update($last_rev, $rev, $self, $ed)) {
  		die "SVN connection failed somewhere...\n";
  	}
  	$self->make_log_entry($rev, \@parents, $ed, $last_rev, $self->path);
  }
  
  sub mkemptydirs {
  	my ($self, $r) = @_;
  
  	# add/remove/collect a paths table
  	#
  	# Paths are split into a tree of nodes, stored as a hash of hashes.
  	#
  	# Each node contains a 'path' entry for the path (if any) associated
  	# with that node and a 'children' entry for any nodes under that
  	# location.
  	#
  	# Removing a path requires a hash lookup for each component then
  	# dropping that node (and anything under it), which is substantially
  	# faster than a grep slice into a single hash of paths for large
  	# numbers of paths.
  	#
  	# For a large (200K) number of empty_dir directives this reduces
  	# scanning time to 3 seconds vs 10 minutes for grep+delete on a single
  	# hash of paths.
  	sub add_path {
  		my ($paths_table, $path) = @_;
  		my $node_ref;
  
  		foreach my $x (split('/', $path)) {
  			if (!exists($paths_table->{$x})) {
  				$paths_table->{$x} = { children => {} };
  			}
  
  			$node_ref = $paths_table->{$x};
  			$paths_table = $paths_table->{$x}->{children};
  		}
  
  		$node_ref->{path} = $path;
  	}
  
  	sub remove_path {
  		my ($paths_table, $path) = @_;
  		my $nodes_ref;
  		my $node_name;
  
  		foreach my $x (split('/', $path)) {
  			if (!exists($paths_table->{$x})) {
  				return;
  			}
  
  			$nodes_ref = $paths_table;
  			$node_name = $x;
  
  			$paths_table = $paths_table->{$x}->{children};
  		}
  
  		delete($nodes_ref->{$node_name});
  	}
  
  	sub collect_paths {
  		my ($paths_table, $paths_ref) = @_;
  
  		foreach my $v (values %$paths_table) {
  			my $p = $v->{path};
  			my $c = $v->{children};
  
  			collect_paths($c, $paths_ref);
  
  			if (defined($p)) {
  				push(@$paths_ref, $p);
  			}
  		}
  	}
  
  	sub scan {
  		my ($r, $paths_table, $line) = @_;
  		if (defined $r && $line =~ /^r(\d+)$/) {
  			return 0 if $1 > $r;
  		} elsif ($line =~ /^  \+empty_dir: (.+)$/) {
  			add_path($paths_table, $1);
  		} elsif ($line =~ /^  \-empty_dir: (.+)$/) {
  			remove_path($paths_table, $1);
  		}
  		1; # continue
  	};
  
  	my @empty_dirs;
  	my %paths_table;
  
  	my $gz_file = "$self->{dir}/unhandled.log.gz";
  	if (-f $gz_file) {
  		if (!can_compress()) {
  			warn "Compress::Zlib could not be found; ",
  			     "empty directories in $gz_file will not be read\n";
  		} else {
  			my $gz = Compress::Zlib::gzopen($gz_file, "rb") or
  				die "Unable to open $gz_file: $!\n";
  			my $line;
  			while ($gz->gzreadline($line) > 0) {
  				scan($r, \%paths_table, $line) or last;
  			}
  			$gz->gzclose;
  		}
  	}
  
  	if (open my $fh, '<', "$self->{dir}/unhandled.log") {
  		binmode $fh or croak "binmode: $!";
  		while (<$fh>) {
  			scan($r, \%paths_table, $_) or last;
  		}
  		close $fh;
  	}
  
  	collect_paths(\%paths_table, \@empty_dirs);
  	my $strip = qr/\A\Q@{[$self->path]}\E(?:\/|$)/;
  	foreach my $d (sort @empty_dirs) {
  		$d = uri_decode($d);
  		$d =~ s/$strip//;
  		next unless length($d);
  		next if -d $d;
  		if (-e $d) {
  			warn "$d exists but is not a directory\n";
  		} else {
  			print "creating empty directory: $d\n";
  			mkpath([$d]);
  		}
  	}
  }
  
  sub get_untracked {
  	my ($self, $ed) = @_;
  	my @out;
  	my $h = $ed->{empty};
  	foreach (sort keys %$h) {
  		my $act = $h->{$_} ? '+empty_dir' : '-empty_dir';
  		push @out, "  $act: " . uri_encode($_);
  		warn "W: $act: $_\n";
  	}
  	foreach my $t (qw/dir_prop file_prop/) {
  		$h = $ed->{$t} or next;
  		foreach my $path (sort keys %$h) {
  			my $ppath = $path eq '' ? '.' : $path;
  			foreach my $prop (sort keys %{$h->{$path}}) {
  				next if $SKIP_PROP{$prop};
  				my $v = $h->{$path}->{$prop};
  				my $t_ppath_prop = "$t: " .
  				                    uri_encode($ppath) . ' ' .
  				                    uri_encode($prop);
  				if (defined $v) {
  					push @out, "  +$t_ppath_prop " .
  					           uri_encode($v);
  				} else {
  					push @out, "  -$t_ppath_prop";
  				}
  			}
  		}
  	}
  	foreach my $t (qw/absent_file absent_directory/) {
  		$h = $ed->{$t} or next;
  		foreach my $parent (sort keys %$h) {
  			foreach my $path (sort @{$h->{$parent}}) {
  				push @out, "  $t: " .
  				           uri_encode("$parent/$path");
  				warn "W: $t: $parent/$path ",
  				     "Insufficient permissions?\n";
  			}
  		}
  	}
  	\@out;
  }
  
  # parse_svn_date(DATE)
  # --------------------
  # Given a date (in UTC) from Subversion, return a string in the format
  # "<TZ Offset> <local date/time>" that Git will use.
  #
  # By default the parsed date will be in UTC; if $Git::SVN::_localtime
  # is true we'll convert it to the local timezone instead.
  sub parse_svn_date {
  	my $date = shift || return '+0000 1970-01-01 00:00:00';
  	my ($Y,$m,$d,$H,$M,$S) = ($date =~ /^(\d{4})\-(\d\d)\-(\d\d)T
  	                                    (\d\d?)\:(\d\d)\:(\d\d)\.\d*Z$/x) or
  	                                 croak "Unable to parse date: $date\n";
  	my $parsed_date;    # Set next.
  
  	if ($Git::SVN::_localtime) {
  		# Translate the Subversion datetime to an epoch time.
  		# Begin by switching ourselves to $date's timezone, UTC.
  		my $old_env_TZ = $ENV{TZ};
  		$ENV{TZ} = 'UTC';
  
  		my $epoch_in_UTC =
  		    Time::Local::timelocal($S, $M, $H, $d, $m - 1, $Y - 1900);
  
  		# Determine our local timezone (including DST) at the
  		# time of $epoch_in_UTC.  $Git::SVN::Log::TZ stored the
  		# value of TZ, if any, at the time we were run.
  		if (defined $Git::SVN::Log::TZ) {
  			$ENV{TZ} = $Git::SVN::Log::TZ;
  		} else {
  			delete $ENV{TZ};
  		}
  
  		my $our_TZ = get_tz_offset($epoch_in_UTC);
  
  		# This converts $epoch_in_UTC into our local timezone.
  		my ($sec, $min, $hour, $mday, $mon, $year,
  		    $wday, $yday, $isdst) = localtime($epoch_in_UTC);
  
  		$parsed_date = sprintf('%s %04d-%02d-%02d %02d:%02d:%02d',
  				       $our_TZ, $year + 1900, $mon + 1,
  				       $mday, $hour, $min, $sec);
  
  		# Reset us to the timezone in effect when we entered
  		# this routine.
  		if (defined $old_env_TZ) {
  			$ENV{TZ} = $old_env_TZ;
  		} else {
  			delete $ENV{TZ};
  		}
  	} else {
  		$parsed_date = "+0000 $Y-$m-$d $H:$M:$S";
  	}
  
  	return $parsed_date;
  }
  
  sub other_gs {
  	my ($self, $new_url, $url,
  	    $branch_from, $r, $old_ref_id) = @_;
  	my $gs = Git::SVN->find_by_url($new_url, $url, $branch_from);
  	unless ($gs) {
  		my $ref_id = $old_ref_id;
  		$ref_id =~ s/\@\d+-*$//;
  		$ref_id .= "\@$r";
  		# just grow a tail if we're not unique enough :x
  		$ref_id .= '-' while find_ref($ref_id);
  		my ($u, $p, $repo_id) = ($new_url, '', $ref_id);
  		if ($u =~ s#^\Q$url\E(/|$)##) {
  			$p = $u;
  			$u = $url;
  			$repo_id = $self->{repo_id};
  		}
  		while (1) {
  			# It is possible to tag two different subdirectories at
  			# the same revision.  If the url for an existing ref
  			# does not match, we must either find a ref with a
  			# matching url or create a new ref by growing a tail.
  			$gs = Git::SVN->init($u, $p, $repo_id, $ref_id, 1);
  			my (undef, $max_commit) = $gs->rev_map_max(1);
  			last if (!$max_commit);
  			my ($url) = ::cmt_metadata($max_commit);
  			last if ($url eq $gs->metadata_url);
  			$ref_id .= '-';
  		}
  		print STDERR "Initializing parent: $ref_id\n" unless $::_q > 1;
  	}
  	$gs
  }
  
  sub call_authors_prog {
  	my ($orig_author) = @_;
  	$orig_author = command_oneline('rev-parse', '--sq-quote', $orig_author);
  	my $author = `$::_authors_prog $orig_author`;
  	if ($? != 0) {
  		die "$::_authors_prog failed with exit code $?\n"
  	}
  	if ($author =~ /^\s*(.+?)\s*<(.*)>\s*$/) {
  		my ($name, $email) = ($1, $2);
  		$email = undef if length $2 == 0;
  		return [$name, $email];
  	} else {
  		die "Author: $orig_author: $::_authors_prog returned "
  			. "invalid author format: $author\n";
  	}
  }
  
  sub check_author {
  	my ($author) = @_;
  	if (!defined $author || length $author == 0) {
  		$author = '(no author)';
  	}
  	if (!defined $::users{$author}) {
  		if (defined $::_authors_prog) {
  			$::users{$author} = call_authors_prog($author);
  		} elsif (defined $::_authors) {
  			die "Author: $author not defined in $::_authors file\n";
  		}
  	}
  	$author;
  }
  
  sub find_extra_svk_parents {
  	my ($self, $tickets, $parents) = @_;
  	# aha!  svk:merge property changed...
  	my @tickets = split "\n", $tickets;
  	my @known_parents;
  	for my $ticket ( @tickets ) {
  		my ($uuid, $path, $rev) = split /:/, $ticket;
  		if ( $uuid eq $self->ra_uuid ) {
  			my $repos_root = $self->url;
  			my $branch_from = $path;
  			$branch_from =~ s{^/}{};
  			my $gs = $self->other_gs(add_path_to_url( $repos_root, $branch_from ),
  			                         $repos_root,
  			                         $branch_from,
  			                         $rev,
  			                         $self->{ref_id});
  			if ( my $commit = $gs->rev_map_get($rev, $uuid) ) {
  				# wahey!  we found it, but it might be
  				# an old one (!)
  				push @known_parents, [ $rev, $commit ];
  			}
  		}
  	}
  	# Ordering matters; highest-numbered commit merge tickets
  	# first, as they may account for later merge ticket additions
  	# or changes.
  	@known_parents = map {$_->[1]} sort {$b->[0] <=> $a->[0]} @known_parents;
  	for my $parent ( @known_parents ) {
  		my @cmd = ('rev-list', $parent, map { "^$_" } @$parents );
  		my ($msg_fh, $ctx) = command_output_pipe(@cmd);
  		my $new;
  		while ( <$msg_fh> ) {
  			$new=1;last;
  		}
  		command_close_pipe($msg_fh, $ctx);
  		if ( $new ) {
  			print STDERR
  			    "Found merge parent (svk:merge ticket): $parent\n";
  			push @$parents, $parent;
  		}
  	}
  }
  
  sub lookup_svn_merge {
  	my $uuid = shift;
  	my $url = shift;
  	my $source = shift;
  	my $revs = shift;
  
  	my $path = $source;
  	$path =~ s{^/}{};
  	my $gs = Git::SVN->find_by_url($url.$source, $url, $path);
  	if ( !$gs ) {
  		warn "Couldn't find revmap for $url$source\n";
  		return;
  	}
  	my @ranges = split ",", $revs;
  	my ($tip, $tip_commit);
  	my @merged_commit_ranges;
  	# find the tip
  	for my $range ( @ranges ) {
  		if ($range =~ /[*]$/) {
  			warn "W: Ignoring partial merge in svn:mergeinfo "
  				."dirprop: $source:$range\n";
  			next;
  		}
  		my ($bottom, $top) = split "-", $range;
  		$top ||= $bottom;
  		my $bottom_commit = $gs->find_rev_after( $bottom, 1, $top );
  		my $top_commit = $gs->find_rev_before( $top, 1, $bottom );
  
  		unless ($top_commit and $bottom_commit) {
  			warn "W: unknown path/rev in svn:mergeinfo "
  				."dirprop: $source:$range\n";
  			next;
  		}
  
  		if (scalar(command('rev-parse', "$bottom_commit^@"))) {
  			push @merged_commit_ranges,
  			     "$bottom_commit^..$top_commit";
  		} else {
  			push @merged_commit_ranges, "$top_commit";
  		}
  
  		if ( !defined $tip or $top > $tip ) {
  			$tip = $top;
  			$tip_commit = $top_commit;
  		}
  	}
  	return ($tip_commit, @merged_commit_ranges);
  }
  
  sub _rev_list {
  	my ($msg_fh, $ctx) = command_output_pipe(
  		"rev-list", @_,
  	       );
  	my @rv;
  	while ( <$msg_fh> ) {
  		chomp;
  		push @rv, $_;
  	}
  	command_close_pipe($msg_fh, $ctx);
  	@rv;
  }
  
  sub check_cherry_pick2 {
  	my $base = shift;
  	my $tip = shift;
  	my $parents = shift;
  	my @ranges = @_;
  	my %commits = map { $_ => 1 }
  		_rev_list("--no-merges", $tip, "--not", $base, @$parents, "--");
  	for my $range ( @ranges ) {
  		delete @commits{_rev_list($range, "--")};
  	}
  	for my $commit (keys %commits) {
  		if (has_no_changes($commit)) {
  			delete $commits{$commit};
  		}
  	}
  	my @k = (keys %commits);
  	return (scalar @k, $k[0]);
  }
  
  sub has_no_changes {
  	my $commit = shift;
  
  	my @revs = split / /, command_oneline(
  		qw(rev-list --parents -1 -m), $commit);
  
  	# Commits with no parents, e.g. the start of a partial branch,
  	# have changes by definition.
  	return 1 if (@revs < 2);
  
  	# Commits with multiple parents, e.g a merge, have no changes
  	# by definition.
  	return 0 if (@revs > 2);
  
  	return (command_oneline("rev-parse", "$commit^{tree}") eq
  		command_oneline("rev-parse", "$commit~1^{tree}"));
  }
  
  sub tie_for_persistent_memoization {
  	my $hash = shift;
  	my $path = shift;
  
  	unless ($memo_backend) {
  		if (eval { require Git::SVN::Memoize::YAML; 1}) {
  			$memo_backend = 1;
  		} else {
  			require Memoize::Storable;
  			$memo_backend = -1;
  		}
  	}
  
  	if ($memo_backend > 0) {
  		tie %$hash => 'Git::SVN::Memoize::YAML', "$path.yaml";
  	} else {
  		# first verify that any existing file can actually be loaded
  		# (it may have been saved by an incompatible version)
  		my $db = "$path.db";
  		if (-e $db) {
  			use Storable qw(retrieve);
  
  			if (!eval { retrieve($db); 1 }) {
  				unlink $db or die "unlink $db failed: $!";
  			}
  		}
  		tie %$hash => 'Memoize::Storable', $db, 'nstore';
  	}
  }
  
  # The GIT_DIR environment variable is not always set until after the command
  # line arguments are processed, so we can't memoize in a BEGIN block.
  {
  	my $memoized = 0;
  
  	sub memoize_svn_mergeinfo_functions {
  		return if $memoized;
  		$memoized = 1;
  
  		my $cache_path = svn_dir() . '/.caches/';
  		mkpath([$cache_path]) unless -d $cache_path;
  
  		my %lookup_svn_merge_cache;
  		my %check_cherry_pick2_cache;
  		my %has_no_changes_cache;
  
  		tie_for_persistent_memoization(\%lookup_svn_merge_cache,
  		    "$cache_path/lookup_svn_merge");
  		memoize 'lookup_svn_merge',
  			SCALAR_CACHE => 'FAULT',
  			LIST_CACHE => ['HASH' => \%lookup_svn_merge_cache],
  		;
  
  		tie_for_persistent_memoization(\%check_cherry_pick2_cache,
  		    "$cache_path/check_cherry_pick2");
  		memoize 'check_cherry_pick2',
  			SCALAR_CACHE => 'FAULT',
  			LIST_CACHE => ['HASH' => \%check_cherry_pick2_cache],
  		;
  
  		tie_for_persistent_memoization(\%has_no_changes_cache,
  		    "$cache_path/has_no_changes");
  		memoize 'has_no_changes',
  			SCALAR_CACHE => ['HASH' => \%has_no_changes_cache],
  			LIST_CACHE => 'FAULT',
  		;
  	}
  
  	sub unmemoize_svn_mergeinfo_functions {
  		return if not $memoized;
  		$memoized = 0;
  
  		Memoize::unmemoize 'lookup_svn_merge';
  		Memoize::unmemoize 'check_cherry_pick2';
  		Memoize::unmemoize 'has_no_changes';
  	}
  
  	sub clear_memoized_mergeinfo_caches {
  		die "Only call this method in non-memoized context" if ($memoized);
  
  		my $cache_path = svn_dir() . '/.caches/';
  		return unless -d $cache_path;
  
  		for my $cache_file (("$cache_path/lookup_svn_merge",
  				     "$cache_path/check_cherry_pick", # old
  				     "$cache_path/check_cherry_pick2",
  				     "$cache_path/has_no_changes")) {
  			for my $suffix (qw(yaml db)) {
  				my $file = "$cache_file.$suffix";
  				next unless -e $file;
  				unlink($file) or die "unlink($file) failed: $!\n";
  			}
  		}
  	}
  
  
  	Memoize::memoize 'Git::SVN::repos_root';
  }
  
  END {
  	# Force cache writeout explicitly instead of waiting for
  	# global destruction to avoid segfault in Storable:
  	# http://rt.cpan.org/Public/Bug/Display.html?id=36087
  	unmemoize_svn_mergeinfo_functions();
  }
  
  sub parents_exclude {
  	my $parents = shift;
  	my @commits = @_;
  	return unless @commits;
  
  	my @excluded;
  	my $excluded;
  	do {
  		my @cmd = ('rev-list', "-1", @commits, "--not", @$parents );
  		$excluded = command_oneline(@cmd);
  		if ( $excluded ) {
  			my @new;
  			my $found;
  			for my $commit ( @commits ) {
  				if ( $commit eq $excluded ) {
  					push @excluded, $commit;
  					$found++;
  				}
  				else {
  					push @new, $commit;
  				}
  			}
  			die "saw commit '$excluded' in rev-list output, "
  				."but we didn't ask for that commit (wanted: @commits --not @$parents)"
  					unless $found;
  			@commits = @new;
  		}
  	}
  		while ($excluded and @commits);
  
  	return @excluded;
  }
  
  # Compute what's new in svn:mergeinfo.
  sub mergeinfo_changes {
  	my ($self, $old_path, $old_rev, $path, $rev, $mergeinfo_prop) = @_;
  	my %minfo = map {split ":", $_ } split "\n", $mergeinfo_prop;
  	my $old_minfo = {};
  
  	my $ra = $self->ra;
  	# Give up if $old_path isn't in the repo.
  	# This is probably a merge on a subtree.
  	if ($ra->check_path($old_path, $old_rev) != $SVN::Node::dir) {
  		warn "W: ignoring svn:mergeinfo on $old_path, ",
  			"directory didn't exist in r$old_rev\n";
  		return {};
  	}
  	my (undef, undef, $props) = $ra->get_dir($old_path, $old_rev);
  	if (defined $props->{"svn:mergeinfo"}) {
  		my %omi = map {split ":", $_ } split "\n",
  			$props->{"svn:mergeinfo"};
  		$old_minfo = \%omi;
  	}
  
  	my %changes = ();
  	foreach my $p (keys %minfo) {
  		my $a = $old_minfo->{$p} || "";
  		my $b = $minfo{$p};
  		# Omit merged branches whose ranges lists are unchanged.
  		next if $a eq $b;
  		# Remove any common range list prefix.
  		($a ^ $b) =~ /^[\0]*/;
  		my $common_prefix = rindex $b, ",", $+[0] - 1;
  		$changes{$p} = substr $b, $common_prefix + 1;
  	}
  	print STDERR "Checking svn:mergeinfo changes since r$old_rev: ",
  		scalar(keys %minfo), " sources, ",
  		scalar(keys %changes), " changed\n";
  
  	return \%changes;
  }
  
  # note: this function should only be called if the various dirprops
  # have actually changed
  sub find_extra_svn_parents {
  	my ($self, $mergeinfo, $parents) = @_;
  	# aha!  svk:merge property changed...
  
  	memoize_svn_mergeinfo_functions();
  
  	# We first search for merged tips which are not in our
  	# history.  Then, we figure out which git revisions are in
  	# that tip, but not this revision.  If all of those revisions
  	# are now marked as merge, we can add the tip as a parent.
  	my @merges = sort keys %$mergeinfo;
  	my @merge_tips;
  	my $url = $self->url;
  	my $uuid = $self->ra_uuid;
  	my @all_ranges;
  	for my $merge ( @merges ) {
  		my ($tip_commit, @ranges) =
  			lookup_svn_merge( $uuid, $url,
  					  $merge, $mergeinfo->{$merge} );
  		unless (!$tip_commit or
  				grep { $_ eq $tip_commit } @$parents ) {
  			push @merge_tips, $tip_commit;
  			push @all_ranges, @ranges;
  		} else {
  			push @merge_tips, undef;
  		}
  	}
  
  	my %excluded = map { $_ => 1 }
  		parents_exclude($parents, grep { defined } @merge_tips);
  
  	# check merge tips for new parents
  	my @new_parents;
  	for my $merge_tip ( @merge_tips ) {
  		my $merge = shift @merges;
  		next unless $merge_tip and $excluded{$merge_tip};
  		my $spec = "$merge:$mergeinfo->{$merge}";
  
  		# check out 'new' tips
  		my $merge_base;
  		eval {
  			$merge_base = command_oneline(
  				"merge-base",
  				@$parents, $merge_tip,
  			);
  		};
  		if ($@) {
  			die "An error occurred during merge-base"
  				unless $@->isa("Git::Error::Command");
  
  			warn "W: Cannot find common ancestor between ".
  			     "@$parents and $merge_tip. Ignoring merge info.\n";
  			next;
  		}
  
  		# double check that there are no missing non-merge commits
  		my ($ninc, $ifirst) = check_cherry_pick2(
  			$merge_base, $merge_tip,
  			$parents,
  			@all_ranges,
  		       );
  
  		if ($ninc) {
  			warn "W: svn cherry-pick ignored ($spec) - missing " .
  				"$ninc commit(s) (eg $ifirst)\n";
  		} else {
  			warn "Found merge parent ($spec): ", $merge_tip, "\n";
  			push @new_parents, $merge_tip;
  		}
  	}
  
  	# cater for merges which merge commits from multiple branches
  	if ( @new_parents > 1 ) {
  		for ( my $i = 0; $i <= $#new_parents; $i++ ) {
  			for ( my $j = 0; $j <= $#new_parents; $j++ ) {
  				next if $i == $j;
  				next unless $new_parents[$i];
  				next unless $new_parents[$j];
  				my $revs = command_oneline(
  					"rev-list", "-1",
  					"$new_parents[$i]..$new_parents[$j]",
  				       );
  				if ( !$revs ) {
  					undef($new_parents[$j]);
  				}
  			}
  		}
  	}
  	push @$parents, grep { defined } @new_parents;
  }
  
  sub make_log_entry {
  	my ($self, $rev, $parents, $ed, $parent_rev, $parent_path) = @_;
  	my $untracked = $self->get_untracked($ed);
  
  	my @parents = @$parents;
  	my $props = $ed->{dir_prop}{$self->path};
  	if ($self->follow_parent) {
  		my $tickets = $props->{"svk:merge"};
  		if ($tickets) {
  			$self->find_extra_svk_parents($tickets, \@parents);
  		}
  
  		my $mergeinfo_prop = $props->{"svn:mergeinfo"};
  		if ($mergeinfo_prop) {
  			my $mi_changes = $self->mergeinfo_changes(
  						$parent_path,
  						$parent_rev,
  						$self->path,
  						$rev,
  						$mergeinfo_prop);
  			$self->find_extra_svn_parents($mi_changes, \@parents);
  		}
  	}
  
  	open my $un, '>>', "$self->{dir}/unhandled.log" or croak $!;
  	print $un "r$rev\n" or croak $!;
  	print $un $_, "\n" foreach @$untracked;
  	my %log_entry = ( parents => \@parents, revision => $rev,
  	                  log => '');
  
  	my $headrev;
  	my $logged = delete $self->{logged_rev_props};
  	if (!$logged || $self->{-want_revprops}) {
  		my $rp = $self->ra->rev_proplist($rev);
  		foreach (sort keys %$rp) {
  			my $v = $rp->{$_};
  			if (/^svn:(author|date|log)$/) {
  				$log_entry{$1} = $v;
  			} elsif ($_ eq 'svm:headrev') {
  				$headrev = $v;
  			} else {
  				print $un "  rev_prop: ", uri_encode($_), ' ',
  					  uri_encode($v), "\n";
  			}
  		}
  	} else {
  		map { $log_entry{$_} = $logged->{$_} } keys %$logged;
  	}
  	close $un or croak $!;
  
  	$log_entry{date} = parse_svn_date($log_entry{date});
  	$log_entry{log} .= "\n";
  	my $author = $log_entry{author} = check_author($log_entry{author});
  	my ($name, $email) = defined $::users{$author} ? @{$::users{$author}}
  						       : ($author, undef);
  
  	my ($commit_name, $commit_email) = ($name, $email);
  	if ($_use_log_author) {
  		my $name_field;
  		if ($log_entry{log} =~ /From:\s+(.*\S)\s*\n/i) {
  			$name_field = $1;
  		} elsif ($log_entry{log} =~ /Signed-off-by:\s+(.*\S)\s*\n/i) {
  			$name_field = $1;
  		}
  		if (!defined $name_field) {
  			if (!defined $email) {
  				$email = $name;
  			}
  		} elsif ($name_field =~ /(.*?)\s+<(.*)>/) {
  			($name, $email) = ($1, $2);
  		} elsif ($name_field =~ /(.*)@/) {
  			($name, $email) = ($1, $name_field);
  		} else {
  			($name, $email) = ($name_field, $name_field);
  		}
  	}
  	if (defined $headrev && $self->use_svm_props) {
  		if ($self->rewrite_root) {
  			die "Can't have both 'useSvmProps' and 'rewriteRoot' ",
  			    "options set!\n";
  		}
  		if ($self->rewrite_uuid) {
  			die "Can't have both 'useSvmProps' and 'rewriteUUID' ",
  			    "options set!\n";
  		}
  		my ($uuid, $r) = $headrev =~ m{^([a-f\d\-]{30,}):(\d+)$}i;
  		# we don't want "SVM: initializing mirror for junk" ...
  		return undef if $r == 0;
  		my $svm = $self->svm;
  		if ($uuid ne $svm->{uuid}) {
  			die "UUID mismatch on SVM path:\n",
  			    "expected: $svm->{uuid}\n",
  			    "     got: $uuid\n";
  		}
  		my $full_url = $self->full_url;
  		$full_url =~ s#^\Q$svm->{replace}\E(/|$)#$svm->{source}$1# or
  		             die "Failed to replace '$svm->{replace}' with ",
  		                 "'$svm->{source}' in $full_url\n";
  		# throw away username for storing in records
  		remove_username($full_url);
  		$log_entry{metadata} = "$full_url\@$r $uuid";
  		$log_entry{svm_revision} = $r;
  		$email ||= "$author\@$uuid";
  		$commit_email ||= "$author\@$uuid";
  	} elsif ($self->use_svnsync_props) {
  		my $full_url = canonicalize_url(
  			add_path_to_url( $self->svnsync->{url}, $self->path )
  		);
  		remove_username($full_url);
  		my $uuid = $self->svnsync->{uuid};
  		$log_entry{metadata} = "$full_url\@$rev $uuid";
  		$email ||= "$author\@$uuid";
  		$commit_email ||= "$author\@$uuid";
  	} else {
  		my $url = $self->metadata_url;
  		remove_username($url);
  		my $uuid = $self->rewrite_uuid || $self->ra->get_uuid;
  		$log_entry{metadata} = "$url\@$rev " . $uuid;
  		$email ||= "$author\@" . $uuid;
  		$commit_email ||= "$author\@" . $uuid;
  	}
  	$log_entry{name} = $name;
  	$log_entry{email} = $email;
  	$log_entry{commit_name} = $commit_name;
  	$log_entry{commit_email} = $commit_email;
  	\%log_entry;
  }
  
  sub fetch {
  	my ($self, $min_rev, $max_rev, @parents) = @_;
  	my ($last_rev, $last_commit) = $self->last_rev_commit;
  	my ($base, $head) = $self->get_fetch_range($min_rev, $max_rev);
  	$self->ra->gs_fetch_loop_common($base, $head, [$self]);
  }
  
  sub set_tree_cb {
  	my ($self, $log_entry, $tree, $rev, $date, $author) = @_;
  	$self->{inject_parents} = { $rev => $tree };
  	$self->fetch(undef, undef);
  }
  
  sub set_tree {
  	my ($self, $tree) = (shift, shift);
  	my $log_entry = ::get_commit_entry($tree);
  	unless ($self->{last_rev}) {
  		fatal("Must have an existing revision to commit");
  	}
  	my %ed_opts = ( r => $self->{last_rev},
  	                log => $log_entry->{log},
  	                ra => $self->ra,
  	                tree_a => $self->{last_commit},
  	                tree_b => $tree,
  	                editor_cb => sub {
  			       $self->set_tree_cb($log_entry, $tree, @_) },
  	                svn_path => $self->path );
  	if (!Git::SVN::Editor->new(\%ed_opts)->apply_diff) {
  		print "No changes\nr$self->{last_rev} = $tree\n";
  	}
  }
  
  sub rebuild_from_rev_db {
  	my ($self, $path) = @_;
  	my $r = -1;
  	open my $fh, '<', $path or croak "open: $!";
  	binmode $fh or croak "binmode: $!";
  	while (<$fh>) {
  		length($_) == 41 or croak "inconsistent size in ($_) != 41";
  		chomp($_);
  		++$r;
  		next if $_ eq ('0' x 40);
  		$self->rev_map_set($r, $_);
  		print "r$r = $_\n";
  	}
  	close $fh or croak "close: $!";
  	unlink $path or croak "unlink: $!";
  }
  
  #define a global associate map to record rebuild status
  my %rebuild_status;
  #define a global associate map to record rebuild verify status
  my %rebuild_verify_status;
  
  sub rebuild {
  	my ($self) = @_;
  	my $map_path = $self->map_path;
  	my $partial = (-e $map_path && ! -z $map_path);
  	my $verify_key = $self->refname.'^0';
  	if (!$rebuild_verify_status{$verify_key}) {
  		my $verify_result = ::verify_ref($verify_key);
  		if ($verify_result) {
  			$rebuild_verify_status{$verify_key} = 1;
  		}
  	}
  	if (!$rebuild_verify_status{$verify_key}) {
  		return;
  	}
  	if (!$partial && ($self->use_svm_props || $self->no_metadata)) {
  		my $rev_db = $self->rev_db_path;
  		$self->rebuild_from_rev_db($rev_db);
  		if ($self->use_svm_props) {
  			my $svm_rev_db = $self->rev_db_path($self->svm_uuid);
  			$self->rebuild_from_rev_db($svm_rev_db);
  		}
  		$self->unlink_rev_db_symlink;
  		return;
  	}
  	print "Rebuilding $map_path ...\n" if (!$partial);
  	my ($base_rev, $head) = ($partial ? $self->rev_map_max_norebuild(1) :
  		(undef, undef));
  	my $key_value = ($head ? "$head.." : "") . $self->refname;
  	if (exists $rebuild_status{$key_value}) {
  		print "Done rebuilding $map_path\n" if (!$partial || !$head);
  		my $rev_db_path = $self->rev_db_path;
  		if (-f $self->rev_db_path) {
  			unlink $self->rev_db_path or croak "unlink: $!";
  		}
  		$self->unlink_rev_db_symlink;
  		return;
  	}
  	my ($log, $ctx) =
  		command_output_pipe(qw/rev-list --pretty=raw --reverse/,
  				$key_value,
  				'--');
  	$rebuild_status{$key_value} = 1;
  	my $metadata_url = $self->metadata_url;
  	remove_username($metadata_url);
  	my $svn_uuid = $self->rewrite_uuid || $self->ra_uuid;
  	my $c;
  	while (<$log>) {
  		if ( m{^commit ($::sha1)$} ) {
  			$c = $1;
  			next;
  		}
  		next unless s{^\s*(git-svn-id:)}{$1};
  		my ($url, $rev, $uuid) = ::extract_metadata($_);
  		remove_username($url);
  
  		# ignore merges (from set-tree)
  		next if (!defined $rev || !$uuid);
  
  		# if we merged or otherwise started elsewhere, this is
  		# how we break out of it
  		if (($uuid ne $svn_uuid) ||
  		    ($metadata_url && $url && ($url ne $metadata_url))) {
  			next;
  		}
  		if ($partial && $head) {
  			print "Partial-rebuilding $map_path ...\n";
  			print "Currently at $base_rev = $head\n";
  			$head = undef;
  		}
  
  		$self->rev_map_set($rev, $c);
  		print "r$rev = $c\n";
  	}
  	command_close_pipe($log, $ctx);
  	print "Done rebuilding $map_path\n" if (!$partial || !$head);
  	my $rev_db_path = $self->rev_db_path;
  	if (-f $self->rev_db_path) {
  		unlink $self->rev_db_path or croak "unlink: $!";
  	}
  	$self->unlink_rev_db_symlink;
  }
  
  # rev_map:
  # Tie::File seems to be prone to offset errors if revisions get sparse,
  # it's not that fast, either.  Tie::File is also not in Perl 5.6.  So
  # one of my favorite modules is out :<  Next up would be one of the DBM
  # modules, but I'm not sure which is most portable...
  #
  # This is the replacement for the rev_db format, which was too big
  # and inefficient for large repositories with a lot of sparse history
  # (mainly tags)
  #
  # The format is this:
  #   - 24 bytes for every record,
  #     * 4 bytes for the integer representing an SVN revision number
  #     * 20 bytes representing the sha1 of a git commit
  #   - No empty padding records like the old format
  #     (except the last record, which can be overwritten)
  #   - new records are written append-only since SVN revision numbers
  #     increase monotonically
  #   - lookups on SVN revision number are done via a binary search
  #   - Piping the file to xxd -c24 is a good way of dumping it for
  #     viewing or editing (piped back through xxd -r), should the need
  #     ever arise.
  #   - The last record can be padding revision with an all-zero sha1
  #     This is used to optimize fetch performance when using multiple
  #     "fetch" directives in .git/config
  #
  # These files are disposable unless noMetadata or useSvmProps is set
  
  sub _rev_map_set {
  	my ($fh, $rev, $commit) = @_;
  
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	my $wr_offset = 0;
  	if ($size > 0) {
  		sysseek($fh, -24, SEEK_END) or croak "seek: $!";
  		my $read = sysread($fh, my $buf, 24) or croak "read: $!";
  		$read == 24 or croak "read only $read bytes (!= 24)";
  		my ($last_rev, $last_commit) = unpack(rev_map_fmt, $buf);
  		if ($last_commit eq ('0' x40)) {
  			if ($size >= 48) {
  				sysseek($fh, -48, SEEK_END) or croak "seek: $!";
  				$read = sysread($fh, $buf, 24) or
  				    croak "read: $!";
  				$read == 24 or
  				    croak "read only $read bytes (!= 24)";
  				($last_rev, $last_commit) =
  				    unpack(rev_map_fmt, $buf);
  				if ($last_commit eq ('0' x40)) {
  					croak "inconsistent .rev_map\n";
  				}
  			}
  			if ($last_rev >= $rev) {
  				croak "last_rev is higher!: $last_rev >= $rev";
  			}
  			$wr_offset = -24;
  		}
  	}
  	sysseek($fh, $wr_offset, SEEK_END) or croak "seek: $!";
  	syswrite($fh, pack(rev_map_fmt, $rev, $commit), 24) == 24 or
  	  croak "write: $!";
  }
  
  sub _rev_map_reset {
  	my ($fh, $rev, $commit) = @_;
  	my $c = _rev_map_get($fh, $rev);
  	$c eq $commit or die "_rev_map_reset(@_) commit $c does not match!\n";
  	my $offset = sysseek($fh, 0, SEEK_CUR) or croak "seek: $!";
  	truncate $fh, $offset or croak "truncate: $!";
  }
  
  sub mkfile {
  	my ($path) = @_;
  	unless (-e $path) {
  		my ($dir, $base) = ($path =~ m#^(.*?)/?([^/]+)$#);
  		mkpath([$dir]) unless -d $dir;
  		open my $fh, '>>', $path or die "Couldn't create $path: $!\n";
  		close $fh or die "Couldn't close (create) $path: $!\n";
  	}
  }
  
  sub rev_map_set {
  	my ($self, $rev, $commit, $update_ref, $uuid) = @_;
  	defined $commit or die "missing arg3\n";
  	length $commit == 40 or die "arg3 must be a full SHA1 hexsum\n";
  	my $db = $self->map_path($uuid);
  	my $db_lock = "$db.lock";
  	my $sigmask;
  	$update_ref ||= 0;
  	if ($update_ref) {
  		$sigmask = POSIX::SigSet->new();
  		my $signew = POSIX::SigSet->new(SIGINT, SIGHUP, SIGTERM,
  			SIGALRM, SIGUSR1, SIGUSR2);
  		sigprocmask(SIG_BLOCK, $signew, $sigmask) or
  			croak "Can't block signals: $!";
  	}
  	mkfile($db);
  
  	$LOCKFILES{$db_lock} = 1;
  	my $sync;
  	# both of these options make our .rev_db file very, very important
  	# and we can't afford to lose it because rebuild() won't work
  	if ($self->use_svm_props || $self->no_metadata) {
  		require File::Copy;
  		$sync = 1;
  		File::Copy::copy($db, $db_lock) or die "rev_map_set(@_): ",
  					   "Failed to copy: ",
  					   "$db => $db_lock ($!)\n";
  	} else {
  		rename $db, $db_lock or die "rev_map_set(@_): ",
  					    "Failed to rename: ",
  					    "$db => $db_lock ($!)\n";
  	}
  
  	sysopen(my $fh, $db_lock, O_RDWR | O_CREAT)
  	     or croak "Couldn't open $db_lock: $!\n";
  	if ($update_ref eq 'reset') {
  		clear_memoized_mergeinfo_caches();
  		_rev_map_reset($fh, $rev, $commit);
  	} else {
  		_rev_map_set($fh, $rev, $commit);
  	}
  
  	if ($sync) {
  		$fh->flush or die "Couldn't flush $db_lock: $!\n";
  		$fh->sync or die "Couldn't sync $db_lock: $!\n";
  	}
  	close $fh or croak $!;
  	if ($update_ref) {
  		$_head = $self;
  		my $note = "";
  		$note = " ($update_ref)" if ($update_ref !~ /^\d*$/);
  		command_noisy('update-ref', '-m', "r$rev$note",
  		              $self->refname, $commit);
  	}
  	rename $db_lock, $db or die "rev_map_set(@_): ", "Failed to rename: ",
  	                            "$db_lock => $db ($!)\n";
  	delete $LOCKFILES{$db_lock};
  	if ($update_ref) {
  		sigprocmask(SIG_SETMASK, $sigmask) or
  			croak "Can't restore signal mask: $!";
  	}
  }
  
  # If want_commit, this will return an array of (rev, commit) where
  # commit _must_ be a valid commit in the archive.
  # Otherwise, it'll return the max revision (whether or not the
  # commit is valid or just a 0x40 placeholder).
  sub rev_map_max {
  	my ($self, $want_commit) = @_;
  	$self->rebuild;
  	my ($r, $c) = $self->rev_map_max_norebuild($want_commit);
  	$want_commit ? ($r, $c) : $r;
  }
  
  sub rev_map_max_norebuild {
  	my ($self, $want_commit) = @_;
  	my $map_path = $self->map_path;
  	stat $map_path or return $want_commit ? (0, undef) : 0;
  	sysopen(my $fh, $map_path, O_RDONLY) or croak "open: $!";
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	if ($size == 0) {
  		close $fh or croak "close: $!";
  		return $want_commit ? (0, undef) : 0;
  	}
  
  	sysseek($fh, -24, SEEK_END) or croak "seek: $!";
  	sysread($fh, my $buf, 24) == 24 or croak "read: $!";
  	my ($r, $c) = unpack(rev_map_fmt, $buf);
  	if ($want_commit && $c eq ('0' x40)) {
  		if ($size < 48) {
  			return $want_commit ? (0, undef) : 0;
  		}
  		sysseek($fh, -48, SEEK_END) or croak "seek: $!";
  		sysread($fh, $buf, 24) == 24 or croak "read: $!";
  		($r, $c) = unpack(rev_map_fmt, $buf);
  		if ($c eq ('0'x40)) {
  			croak "Penultimate record is all-zeroes in $map_path";
  		}
  	}
  	close $fh or croak "close: $!";
  	$want_commit ? ($r, $c) : $r;
  }
  
  sub rev_map_get {
  	my ($self, $rev, $uuid) = @_;
  	my $map_path = $self->map_path($uuid);
  	return undef unless -e $map_path;
  
  	sysopen(my $fh, $map_path, O_RDONLY) or croak "open: $!";
  	my $c = _rev_map_get($fh, $rev);
  	close($fh) or croak "close: $!";
  	$c
  }
  
  sub _rev_map_get {
  	my ($fh, $rev) = @_;
  
  	binmode $fh or croak "binmode: $!";
  	my $size = (stat($fh))[7];
  	($size % 24) == 0 or croak "inconsistent size: $size";
  
  	if ($size == 0) {
  		return undef;
  	}
  
  	my ($l, $u) = (0, $size - 24);
  	my ($r, $c, $buf);
  
  	while ($l <= $u) {
  		my $i = int(($l/24 + $u/24) / 2) * 24;
  		sysseek($fh, $i, SEEK_SET) or croak "seek: $!";
  		sysread($fh, my $buf, 24) == 24 or croak "read: $!";
  		my ($r, $c) = unpack(rev_map_fmt, $buf);
  
  		if ($r < $rev) {
  			$l = $i + 24;
  		} elsif ($r > $rev) {
  			$u = $i - 24;
  		} else { # $r == $rev
  			return $c eq ('0' x 40) ? undef : $c;
  		}
  	}
  	undef;
  }
  
  # Finds the first svn revision that exists on (if $eq_ok is true) or
  # before $rev for the current branch.  It will not search any lower
  # than $min_rev.  Returns the git commit hash and svn revision number
  # if found, else (undef, undef).
  sub find_rev_before {
  	my ($self, $rev, $eq_ok, $min_rev) = @_;
  	--$rev unless $eq_ok;
  	$min_rev ||= 1;
  	my $max_rev = $self->rev_map_max;
  	$rev = $max_rev if ($rev > $max_rev);
  	while ($rev >= $min_rev) {
  		if (my $c = $self->rev_map_get($rev)) {
  			return ($rev, $c);
  		}
  		--$rev;
  	}
  	return (undef, undef);
  }
  
  # Finds the first svn revision that exists on (if $eq_ok is true) or
  # after $rev for the current branch.  It will not search any higher
  # than $max_rev.  Returns the git commit hash and svn revision number
  # if found, else (undef, undef).
  sub find_rev_after {
  	my ($self, $rev, $eq_ok, $max_rev) = @_;
  	++$rev unless $eq_ok;
  	$max_rev ||= $self->rev_map_max;
  	while ($rev <= $max_rev) {
  		if (my $c = $self->rev_map_get($rev)) {
  			return ($rev, $c);
  		}
  		++$rev;
  	}
  	return (undef, undef);
  }
  
  sub _new {
  	my ($class, $repo_id, $ref_id, $path) = @_;
  	unless (defined $repo_id && length $repo_id) {
  		$repo_id = $default_repo_id;
  	}
  	unless (defined $ref_id && length $ref_id) {
  		# Access the prefix option from the git-svn main program if it's loaded.
  		my $prefix = defined &::opt_prefix ? ::opt_prefix() : "";
  		$_[2] = $ref_id =
  		             "refs/remotes/$prefix$default_ref_id";
  	}
  	$_[1] = $repo_id;
  	my $svn_dir = svn_dir();
  	my $dir = "$svn_dir/$ref_id";
  
  	# Older repos imported by us used $svn_dir/foo instead of
  	# $svn_dir/refs/remotes/foo when tracking refs/remotes/foo
  	if ($ref_id =~ m{^refs/remotes/(.+)}) {
  		my $old_dir = "$svn_dir/$1";
  		if (-d $old_dir && ! -d $dir) {
  			$dir = $old_dir;
  		}
  	}
  
  	$_[3] = $path = '' unless (defined $path);
  	mkpath([$dir]);
  	my $obj = bless {
  		ref_id => $ref_id, dir => $dir, index => "$dir/index",
  	        config => "$svn_dir/config",
  	        map_root => "$dir/.rev_map", repo_id => $repo_id }, $class;
  
  	# Ensure it gets canonicalized
  	$obj->path($path);
  
  	return $obj;
  }
  
  sub path {
  	my $self = shift;
  
  	if (@_) {
  		my $path = shift;
  		$self->{_path} = canonicalize_path($path);
  		return;
  	}
  
  	return $self->{_path};
  }
  
  sub url {
  	my $self = shift;
  
  	if (@_) {
  		my $url = shift;
  		$self->{url} = canonicalize_url($url);
  		return;
  	}
  
  	return $self->{url};
  }
  
  # for read-only access of old .rev_db formats
  sub unlink_rev_db_symlink {
  	my ($self) = @_;
  	my $link = $self->rev_db_path;
  	$link =~ s/\.[\w-]+$// or croak "missing UUID at the end of $link";
  	if (-l $link) {
  		unlink $link or croak "unlink: $link failed!";
  	}
  }
  
  sub rev_db_path {
  	my ($self, $uuid) = @_;
  	my $db_path = $self->map_path($uuid);
  	$db_path =~ s{/\.rev_map\.}{/\.rev_db\.}
  	    or croak "map_path: $db_path does not contain '/.rev_map.' !";
  	$db_path;
  }
  
  # the new replacement for .rev_db
  sub map_path {
  	my ($self, $uuid) = @_;
  	$uuid ||= $self->ra_uuid;
  	"$self->{map_root}.$uuid";
  }
  
  sub uri_encode {
  	my ($f) = @_;
  	$f =~ s#([^a-zA-Z0-9\*!\:_\./\-])#sprintf("%%%02X",ord($1))#eg;
  	$f
  }
  
  sub uri_decode {
  	my ($f) = @_;
  	$f =~ s#%([0-9a-fA-F]{2})#chr(hex($1))#eg;
  	$f
  }
  
  sub remove_username {
  	$_[0] =~ s{^([^:]*://)[^@]+@}{$1};
  }
  
  1;
GIT_SVN

$fatpacked{"Git/SVN/Editor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_EDITOR';
  package Git::SVN::Editor;
  use vars qw/@ISA $_rmdir $_cp_similarity $_find_copies_harder $_rename_limit/;
  use strict;
  use warnings;
  use SVN::Core;
  use SVN::Delta;
  use Carp qw/croak/;
  use Git qw/command command_oneline command_noisy command_output_pipe
             command_input_pipe command_close_pipe
             command_bidi_pipe command_close_bidi_pipe
             get_record/;
  
  BEGIN {
  	@ISA = qw(SVN::Delta::Editor);
  }
  
  sub new {
  	my ($class, $opts) = @_;
  	foreach (qw/svn_path r ra tree_a tree_b log editor_cb/) {
  		die "$_ required!\n" unless (defined $opts->{$_});
  	}
  
  	my $pool = SVN::Pool->new;
  	my $mods = generate_diff($opts->{tree_a}, $opts->{tree_b});
  	my $types = check_diff_paths($opts->{ra}, $opts->{svn_path},
  	                             $opts->{r}, $mods);
  
  	# $opts->{ra} functions should not be used after this:
  	my @ce  = $opts->{ra}->get_commit_editor($opts->{log},
  	                                        $opts->{editor_cb}, $pool);
  	my $self = SVN::Delta::Editor->new(@ce, $pool);
  	bless $self, $class;
  	foreach (qw/svn_path r tree_a tree_b/) {
  		$self->{$_} = $opts->{$_};
  	}
  	$self->{url} = $opts->{ra}->{url};
  	$self->{mods} = $mods;
  	$self->{types} = $types;
  	$self->{pool} = $pool;
  	$self->{bat} = { '' => $self->open_root($self->{r}, $self->{pool}) };
  	$self->{rm} = { };
  	$self->{path_prefix} = length $self->{svn_path} ?
  	                       "$self->{svn_path}/" : '';
  	$self->{config} = $opts->{config};
  	$self->{mergeinfo} = $opts->{mergeinfo};
  	$self->{pathnameencoding} = Git::config('svn.pathnameencoding');
  	return $self;
  }
  
  sub generate_diff {
  	my ($tree_a, $tree_b) = @_;
  	my @diff_tree = qw(diff-tree -z -r);
  	if ($_cp_similarity) {
  		push @diff_tree, "-C$_cp_similarity";
  	} else {
  		push @diff_tree, '-C';
  	}
  	push @diff_tree, '--find-copies-harder' if $_find_copies_harder;
  	push @diff_tree, "-l$_rename_limit" if defined $_rename_limit;
  	push @diff_tree, $tree_a, $tree_b;
  	my ($diff_fh, $ctx) = command_output_pipe(@diff_tree);
  	my $state = 'meta';
  	my @mods;
  	while (defined($_ = get_record($diff_fh, "\0"))) {
  		if ($state eq 'meta' && /^:(\d{6})\s(\d{6})\s
  					($::sha1)\s($::sha1)\s
  					([MTCRAD])\d*$/xo) {
  			push @mods, {	mode_a => $1, mode_b => $2,
  					sha1_a => $3, sha1_b => $4,
  					chg => $5 };
  			if ($5 =~ /^(?:C|R)$/) {
  				$state = 'file_a';
  			} else {
  				$state = 'file_b';
  			}
  		} elsif ($state eq 'file_a') {
  			my $x = $mods[$#mods] or croak "Empty array\n";
  			if ($x->{chg} !~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			$x->{file_a} = $_;
  			$state = 'file_b';
  		} elsif ($state eq 'file_b') {
  			my $x = $mods[$#mods] or croak "Empty array\n";
  			if (exists $x->{file_a} && $x->{chg} !~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			if (!exists $x->{file_a} && $x->{chg} =~ /^(?:C|R)$/) {
  				croak "Error parsing $_, $x->{chg}\n";
  			}
  			$x->{file_b} = $_;
  			$state = 'meta';
  		} else {
  			croak "Error parsing $_\n";
  		}
  	}
  	command_close_pipe($diff_fh, $ctx);
  	\@mods;
  }
  
  sub check_diff_paths {
  	my ($ra, $pfx, $rev, $mods) = @_;
  	my %types;
  	$pfx .= '/' if length $pfx;
  
  	sub type_diff_paths {
  		my ($ra, $types, $path, $rev) = @_;
  		my @p = split m#/+#, $path;
  		my $c = shift @p;
  		unless (defined $types->{$c}) {
  			$types->{$c} = $ra->check_path($c, $rev);
  		}
  		while (@p) {
  			$c .= '/' . shift @p;
  			next if defined $types->{$c};
  			$types->{$c} = $ra->check_path($c, $rev);
  		}
  	}
  
  	foreach my $m (@$mods) {
  		foreach my $f (qw/file_a file_b/) {
  			next unless defined $m->{$f};
  			my ($dir) = ($m->{$f} =~ m#^(.*?)/?(?:[^/]+)$#);
  			if (length $pfx.$dir && ! defined $types{$dir}) {
  				type_diff_paths($ra, \%types, $pfx.$dir, $rev);
  			}
  		}
  	}
  	\%types;
  }
  
  sub split_path {
  	return ($_[0] =~ m#^(.*?)/?([^/]+)$#);
  }
  
  sub repo_path {
  	my ($self, $path) = @_;
  	if (my $enc = $self->{pathnameencoding}) {
  		require Encode;
  		Encode::from_to($path, $enc, 'UTF-8');
  	}
  	$self->{path_prefix}.(defined $path ? $path : '');
  }
  
  sub url_path {
  	my ($self, $path) = @_;
  	$path = $self->repo_path($path);
  	if ($self->{url} =~ m#^https?://#) {
  		# characters are taken from subversion/libsvn_subr/path.c
  		$path =~ s#([^~a-zA-Z0-9_./!$&'()*+,-])#sprintf("%%%02X",ord($1))#eg;
  	}
  	$self->{url} . '/' . $path;
  }
  
  sub rmdirs {
  	my ($self) = @_;
  	my $rm = $self->{rm};
  	delete $rm->{''}; # we never delete the url we're tracking
  	return unless %$rm;
  
  	foreach (keys %$rm) {
  		my @d = split m#/#, $_;
  		my $c = shift @d;
  		$rm->{$c} = 1;
  		while (@d) {
  			$c .= '/' . shift @d;
  			$rm->{$c} = 1;
  		}
  	}
  	delete $rm->{$self->{svn_path}};
  	delete $rm->{''}; # we never delete the url we're tracking
  	return unless %$rm;
  
  	my ($fh, $ctx) = command_output_pipe(qw/ls-tree --name-only -r -z/,
  	                                     $self->{tree_b});
  	while (defined($_ = get_record($fh, "\0"))) {
  		my @dn = split m#/#, $_;
  		while (pop @dn) {
  			delete $rm->{join '/', @dn};
  		}
  		unless (%$rm) {
  			close $fh;
  			return;
  		}
  	}
  	command_close_pipe($fh, $ctx);
  
  	my ($r, $p, $bat) = ($self->{r}, $self->{pool}, $self->{bat});
  	foreach my $d (sort { $b =~ tr#/#/# <=> $a =~ tr#/#/# } keys %$rm) {
  		$self->close_directory($bat->{$d}, $p);
  		my ($dn) = ($d =~ m#^(.*?)/?(?:[^/]+)$#);
  		print "\tD+\t$d/\n" unless $::_q;
  		$self->SUPER::delete_entry($d, $r, $bat->{$dn}, $p);
  		delete $bat->{$d};
  	}
  }
  
  sub open_or_add_dir {
  	my ($self, $full_path, $baton, $deletions) = @_;
  	my $t = $self->{types}->{$full_path};
  	if (!defined $t) {
  		die "$full_path not known in r$self->{r} or we have a bug!\n";
  	}
  	{
  		no warnings 'once';
  		# SVN::Node::none and SVN::Node::file are used only once,
  		# so we're shutting up Perl's warnings about them.
  		if ($t == $SVN::Node::none || defined($deletions->{$full_path})) {
  			return $self->add_directory($full_path, $baton,
  			    undef, -1, $self->{pool});
  		} elsif ($t == $SVN::Node::dir) {
  			return $self->open_directory($full_path, $baton,
  			    $self->{r}, $self->{pool});
  		} # no warnings 'once'
  		print STDERR "$full_path already exists in repository at ",
  		    "r$self->{r} and it is not a directory (",
  		    ($t == $SVN::Node::file ? 'file' : 'unknown'),"/$t)\n";
  	} # no warnings 'once'
  	exit 1;
  }
  
  sub ensure_path {
  	my ($self, $path, $deletions) = @_;
  	my $bat = $self->{bat};
  	my $repo_path = $self->repo_path($path);
  	return $bat->{''} unless (length $repo_path);
  
  	my @p = split m#/+#, $repo_path;
  	my $c = shift @p;
  	$bat->{$c} ||= $self->open_or_add_dir($c, $bat->{''}, $deletions);
  	while (@p) {
  		my $c0 = $c;
  		$c .= '/' . shift @p;
  		$bat->{$c} ||= $self->open_or_add_dir($c, $bat->{$c0}, $deletions);
  	}
  	return $bat->{$c};
  }
  
  # Subroutine to convert a globbing pattern to a regular expression.
  # From perl cookbook.
  sub glob2pat {
  	my $globstr = shift;
  	my %patmap = ('*' => '.*', '?' => '.', '[' => '[', ']' => ']');
  	$globstr =~ s{(.)} { $patmap{$1} || "\Q$1" }ge;
  	return '^' . $globstr . '$';
  }
  
  sub check_autoprop {
  	my ($self, $pattern, $properties, $file, $fbat) = @_;
  	# Convert the globbing pattern to a regular expression.
  	my $regex = glob2pat($pattern);
  	# Check if the pattern matches the file name.
  	if($file =~ m/($regex)/) {
  		# Parse the list of properties to set.
  		my @props = split(/;/, $properties);
  		foreach my $prop (@props) {
  			# Parse 'name=value' syntax and set the property.
  			if ($prop =~ /([^=]+)=(.*)/) {
  				my ($n,$v) = ($1,$2);
  				for ($n, $v) {
  					s/^\s+//; s/\s+$//;
  				}
  				$self->change_file_prop($fbat, $n, $v);
  			}
  		}
  	}
  }
  
  sub apply_autoprops {
  	my ($self, $file, $fbat) = @_;
  	my $conf_t = ${$self->{config}}{'config'};
  	no warnings 'once';
  	# Check [miscellany]/enable-auto-props in svn configuration.
  	if (SVN::_Core::svn_config_get_bool(
  		$conf_t,
  		$SVN::_Core::SVN_CONFIG_SECTION_MISCELLANY,
  		$SVN::_Core::SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS,
  		0)) {
  		# Auto-props are enabled.  Enumerate them to look for matches.
  		my $callback = sub {
  			$self->check_autoprop($_[0], $_[1], $file, $fbat);
  		};
  		SVN::_Core::svn_config_enumerate(
  			$conf_t,
  			$SVN::_Core::SVN_CONFIG_SECTION_AUTO_PROPS,
  			$callback);
  	}
  }
  
  sub check_attr {
  	my ($attr,$path) = @_;
  	my $val = command_oneline("check-attr", $attr, "--", $path);
  	if ($val) { $val =~ s/^[^:]*:\s*[^:]*:\s*(.*)\s*$/$1/; }
  	return $val;
  }
  
  sub apply_manualprops {
  	my ($self, $file, $fbat) = @_;
  	my $pending_properties = check_attr( "svn-properties", $file );
  	if ($pending_properties eq "") { return; }
  	# Parse the list of properties to set.
  	my @props = split(/;/, $pending_properties);
  	# TODO: get existing properties to compare to
  	# - this fails for add so currently not done
  	# my $existing_props = ::get_svnprops($file);
  	my $existing_props = {};
  	# TODO: caching svn properties or storing them in .gitattributes
  	# would make that faster
  	foreach my $prop (@props) {
  		# Parse 'name=value' syntax and set the property.
  		if ($prop =~ /([^=]+)=(.*)/) {
  			my ($n,$v) = ($1,$2);
  			for ($n, $v) {
  				s/^\s+//; s/\s+$//;
  			}
  			my $existing = $existing_props->{$n};
  			if (!defined($existing) || $existing ne $v) {
  			    $self->change_file_prop($fbat, $n, $v);
  			}
  		}
  	}
  }
  
  sub A {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  					undef, -1);
  	print "\tA\t$m->{file_b}\n" unless $::_q;
  	$self->apply_autoprops($file, $fbat);
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub C {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	# workaround for a bug in svn serf backend (v1.8.5 and below):
  	# store third argument to ->add_file() in a local variable, to make it
  	# have the same lifetime as $fbat
  	my $upa = $self->url_path($m->{file_a});
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  				$upa, $self->{r});
  	print "\tC\t$m->{file_a} => $m->{file_b}\n" unless $::_q;
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub delete_entry {
  	my ($self, $path, $pbat) = @_;
  	my $rpath = $self->repo_path($path);
  	my ($dir, $file) = split_path($rpath);
  	$self->{rm}->{$dir} = 1;
  	$self->SUPER::delete_entry($rpath, $self->{r}, $pbat, $self->{pool});
  }
  
  sub R {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	# workaround for a bug in svn serf backend, see comment in C() above
  	my $upa = $self->url_path($m->{file_a});
  	my $fbat = $self->add_file($self->repo_path($m->{file_b}), $pbat,
  				$upa, $self->{r});
  	print "\tR\t$m->{file_a} => $m->{file_b}\n" unless $::_q;
  	$self->apply_autoprops($file, $fbat);
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  
  	($dir, $file) = split_path($m->{file_a});
  	$pbat = $self->ensure_path($dir, $deletions);
  	$self->delete_entry($m->{file_a}, $pbat);
  }
  
  sub M {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	my $fbat = $self->open_file($self->repo_path($m->{file_b}),
  				$pbat,$self->{r},$self->{pool});
  	print "\t$m->{chg}\t$m->{file_b}\n" unless $::_q;
  	$self->apply_manualprops($m->{file_b}, $fbat);
  	$self->chg_file($fbat, $m);
  	$self->close_file($fbat,undef,$self->{pool});
  }
  
  sub T {
  	my ($self, $m, $deletions) = @_;
  
  	# Work around subversion issue 4091: toggling the "is a
  	# symlink" property requires removing and re-adding a
  	# file or else "svn up" on affected clients trips an
  	# assertion and aborts.
  	if (($m->{mode_b} =~ /^120/ && $m->{mode_a} !~ /^120/) ||
  	    ($m->{mode_b} !~ /^120/ && $m->{mode_a} =~ /^120/)) {
  		$self->D({
  			mode_a => $m->{mode_a}, mode_b => '000000',
  			sha1_a => $m->{sha1_a}, sha1_b => '0' x 40,
  			chg => 'D', file_b => $m->{file_b}
  		}, $deletions);
  		$self->A({
  			mode_a => '000000', mode_b => $m->{mode_b},
  			sha1_a => '0' x 40, sha1_b => $m->{sha1_b},
  			chg => 'A', file_b => $m->{file_b}
  		}, $deletions);
  		return;
  	}
  
  	$self->M($m, $deletions);
  }
  
  sub change_file_prop {
  	my ($self, $fbat, $pname, $pval) = @_;
  	$self->SUPER::change_file_prop($fbat, $pname, $pval, $self->{pool});
  }
  
  sub change_dir_prop {
  	my ($self, $pbat, $pname, $pval) = @_;
  	$self->SUPER::change_dir_prop($pbat, $pname, $pval, $self->{pool});
  }
  
  sub _chg_file_get_blob ($$$$) {
  	my ($self, $fbat, $m, $which) = @_;
  	my $fh = $::_repository->temp_acquire("git_blob_$which");
  	if ($m->{"mode_$which"} =~ /^120/) {
  		print $fh 'link ' or croak $!;
  		$self->change_file_prop($fbat,'svn:special','*');
  	} elsif ($m->{mode_a} =~ /^120/ && $m->{"mode_$which"} !~ /^120/) {
  		$self->change_file_prop($fbat,'svn:special',undef);
  	}
  	my $blob = $m->{"sha1_$which"};
  	return ($fh,) if ($blob =~ /^0{40}$/);
  	my $size = $::_repository->cat_blob($blob, $fh);
  	croak "Failed to read object $blob" if ($size < 0);
  	$fh->flush == 0 or croak $!;
  	seek $fh, 0, 0 or croak $!;
  
  	my $exp = ::md5sum($fh);
  	seek $fh, 0, 0 or croak $!;
  	return ($fh, $exp);
  }
  
  sub chg_file {
  	my ($self, $fbat, $m) = @_;
  	if ($m->{mode_b} =~ /755$/ && $m->{mode_a} !~ /755$/) {
  		$self->change_file_prop($fbat,'svn:executable','*');
  	} elsif ($m->{mode_b} !~ /755$/ && $m->{mode_a} =~ /755$/) {
  		$self->change_file_prop($fbat,'svn:executable',undef);
  	}
  	my ($fh_a, $exp_a) = _chg_file_get_blob $self, $fbat, $m, 'a';
  	my ($fh_b, $exp_b) = _chg_file_get_blob $self, $fbat, $m, 'b';
  	my $pool = SVN::Pool->new;
  	my $atd = $self->apply_textdelta($fbat, $exp_a, $pool);
  	if (-s $fh_a) {
  		my $txstream = SVN::TxDelta::new ($fh_a, $fh_b, $pool);
  		my $res = SVN::TxDelta::send_txstream($txstream, @$atd, $pool);
  		if (defined $res) {
  			die "Unexpected result from send_txstream: $res\n",
  			    "(SVN::Core::VERSION: $SVN::Core::VERSION)\n";
  		}
  	} else {
  		my $got = SVN::TxDelta::send_stream($fh_b, @$atd, $pool);
  		die "Checksum mismatch\nexpected: $exp_b\ngot: $got\n"
  		    if ($got ne $exp_b);
  	}
  	Git::temp_release($fh_b, 1);
  	Git::temp_release($fh_a, 1);
  	$pool->clear;
  }
  
  sub D {
  	my ($self, $m, $deletions) = @_;
  	my ($dir, $file) = split_path($m->{file_b});
  	my $pbat = $self->ensure_path($dir, $deletions);
  	print "\tD\t$m->{file_b}\n" unless $::_q;
  	$self->delete_entry($m->{file_b}, $pbat);
  }
  
  sub close_edit {
  	my ($self) = @_;
  	my ($p,$bat) = ($self->{pool}, $self->{bat});
  	foreach (sort { $b =~ tr#/#/# <=> $a =~ tr#/#/# } keys %$bat) {
  		next if $_ eq '';
  		$self->close_directory($bat->{$_}, $p);
  	}
  	$self->close_directory($bat->{''}, $p);
  	$self->SUPER::close_edit($p);
  	$p->clear;
  }
  
  sub abort_edit {
  	my ($self) = @_;
  	$self->SUPER::abort_edit($self->{pool});
  }
  
  sub DESTROY {
  	my $self = shift;
  	$self->SUPER::DESTROY(@_);
  	$self->{pool}->clear;
  }
  
  # this drives the editor
  sub apply_diff {
  	my ($self) = @_;
  	my $mods = $self->{mods};
  	my %o = ( D => 0, C => 1, R => 2, A => 3, M => 4, T => 5 );
  	my %deletions;
  
  	foreach my $m (@$mods) {
  		if ($m->{chg} eq "D") {
  			$deletions{$m->{file_b}} = 1;
  		}
  	}
  
  	foreach my $m (sort { $o{$a->{chg}} <=> $o{$b->{chg}} } @$mods) {
  		my $f = $m->{chg};
  		if (defined $o{$f}) {
  			$self->$f($m, \%deletions);
  		} else {
  			fatal("Invalid change type: $f");
  		}
  	}
  
  	if (defined($self->{mergeinfo})) {
  		$self->change_dir_prop($self->{bat}{''}, "svn:mergeinfo",
  			               $self->{mergeinfo});
  	}
  	$self->rmdirs if $_rmdir;
  	if (@$mods == 0 && !defined($self->{mergeinfo})) {
  		$self->abort_edit;
  	} else {
  		$self->close_edit;
  	}
  	return scalar @$mods;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Editor - commit driver for "git svn set-tree" and dcommit
  
  =head1 SYNOPSIS
  
  	use Git::SVN::Editor;
  	use Git::SVN::Ra;
  
  	my $ra = Git::SVN::Ra->new($url);
  	my %opts = (
  		r => 19,
  		log => "log message",
  		ra => $ra,
  		config => SVN::Core::config_get_config($svn_config_dir),
  		tree_a => "$commit^",
  		tree_b => "$commit",
  		editor_cb => sub { print "Committed r$_[0]\n"; },
  		mergeinfo => "/branches/foo:1-10",
  		svn_path => "trunk"
  	);
  	Git::SVN::Editor->new(\%opts)->apply_diff or print "No changes\n";
  
  	my $re = Git::SVN::Editor::glob2pat("trunk/*");
  	if ($branchname =~ /$re/) {
  		print "matched!\n";
  	}
  
  =head1 DESCRIPTION
  
  This module is an implementation detail of the "git svn" command.
  Do not use it unless you are developing git-svn.
  
  This module adapts the C<SVN::Delta::Editor> object returned by
  C<SVN::Delta::get_commit_editor> and drives it to convey the
  difference between two git tree objects to a remote Subversion
  repository.
  
  The interface will change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  Subversion perl bindings,
  the core L<Carp> module,
  and git's L<Git> helper module.
  
  C<Git::SVN::Editor> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Delta>,
  L<Git::SVN::Fetcher>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_EDITOR

$fatpacked{"Git/SVN/Fetcher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_FETCHER';
  package Git::SVN::Fetcher;
  use vars qw/@ISA $_ignore_regex $_include_regex $_preserve_empty_dirs
              $_placeholder_filename @deleted_gpath %added_placeholder
              $repo_id/;
  use strict;
  use warnings;
  use SVN::Delta;
  use Carp qw/croak/;
  use File::Basename qw/dirname/;
  use Git qw/command command_oneline command_noisy command_output_pipe
             command_input_pipe command_close_pipe
             command_bidi_pipe command_close_bidi_pipe
             get_record/;
  BEGIN {
  	@ISA = qw(SVN::Delta::Editor);
  }
  
  # file baton members: path, mode_a, mode_b, pool, fh, blob, base
  sub new {
  	my ($class, $git_svn, $switch_path) = @_;
  	my $self = SVN::Delta::Editor->new;
  	bless $self, $class;
  	if (exists $git_svn->{last_commit}) {
  		$self->{c} = $git_svn->{last_commit};
  		$self->{empty_symlinks} =
  		                  _mark_empty_symlinks($git_svn, $switch_path);
  	}
  
  	# some options are read globally, but can be overridden locally
  	# per [svn-remote "..."] section.  Command-line options will *NOT*
  	# override options set in an [svn-remote "..."] section
  	$repo_id = $git_svn->{repo_id};
  	my $k = "svn-remote.$repo_id.ignore-paths";
  	my $v = eval { command_oneline('config', '--get', $k) };
  	$self->{ignore_regex} = $v;
  
  	$k = "svn-remote.$repo_id.include-paths";
  	$v = eval { command_oneline('config', '--get', $k) };
  	$self->{include_regex} = $v;
  
  	$k = "svn-remote.$repo_id.preserve-empty-dirs";
  	$v = eval { command_oneline('config', '--get', '--bool', $k) };
  	if ($v && $v eq 'true') {
  		$_preserve_empty_dirs = 1;
  		$k = "svn-remote.$repo_id.placeholder-filename";
  		$v = eval { command_oneline('config', '--get', $k) };
  		$_placeholder_filename = $v;
  	}
  
  	# Load the list of placeholder files added during previous invocations.
  	$k = "svn-remote.$repo_id.added-placeholder";
  	$v = eval { command_oneline('config', '--get-all', $k) };
  	if ($_preserve_empty_dirs && $v) {
  		# command() prints errors to stderr, so we only call it if
  		# command_oneline() succeeded.
  		my @v = command('config', '--get-all', $k);
  		$added_placeholder{ dirname($_) } = $_ foreach @v;
  	}
  
  	$self->{empty} = {};
  	$self->{dir_prop} = {};
  	$self->{file_prop} = {};
  	$self->{absent_dir} = {};
  	$self->{absent_file} = {};
  	require Git::IndexInfo;
  	$self->{gii} = $git_svn->tmp_index_do(sub { Git::IndexInfo->new });
  	$self->{pathnameencoding} = Git::config('svn.pathnameencoding');
  	$self;
  }
  
  # this uses the Ra object, so it must be called before do_{switch,update},
  # not inside them (when the Git::SVN::Fetcher object is passed) to
  # do_{switch,update}
  sub _mark_empty_symlinks {
  	my ($git_svn, $switch_path) = @_;
  	my $bool = Git::config_bool('svn.brokenSymlinkWorkaround');
  	return {} if (!defined($bool)) || (defined($bool) && ! $bool);
  
  	my %ret;
  	my ($rev, $cmt) = $git_svn->last_rev_commit;
  	return {} unless ($rev && $cmt);
  
  	# allow the warning to be printed for each revision we fetch to
  	# ensure the user sees it.  The user can also disable the workaround
  	# on the repository even while git svn is running and the next
  	# revision fetched will skip this expensive function.
  	my $printed_warning;
  	chomp(my $empty_blob = `git hash-object -t blob --stdin < /dev/null`);
  	my ($ls, $ctx) = command_output_pipe(qw/ls-tree -r -z/, $cmt);
  	my $pfx = defined($switch_path) ? $switch_path : $git_svn->path;
  	$pfx .= '/' if length($pfx);
  	while (defined($_ = get_record($ls, "\0"))) {
  		s/\A100644 blob $empty_blob\t//o or next;
  		unless ($printed_warning) {
  			print STDERR "Scanning for empty symlinks, ",
  			             "this may take a while if you have ",
  				     "many empty files\n",
  				     "You may disable this with `",
  				     "git config svn.brokenSymlinkWorkaround ",
  				     "false'.\n",
  				     "This may be done in a different ",
  				     "terminal without restarting ",
  				     "git svn\n";
  			$printed_warning = 1;
  		}
  		my $path = $_;
  		my (undef, $props) =
  		               $git_svn->ra->get_file($pfx.$path, $rev, undef);
  		if ($props->{'svn:special'}) {
  			$ret{$path} = 1;
  		}
  	}
  	command_close_pipe($ls, $ctx);
  	\%ret;
  }
  
  # returns true if a given path is inside a ".git" directory
  sub in_dot_git {
  	$_[0] =~ m{(?:^|/)\.git(?:/|$)};
  }
  
  # return value: 0 -- don't ignore, 1 -- ignore
  # This will also check whether the path is explicitly included
  sub is_path_ignored {
  	my ($self, $path) = @_;
  	return 1 if in_dot_git($path);
  	return 1 if defined($self->{ignore_regex}) &&
  	            $path =~ m!$self->{ignore_regex}!;
  	return 0 if defined($self->{include_regex}) &&
  	            $path =~ m!$self->{include_regex}!;
  	return 0 if defined($_include_regex) &&
  	            $path =~ m!$_include_regex!;
  	return 1 if defined($self->{include_regex});
  	return 1 if defined($_include_regex);
  	return 0 unless defined($_ignore_regex);
  	return 1 if $path =~ m!$_ignore_regex!o;
  	return 0;
  }
  
  sub set_path_strip {
  	my ($self, $path) = @_;
  	$self->{path_strip} = qr/^\Q$path\E(\/|$)/ if length $path;
  }
  
  sub open_root {
  	{ path => '' };
  }
  
  sub open_directory {
  	my ($self, $path, $pb, $rev) = @_;
  	{ path => $path };
  }
  
  sub git_path {
  	my ($self, $path) = @_;
  	if (my $enc = $self->{pathnameencoding}) {
  		require Encode;
  		Encode::from_to($path, 'UTF-8', $enc);
  	}
  	if ($self->{path_strip}) {
  		$path =~ s!$self->{path_strip}!! or
  		  die "Failed to strip path '$path' ($self->{path_strip})\n";
  	}
  	$path;
  }
  
  sub delete_entry {
  	my ($self, $path, $rev, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  
  	my $gpath = $self->git_path($path);
  	return undef if ($gpath eq '');
  
  	# remove entire directories.
  	my ($tree) = (command('ls-tree', '-z', $self->{c}, "./$gpath")
  	                 =~ /\A040000 tree ([a-f\d]{40})\t\Q$gpath\E\0/);
  	if ($tree) {
  		my ($ls, $ctx) = command_output_pipe(qw/ls-tree
  		                                     -r --name-only -z/,
  				                     $tree);
  		while (defined($_ = get_record($ls, "\0"))) {
  			my $rmpath = "$gpath/$_";
  			$self->{gii}->remove($rmpath);
  			print "\tD\t$rmpath\n" unless $::_q;
  		}
  		print "\tD\t$gpath/\n" unless $::_q;
  		command_close_pipe($ls, $ctx);
  	} else {
  		$self->{gii}->remove($gpath);
  		print "\tD\t$gpath\n" unless $::_q;
  	}
  	# Don't add to @deleted_gpath if we're deleting a placeholder file.
  	push @deleted_gpath, $gpath unless $added_placeholder{dirname($path)};
  	$self->{empty}->{$path} = 0;
  	undef;
  }
  
  sub open_file {
  	my ($self, $path, $pb, $rev) = @_;
  	my ($mode, $blob);
  
  	goto out if $self->is_path_ignored($path);
  
  	my $gpath = $self->git_path($path);
  	($mode, $blob) = (command('ls-tree', '-z', $self->{c}, "./$gpath")
  	                     =~ /\A(\d{6}) blob ([a-f\d]{40})\t\Q$gpath\E\0/);
  	unless (defined $mode && defined $blob) {
  		die "$path was not found in commit $self->{c} (r$rev)\n";
  	}
  	if ($mode eq '100644' && $self->{empty_symlinks}->{$path}) {
  		$mode = '120000';
  	}
  out:
  	{ path => $path, mode_a => $mode, mode_b => $mode, blob => $blob,
  	  pool => SVN::Pool->new, action => 'M' };
  }
  
  sub add_file {
  	my ($self, $path, $pb, $cp_path, $cp_rev) = @_;
  	my $mode;
  
  	if (!$self->is_path_ignored($path)) {
  		my ($dir, $file) = ($path =~ m#^(.*?)/?([^/]+)$#);
  		delete $self->{empty}->{$dir};
  		$mode = '100644';
  
  		if ($added_placeholder{$dir}) {
  			# Remove our placeholder file, if we created one.
  			delete_entry($self, $added_placeholder{$dir})
  				unless $path eq $added_placeholder{$dir};
  			delete $added_placeholder{$dir}
  		}
  	}
  
  	{ path => $path, mode_a => $mode, mode_b => $mode,
  	  pool => SVN::Pool->new, action => 'A' };
  }
  
  sub add_directory {
  	my ($self, $path, $cp_path, $cp_rev) = @_;
  	goto out if $self->is_path_ignored($path);
  	my $gpath = $self->git_path($path);
  	if ($gpath eq '') {
  		my ($ls, $ctx) = command_output_pipe(qw/ls-tree
  		                                     -r --name-only -z/,
  				                     $self->{c});
  		while (defined($_ = get_record($ls, "\0"))) {
  			$self->{gii}->remove($_);
  			print "\tD\t$_\n" unless $::_q;
  			push @deleted_gpath, $gpath;
  		}
  		command_close_pipe($ls, $ctx);
  		$self->{empty}->{$path} = 0;
  	}
  	my ($dir, $file) = ($path =~ m#^(.*?)/?([^/]+)$#);
  	delete $self->{empty}->{$dir};
  	$self->{empty}->{$path} = 1;
  
  	if ($added_placeholder{$dir}) {
  		# Remove our placeholder file, if we created one.
  		delete_entry($self, $added_placeholder{$dir});
  		delete $added_placeholder{$dir}
  	}
  
  out:
  	{ path => $path };
  }
  
  sub change_dir_prop {
  	my ($self, $db, $prop, $value) = @_;
  	return undef if $self->is_path_ignored($db->{path});
  	$self->{dir_prop}->{$db->{path}} ||= {};
  	$self->{dir_prop}->{$db->{path}}->{$prop} = $value;
  	undef;
  }
  
  sub absent_directory {
  	my ($self, $path, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  	$self->{absent_dir}->{$pb->{path}} ||= [];
  	push @{$self->{absent_dir}->{$pb->{path}}}, $path;
  	undef;
  }
  
  sub absent_file {
  	my ($self, $path, $pb) = @_;
  	return undef if $self->is_path_ignored($path);
  	$self->{absent_file}->{$pb->{path}} ||= [];
  	push @{$self->{absent_file}->{$pb->{path}}}, $path;
  	undef;
  }
  
  sub change_file_prop {
  	my ($self, $fb, $prop, $value) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  	if ($prop eq 'svn:executable') {
  		if ($fb->{mode_b} != 120000) {
  			$fb->{mode_b} = defined $value ? 100755 : 100644;
  		}
  	} elsif ($prop eq 'svn:special') {
  		$fb->{mode_b} = defined $value ? 120000 : 100644;
  	} else {
  		$self->{file_prop}->{$fb->{path}} ||= {};
  		$self->{file_prop}->{$fb->{path}}->{$prop} = $value;
  	}
  	undef;
  }
  
  sub apply_textdelta {
  	my ($self, $fb, $exp) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  	my $suffix = 0;
  	++$suffix while $::_repository->temp_is_locked("svn_delta_${$}_$suffix");
  	my $fh = $::_repository->temp_acquire("svn_delta_${$}_$suffix");
  	# $fh gets auto-closed() by SVN::TxDelta::apply(),
  	# (but $base does not,) so dup() it for reading in close_file
  	open my $dup, '<&', $fh or croak $!;
  	my $base = $::_repository->temp_acquire("git_blob_${$}_$suffix");
  	# close_file may call temp_acquire on 'svn_hash', but because of the
  	# call chain, if the temp_acquire call from close_file ends up being the
  	# call that first creates the 'svn_hash' temp file, then the FileHandle
  	# that's created as a result will end up in an SVN::Pool that we clear
  	# in SVN::Ra::gs_fetch_loop_common.  Avoid that by making sure the
  	# 'svn_hash' FileHandle is already created before close_file is called.
  	my $tmp_fh = $::_repository->temp_acquire('svn_hash');
  	$::_repository->temp_release($tmp_fh, 1);
  
  	if ($fb->{blob}) {
  		my ($base_is_link, $size);
  
  		if ($fb->{mode_a} eq '120000' &&
  		    ! $self->{empty_symlinks}->{$fb->{path}}) {
  			print $base 'link ' or die "print $!\n";
  			$base_is_link = 1;
  		}
  	retry:
  		$size = $::_repository->cat_blob($fb->{blob}, $base);
  		die "Failed to read object $fb->{blob}" if ($size < 0);
  
  		if (defined $exp) {
  			seek $base, 0, 0 or croak $!;
  			my $got = ::md5sum($base);
  			if ($got ne $exp) {
  				my $err = "Checksum mismatch: ".
  				       "$fb->{path} $fb->{blob}\n" .
  				       "expected: $exp\n" .
  				       "     got: $got\n";
  				if ($base_is_link) {
  					warn $err,
  					     "Retrying... (possibly ",
  					     "a bad symlink from SVN)\n";
  					$::_repository->temp_reset($base);
  					$base_is_link = 0;
  					goto retry;
  				}
  				die $err;
  			}
  		}
  	}
  	seek $base, 0, 0 or croak $!;
  	$fb->{fh} = $fh;
  	$fb->{base} = $base;
  	[ SVN::TxDelta::apply($base, $dup, undef, $fb->{path}, $fb->{pool}) ];
  }
  
  sub close_file {
  	my ($self, $fb, $exp) = @_;
  	return undef if $self->is_path_ignored($fb->{path});
  
  	my $hash;
  	my $path = $self->git_path($fb->{path});
  	if (my $fh = $fb->{fh}) {
  		if (defined $exp) {
  			seek($fh, 0, 0) or croak $!;
  			my $got = ::md5sum($fh);
  			if ($got ne $exp) {
  				die "Checksum mismatch: $path\n",
  				    "expected: $exp\n    got: $got\n";
  			}
  		}
  		if ($fb->{mode_b} == 120000) {
  			sysseek($fh, 0, 0) or croak $!;
  			my $rd = sysread($fh, my $buf, 5);
  
  			if (!defined $rd) {
  				croak "sysread: $!\n";
  			} elsif ($rd == 0) {
  				warn "$path has mode 120000",
  				     " but it points to nothing\n",
  				     "converting to an empty file with mode",
  				     " 100644\n";
  				$fb->{mode_b} = '100644';
  			} elsif ($buf ne 'link ') {
  				warn "$path has mode 120000",
  				     " but is not a link\n";
  			} else {
  				my $tmp_fh = $::_repository->temp_acquire(
  					'svn_hash');
  				my $res;
  				while ($res = sysread($fh, my $str, 1024)) {
  					my $out = syswrite($tmp_fh, $str, $res);
  					defined($out) && $out == $res
  						or croak("write ",
  							Git::temp_path($tmp_fh),
  							": $!\n");
  				}
  				defined $res or croak $!;
  
  				($fh, $tmp_fh) = ($tmp_fh, $fh);
  				Git::temp_release($tmp_fh, 1);
  			}
  		}
  
  		$hash = $::_repository->hash_and_insert_object(
  				Git::temp_path($fh));
  		$hash =~ /^[a-f\d]{40}$/ or die "not a sha1: $hash\n";
  
  		Git::temp_release($fb->{base}, 1);
  		Git::temp_release($fh, 1);
  	} else {
  		$hash = $fb->{blob} or die "no blob information\n";
  	}
  	$fb->{pool}->clear;
  	$self->{gii}->update($fb->{mode_b}, $hash, $path) or croak $!;
  	print "\t$fb->{action}\t$path\n" if $fb->{action} && ! $::_q;
  	undef;
  }
  
  sub abort_edit {
  	my $self = shift;
  	$self->{nr} = $self->{gii}->{nr};
  	delete $self->{gii};
  	$self->SUPER::abort_edit(@_);
  }
  
  sub close_edit {
  	my $self = shift;
  
  	if ($_preserve_empty_dirs) {
  		my @empty_dirs;
  
  		# Any entry flagged as empty that also has an associated
  		# dir_prop represents a newly created empty directory.
  		foreach my $i (keys %{$self->{empty}}) {
  			push @empty_dirs, $i if exists $self->{dir_prop}->{$i};
  		}
  
  		# Search for directories that have become empty due subsequent
  		# file deletes.
  		push @empty_dirs, $self->find_empty_directories();
  
  		# Finally, add a placeholder file to each empty directory.
  		$self->add_placeholder_file($_) foreach (@empty_dirs);
  
  		$self->stash_placeholder_list();
  	}
  
  	$self->{git_commit_ok} = 1;
  	$self->{nr} = $self->{gii}->{nr};
  	delete $self->{gii};
  	$self->SUPER::close_edit(@_);
  }
  
  sub find_empty_directories {
  	my ($self) = @_;
  	my @empty_dirs;
  	my %dirs = map { dirname($_) => 1 } @deleted_gpath;
  
  	foreach my $dir (sort keys %dirs) {
  		next if $dir eq ".";
  
  		# If there have been any additions to this directory, there is
  		# no reason to check if it is empty.
  		my $skip_added = 0;
  		foreach my $t (qw/dir_prop file_prop/) {
  			foreach my $path (keys %{ $self->{$t} }) {
  				if (exists $self->{$t}->{dirname($path)}) {
  					$skip_added = 1;
  					last;
  				}
  			}
  			last if $skip_added;
  		}
  		next if $skip_added;
  
  		# Use `git ls-tree` to get the filenames of this directory
  		# that existed prior to this particular commit.
  		my $ls = command('ls-tree', '-z', '--name-only',
  				 $self->{c}, "$dir/");
  		my %files = map { $_ => 1 } split(/\0/, $ls);
  
  		# Remove the filenames that were deleted during this commit.
  		delete $files{$_} foreach (@deleted_gpath);
  
  		# Report the directory if there are no filenames left.
  		push @empty_dirs, $dir unless (scalar %files);
  	}
  	@empty_dirs;
  }
  
  sub add_placeholder_file {
  	my ($self, $dir) = @_;
  	my $path = "$dir/$_placeholder_filename";
  	my $gpath = $self->git_path($path);
  
  	my $fh = $::_repository->temp_acquire($gpath);
  	my $hash = $::_repository->hash_and_insert_object(Git::temp_path($fh));
  	Git::temp_release($fh, 1);
  	$self->{gii}->update('100644', $hash, $gpath) or croak $!;
  
  	# The directory should no longer be considered empty.
  	delete $self->{empty}->{$dir} if exists $self->{empty}->{$dir};
  
  	# Keep track of any placeholder files we create.
  	$added_placeholder{$dir} = $path;
  }
  
  sub stash_placeholder_list {
  	my ($self) = @_;
  	my $k = "svn-remote.$repo_id.added-placeholder";
  	my $v = eval { command_oneline('config', '--get-all', $k) };
  	command_noisy('config', '--unset-all', $k) if $v;
  	foreach (values %added_placeholder) {
  		command_noisy('config', '--add', $k, $_);
  	}
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Fetcher - tree delta consumer for "git svn fetch"
  
  =head1 SYNOPSIS
  
      use SVN::Core;
      use SVN::Ra;
      use Git::SVN;
      use Git::SVN::Fetcher;
      use Git;
  
      my $gs = Git::SVN->find_by_url($url);
      my $ra = SVN::Ra->new(url => $url);
      my $editor = Git::SVN::Fetcher->new($gs);
      my $reporter = $ra->do_update($SVN::Core::INVALID_REVNUM, '',
                                    1, $editor);
      $reporter->set_path('', $old_rev, 0);
      $reporter->finish_report;
      my $tree = $gs->tmp_index_do(sub { command_oneline('write-tree') });
  
      foreach my $path (keys %{$editor->{dir_prop}) {
          my $props = $editor->{dir_prop}{$path};
          foreach my $prop (keys %$props) {
              print "property $prop at $path changed to $props->{$prop}\n";
          }
      }
      foreach my $path (keys %{$editor->{empty}) {
          my $action = $editor->{empty}{$path} ? 'added' : 'removed';
          print "empty directory $path $action\n";
      }
      foreach my $path (keys %{$editor->{file_prop}) { ... }
      foreach my $parent (keys %{$editor->{absent_dir}}) {
          my @children = @{$editor->{abstent_dir}{$parent}};
          print "cannot fetch directory $parent/$_: not authorized?\n"
              foreach @children;
      }
      foreach my $parent (keys %{$editor->{absent_file}) { ... }
  
  =head1 DESCRIPTION
  
  This is a subclass of C<SVN::Delta::Editor>, which means it implements
  callbacks to act as a consumer of Subversion tree deltas.  This
  particular implementation of those callbacks is meant to store
  information about the resulting content which B<git svn fetch> could
  use to populate new commits and new entries for F<unhandled.log>.
  More specifically:
  
  =over
  
  =item * Additions, removals, and modifications of files are propagated
  to git-svn's index file F<$GIT_DIR/svn/$refname/index> using
  B<git update-index>.
  
  =item * Changes in Subversion path properties are recorded in the
  C<dir_prop> and C<file_prop> fields (which are hashes).
  
  =item * Addition and removal of empty directories are indicated by
  entries with value 1 and 0 respectively in the C<empty> hash.
  
  =item * Paths that are present but cannot be conveyed (presumably due
  to permissions) are recorded in the C<absent_file> and
  C<absent_dirs> hashes.  For each key, the corresponding value is
  a list of paths under that directory that were present but
  could not be conveyed.
  
  =back
  
  The interface is unstable.  Do not use this module unless you are
  developing git-svn.
  
  =head1 DEPENDENCIES
  
  L<SVN::Delta> from the Subversion perl bindings,
  the core L<Carp> and L<File::Basename> modules,
  and git's L<Git> helper module.
  
  C<Git::SVN::Fetcher> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Delta>,
  L<Git::SVN::Editor>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_FETCHER

$fatpacked{"Git/SVN/GlobSpec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_GLOBSPEC';
  package Git::SVN::GlobSpec;
  use strict;
  use warnings;
  
  sub new {
  	my ($class, $glob, $pattern_ok) = @_;
  	my $re = $glob;
  	$re =~ s!/+$!!g; # no need for trailing slashes
  	my (@left, @right, @patterns);
  	my $state = "left";
  	my $die_msg = "Only one set of wildcards " .
  				"(e.g. '*' or '*/*/*') is supported: $glob\n";
  	for my $part (split(m|/|, $glob)) {
  		if ($pattern_ok && $part =~ /[{}]/ &&
  			 $part !~ /^\{[^{}]+\}/) {
  			die "Invalid pattern in '$glob': $part\n";
  		}
  		my $nstars = $part =~ tr/*//;
  		if ($nstars > 1) {
  			die "Only one '*' is allowed in a pattern: '$part'\n";
  		}
  		if ($part =~ /(.*)\*(.*)/) {
  			die $die_msg if $state eq "right";
  			my ($l, $r) = ($1, $2);
  			$state = "pattern";
  			my $pat = quotemeta($l) . '[^/]*' . quotemeta($r);
  			push(@patterns, $pat);
  		} elsif ($pattern_ok && $part =~ /^\{(.*)\}$/) {
  			die $die_msg if $state eq "right";
  			$state = "pattern";
  			my $p = quotemeta($1);
  			$p =~ s/\\,/|/g;
  			push(@patterns, "(?:$p)");
  		} else {
  			if ($state eq "left") {
  				push(@left, $part);
  			} else {
  				push(@right, $part);
  				$state = "right";
  			}
  		}
  	}
  	my $depth = @patterns;
  	if ($depth == 0) {
  		die "One '*' is needed in glob: '$glob'\n";
  	}
  	my $left = join('/', @left);
  	my $right = join('/', @right);
  	$re = join('/', @patterns);
  	$re = join('\/',
  		   grep(length, quotemeta($left),
                                  "($re)(?=/|\$)",
                                  quotemeta($right)));
  	my $left_re = qr/^\/\Q$left\E(\/|$)/;
  	bless { left => $left, right => $right, left_regex => $left_re,
  	        regex => qr/$re/, glob => $glob, depth => $depth }, $class;
  }
  
  sub full_path {
  	my ($self, $path) = @_;
  	return (length $self->{left} ? "$self->{left}/" : '') .
  	       $path . (length $self->{right} ? "/$self->{right}" : '');
  }
  
  1;
GIT_SVN_GLOBSPEC

$fatpacked{"Git/SVN/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_LOG';
  package Git::SVN::Log;
  use strict;
  use warnings;
  use Git::SVN::Utils qw(fatal);
  use Git qw(command
             command_oneline
             command_output_pipe
             command_close_pipe
             get_tz_offset);
  use POSIX qw/strftime/;
  use constant commit_log_separator => ('-' x 72) . "\n";
  use vars qw/$TZ $limit $color $pager $non_recursive $verbose $oneline
              %rusers $show_commit $incremental/;
  
  # Option set in git-svn
  our $_git_format;
  
  sub cmt_showable {
  	my ($c) = @_;
  	return 1 if defined $c->{r};
  
  	# big commit message got truncated by the 16k pretty buffer in rev-list
  	if ($c->{l} && $c->{l}->[-1] eq "...\n" &&
  				$c->{a_raw} =~ /\@([a-f\d\-]+)>$/) {
  		@{$c->{l}} = ();
  		my @log = command(qw/cat-file commit/, $c->{c});
  
  		# shift off the headers
  		shift @log while ($log[0] ne '');
  		shift @log;
  
  		# TODO: make $c->{l} not have a trailing newline in the future
  		@{$c->{l}} = map { "$_\n" } grep !/^git-svn-id: /, @log;
  
  		(undef, $c->{r}, undef) = ::extract_metadata(
  				(grep(/^git-svn-id: /, @log))[-1]);
  	}
  	return defined $c->{r};
  }
  
  sub log_use_color {
  	return $color || Git->repository->get_colorbool('color.diff');
  }
  
  sub git_svn_log_cmd {
  	my ($r_min, $r_max, @args) = @_;
  	my $head = 'HEAD';
  	my (@files, @log_opts);
  	foreach my $x (@args) {
  		if ($x eq '--' || @files) {
  			push @files, $x;
  		} else {
  			if (::verify_ref("$x^0")) {
  				$head = $x;
  			} else {
  				push @log_opts, $x;
  			}
  		}
  	}
  
  	my ($url, $rev, $uuid, $gs) = ::working_head_info($head);
  
  	require Git::SVN;
  	$gs ||= Git::SVN->_new;
  	my @cmd = (qw/log --abbrev-commit --pretty=raw --default/,
  	           $gs->refname);
  	push @cmd, '-r' unless $non_recursive;
  	push @cmd, qw/--raw --name-status/ if $verbose;
  	push @cmd, '--color' if log_use_color();
  	push @cmd, @log_opts;
  	if (defined $r_max && $r_max == $r_min) {
  		push @cmd, '--max-count=1';
  		if (my $c = $gs->rev_map_get($r_max)) {
  			push @cmd, $c;
  		}
  	} elsif (defined $r_max) {
  		if ($r_max < $r_min) {
  			($r_min, $r_max) = ($r_max, $r_min);
  		}
  		my (undef, $c_max) = $gs->find_rev_before($r_max, 1, $r_min);
  		my (undef, $c_min) = $gs->find_rev_after($r_min, 1, $r_max);
  		# If there are no commits in the range, both $c_max and $c_min
  		# will be undefined.  If there is at least 1 commit in the
  		# range, both will be defined.
  		return () if !defined $c_min || !defined $c_max;
  		if ($c_min eq $c_max) {
  			push @cmd, '--max-count=1', $c_min;
  		} else {
  			push @cmd, '--boundary', "$c_min..$c_max";
  		}
  	}
  	return (@cmd, @files);
  }
  
  # adapted from pager.c
  sub config_pager {
  	if (! -t *STDOUT) {
  		$ENV{GIT_PAGER_IN_USE} = 'false';
  		$pager = undef;
  		return;
  	}
  	chomp($pager = command_oneline(qw(var GIT_PAGER)));
  	if ($pager eq 'cat') {
  		$pager = undef;
  	}
  	$ENV{GIT_PAGER_IN_USE} = defined($pager);
  }
  
  sub run_pager {
  	return unless defined $pager;
  	pipe my ($rfd, $wfd) or return;
  	defined(my $pid = fork) or fatal "Can't fork: $!";
  	if (!$pid) {
  		open STDOUT, '>&', $wfd or
  		                     fatal "Can't redirect to stdout: $!";
  		return;
  	}
  	open STDIN, '<&', $rfd or fatal "Can't redirect stdin: $!";
  	$ENV{LESS} ||= 'FRX';
  	$ENV{LV} ||= '-c';
  	exec $pager or fatal "Can't run pager: $! ($pager)";
  }
  
  sub format_svn_date {
  	my $t = shift || time;
  	require Git::SVN;
  	my $gmoff = get_tz_offset($t);
  	return strftime("%Y-%m-%d %H:%M:%S $gmoff (%a, %d %b %Y)", localtime($t));
  }
  
  sub parse_git_date {
  	my ($t, $tz) = @_;
  	# Date::Parse isn't in the standard Perl distro :(
  	if ($tz =~ s/^\+//) {
  		$t += tz_to_s_offset($tz);
  	} elsif ($tz =~ s/^\-//) {
  		$t -= tz_to_s_offset($tz);
  	}
  	return $t;
  }
  
  sub set_local_timezone {
  	if (defined $TZ) {
  		$ENV{TZ} = $TZ;
  	} else {
  		delete $ENV{TZ};
  	}
  }
  
  sub tz_to_s_offset {
  	my ($tz) = @_;
  	$tz =~ s/(\d\d)$//;
  	return ($1 * 60) + ($tz * 3600);
  }
  
  sub get_author_info {
  	my ($dest, $author, $t, $tz) = @_;
  	$author =~ s/(?:^\s*|\s*$)//g;
  	$dest->{a_raw} = $author;
  	my $au;
  	if ($::_authors) {
  		$au = $rusers{$author} || undef;
  	}
  	if (!$au) {
  		($au) = ($author =~ /<([^>]+)\@[^>]+>$/);
  	}
  	$dest->{t} = $t;
  	$dest->{tz} = $tz;
  	$dest->{a} = $au;
  	$dest->{t_utc} = parse_git_date($t, $tz);
  }
  
  sub process_commit {
  	my ($c, $r_min, $r_max, $defer) = @_;
  	if (defined $r_min && defined $r_max) {
  		if ($r_min == $c->{r} && $r_min == $r_max) {
  			show_commit($c);
  			return 0;
  		}
  		return 1 if $r_min == $r_max;
  		if ($r_min < $r_max) {
  			# we need to reverse the print order
  			return 0 if (defined $limit && --$limit < 0);
  			push @$defer, $c;
  			return 1;
  		}
  		if ($r_min != $r_max) {
  			return 1 if ($r_min < $c->{r});
  			return 1 if ($r_max > $c->{r});
  		}
  	}
  	return 0 if (defined $limit && --$limit < 0);
  	show_commit($c);
  	return 1;
  }
  
  my $l_fmt;
  sub show_commit {
  	my $c = shift;
  	if ($oneline) {
  		my $x = "\n";
  		if (my $l = $c->{l}) {
  			while ($l->[0] =~ /^\s*$/) { shift @$l }
  			$x = $l->[0];
  		}
  		$l_fmt ||= 'A' . length($c->{r});
  		print 'r',pack($l_fmt, $c->{r}),' | ';
  		print "$c->{c} | " if $show_commit;
  		print $x;
  	} else {
  		show_commit_normal($c);
  	}
  }
  
  sub show_commit_changed_paths {
  	my ($c) = @_;
  	return unless $c->{changed};
  	print "Changed paths:\n", @{$c->{changed}};
  }
  
  sub show_commit_normal {
  	my ($c) = @_;
  	print commit_log_separator, "r$c->{r} | ";
  	print "$c->{c} | " if $show_commit;
  	print "$c->{a} | ", format_svn_date($c->{t_utc}), ' | ';
  	my $nr_line = 0;
  
  	if (my $l = $c->{l}) {
  		while ($l->[$#$l] eq "\n" && $#$l > 0
  		                          && $l->[($#$l - 1)] eq "\n") {
  			pop @$l;
  		}
  		$nr_line = scalar @$l;
  		if (!$nr_line) {
  			print "1 line\n\n\n";
  		} else {
  			if ($nr_line == 1) {
  				$nr_line = '1 line';
  			} else {
  				$nr_line .= ' lines';
  			}
  			print $nr_line, "\n";
  			show_commit_changed_paths($c);
  			print "\n";
  			print $_ foreach @$l;
  		}
  	} else {
  		print "1 line\n";
  		show_commit_changed_paths($c);
  		print "\n";
  
  	}
  	foreach my $x (qw/raw stat diff/) {
  		if ($c->{$x}) {
  			print "\n";
  			print $_ foreach @{$c->{$x}}
  		}
  	}
  }
  
  sub cmd_show_log {
  	my (@args) = @_;
  	my ($r_min, $r_max);
  	my $r_last = -1; # prevent dupes
  	set_local_timezone();
  	if (defined $::_revision) {
  		if ($::_revision =~ /^(\d+):(\d+)$/) {
  			($r_min, $r_max) = ($1, $2);
  		} elsif ($::_revision =~ /^\d+$/) {
  			$r_min = $r_max = $::_revision;
  		} else {
  			fatal "-r$::_revision is not supported, use ",
  				"standard 'git log' arguments instead";
  		}
  	}
  
  	config_pager();
  	@args = git_svn_log_cmd($r_min, $r_max, @args);
  	if (!@args) {
  		print commit_log_separator unless $incremental || $oneline;
  		return;
  	}
  	my $log = command_output_pipe(@args);
  	run_pager();
  	my (@k, $c, $d, $stat);
  	my $esc_color = qr/(?:\033\[(?:(?:\d+;)*\d*)?m)*/;
  	while (<$log>) {
  		if (/^${esc_color}commit (?:- )?($::sha1_short)/o) {
  			my $cmt = $1;
  			if ($c && cmt_showable($c) && $c->{r} != $r_last) {
  				$r_last = $c->{r};
  				process_commit($c, $r_min, $r_max, \@k) or
  								goto out;
  			}
  			$d = undef;
  			$c = { c => $cmt };
  		} elsif (/^${esc_color}author (.+) (\d+) ([\-\+]?\d+)$/o) {
  			get_author_info($c, $1, $2, $3);
  		} elsif (/^${esc_color}(?:tree|parent|committer) /o) {
  			# ignore
  		} elsif (/^${esc_color}:\d{6} \d{6} $::sha1_short/o) {
  			push @{$c->{raw}}, $_;
  		} elsif (/^${esc_color}[ACRMDT]\t/) {
  			# we could add $SVN->{svn_path} here, but that requires
  			# remote access at the moment (repo_path_split)...
  			s#^(${esc_color})([ACRMDT])\t#$1   $2 #o;
  			push @{$c->{changed}}, $_;
  		} elsif (/^${esc_color}diff /o) {
  			$d = 1;
  			push @{$c->{diff}}, $_;
  		} elsif ($d) {
  			push @{$c->{diff}}, $_;
  		} elsif (/^\ .+\ \|\s*\d+\ $esc_color[\+\-]*
  		          $esc_color*[\+\-]*$esc_color$/x) {
  			$stat = 1;
  			push @{$c->{stat}}, $_;
  		} elsif ($stat && /^ \d+ files changed, \d+ insertions/) {
  			push @{$c->{stat}}, $_;
  			$stat = undef;
  		} elsif (/^${esc_color}    (git-svn-id:.+)$/o) {
  			($c->{url}, $c->{r}, undef) = ::extract_metadata($1);
  		} elsif (s/^${esc_color}    //o) {
  			push @{$c->{l}}, $_;
  		}
  	}
  	if ($c && defined $c->{r} && $c->{r} != $r_last) {
  		$r_last = $c->{r};
  		process_commit($c, $r_min, $r_max, \@k);
  	}
  	if (@k) {
  		($r_min, $r_max) = ($r_max, $r_min);
  		process_commit($_, $r_min, $r_max) foreach reverse @k;
  	}
  out:
  	close $log;
  	print commit_log_separator unless $incremental || $oneline;
  }
  
  sub cmd_blame {
  	my $path = pop;
  
  	config_pager();
  	run_pager();
  
  	my ($fh, $ctx, $rev);
  
  	if ($_git_format) {
  		($fh, $ctx) = command_output_pipe('blame', @_, $path);
  		while (my $line = <$fh>) {
  			if ($line =~ /^\^?([[:xdigit:]]+)\s/) {
  				# Uncommitted edits show up as a rev ID of
  				# all zeros, which we can't look up with
  				# cmt_metadata
  				if ($1 !~ /^0+$/) {
  					(undef, $rev, undef) =
  						::cmt_metadata($1);
  					$rev = '0' if (!$rev);
  				} else {
  					$rev = '0';
  				}
  				$rev = sprintf('%-10s', $rev);
  				$line =~ s/^\^?[[:xdigit:]]+(\s)/$rev$1/;
  			}
  			print $line;
  		}
  	} else {
  		($fh, $ctx) = command_output_pipe('blame', '-p', @_, 'HEAD',
  						  '--', $path);
  		my ($sha1);
  		my %authors;
  		my @buffer;
  		my %dsha; #distinct sha keys
  
  		while (my $line = <$fh>) {
  			push @buffer, $line;
  			if ($line =~ /^([[:xdigit:]]{40})\s\d+\s\d+/) {
  				$dsha{$1} = 1;
  			}
  		}
  
  		my $s2r = ::cmt_sha2rev_batch([keys %dsha]);
  
  		foreach my $line (@buffer) {
  			if ($line =~ /^([[:xdigit:]]{40})\s\d+\s\d+/) {
  				$rev = $s2r->{$1};
  				$rev = '0' if (!$rev)
  			}
  			elsif ($line =~ /^author (.*)/) {
  				$authors{$rev} = $1;
  				$authors{$rev} =~ s/\s/_/g;
  			}
  			elsif ($line =~ /^\t(.*)$/) {
  				printf("%6s %10s %s\n", $rev, $authors{$rev}, $1);
  			}
  		}
  	}
  	command_close_pipe($fh, $ctx);
  }
  
  1;
GIT_SVN_LOG

$fatpacked{"Git/SVN/Memoize/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_MEMOIZE_YAML';
  package Git::SVN::Memoize::YAML;
  use warnings;
  use strict;
  use YAML::Any ();
  
  # based on Memoize::Storable.
  
  sub TIEHASH {
  	my $package = shift;
  	my $filename = shift;
  	my $truehash = (-e $filename) ? YAML::Any::LoadFile($filename) : {};
  	my $self = {FILENAME => $filename, H => $truehash};
  	bless $self => $package;
  }
  
  sub STORE {
  	my $self = shift;
  	$self->{H}{$_[0]} = $_[1];
  }
  
  sub FETCH {
  	my $self = shift;
  	$self->{H}{$_[0]};
  }
  
  sub EXISTS {
  	my $self = shift;
  	exists $self->{H}{$_[0]};
  }
  
  sub DESTROY {
  	my $self = shift;
  	YAML::Any::DumpFile($self->{FILENAME}, $self->{H});
  }
  
  sub SCALAR {
  	my $self = shift;
  	scalar(%{$self->{H}});
  }
  
  sub FIRSTKEY {
  	'Fake hash from Git::SVN::Memoize::YAML';
  }
  
  sub NEXTKEY {
  	undef;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Memoize::YAML - store Memoized data in YAML format
  
  =head1 SYNOPSIS
  
      use Memoize;
      use Git::SVN::Memoize::YAML;
  
      tie my %cache => 'Git::SVN::Memoize::YAML', $filename;
      memoize('slow_function', SCALAR_CACHE => [HASH => \%cache]);
      slow_function(arguments);
  
  =head1 DESCRIPTION
  
  This module provides a class that can be used to tie a hash to a
  YAML file.  The file is read when the hash is initialized and
  rewritten when the hash is destroyed.
  
  The intent is to allow L<Memoize> to back its cache with a file in
  YAML format, just like L<Memoize::Storable> allows L<Memoize> to
  back its cache with a file in Storable format.  Unlike the Storable
  format, the YAML format is platform-independent and fairly stable.
  
  Carps on error.
  
  =head1 DIAGNOSTICS
  
  See L<YAML::Any>.
  
  =head1 DEPENDENCIES
  
  L<YAML::Any> from CPAN.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  The entire cache is read into a Perl hash when loading the file,
  so this is not very scalable.
GIT_SVN_MEMOIZE_YAML

$fatpacked{"Git/SVN/Migration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_MIGRATION';
  package Git::SVN::Migration;
  # these version numbers do NOT correspond to actual version numbers
  # of git or git-svn.  They are just relative.
  #
  # v0 layout: .git/$id/info/url, refs/heads/$id-HEAD
  #
  # v1 layout: .git/$id/info/url, refs/remotes/$id
  #
  # v2 layout: .git/svn/$id/info/url, refs/remotes/$id
  #
  # v3 layout: .git/svn/$id, refs/remotes/$id
  #            - info/url may remain for backwards compatibility
  #            - this is what we migrate up to this layout automatically,
  #            - this will be used by git svn init on single branches
  # v3.1 layout (auto migrated):
  #            - .rev_db => .rev_db.$UUID, .rev_db will remain as a symlink
  #              for backwards compatibility
  #
  # v4 layout: .git/svn/$repo_id/$id, refs/remotes/$repo_id/$id
  #            - this is only created for newly multi-init-ed
  #              repositories.  Similar in spirit to the
  #              --use-separate-remotes option in git-clone (now default)
  #            - we do not automatically migrate to this (following
  #              the example set by core git)
  #
  # v5 layout: .rev_db.$UUID => .rev_map.$UUID
  #            - newer, more-efficient format that uses 24-bytes per record
  #              with no filler space.
  #            - use xxd -c24 < .rev_map.$UUID to view and debug
  #            - This is a one-way migration, repositories updated to the
  #              new format will not be able to use old git-svn without
  #              rebuilding the .rev_db.  Rebuilding the rev_db is not
  #              possible if noMetadata or useSvmProps are set; but should
  #              be no problem for users that use the (sensible) defaults.
  use strict;
  use warnings;
  use Carp qw/croak/;
  use File::Path qw/mkpath/;
  use File::Basename qw/dirname basename/;
  
  our $_minimize;
  use Git qw(
  	command
  	command_noisy
  	command_output_pipe
  	command_close_pipe
  	command_oneline
  );
  use Git::SVN;
  
  sub migrate_from_v0 {
  	my $git_dir = $ENV{GIT_DIR};
  	return undef unless -d $git_dir;
  	my ($fh, $ctx) = command_output_pipe(qw/rev-parse --symbolic --all/);
  	my $migrated = 0;
  	while (<$fh>) {
  		chomp;
  		my ($id, $orig_ref) = ($_, $_);
  		next unless $id =~ s#^refs/heads/(.+)-HEAD$#$1#;
  		my $info_url = command_oneline(qw(rev-parse --git-path),
  						"$id/info/url");
  		next unless -f $info_url;
  		my $new_ref = "refs/remotes/$id";
  		if (::verify_ref("$new_ref^0")) {
  			print STDERR "W: $orig_ref is probably an old ",
  			             "branch used by an ancient version of ",
  				     "git-svn.\n",
  				     "However, $new_ref also exists.\n",
  				     "We will not be able ",
  				     "to use this branch until this ",
  				     "ambiguity is resolved.\n";
  			next;
  		}
  		print STDERR "Migrating from v0 layout...\n" if !$migrated;
  		print STDERR "Renaming ref: $orig_ref => $new_ref\n";
  		command_noisy('update-ref', $new_ref, $orig_ref);
  		command_noisy('update-ref', '-d', $orig_ref, $orig_ref);
  		$migrated++;
  	}
  	command_close_pipe($fh, $ctx);
  	print STDERR "Done migrating from v0 layout...\n" if $migrated;
  	$migrated;
  }
  
  sub migrate_from_v1 {
  	my $git_dir = $ENV{GIT_DIR};
  	my $migrated = 0;
  	return $migrated unless -d $git_dir;
  	my $svn_dir = Git::SVN::svn_dir();
  
  	# just in case somebody used 'svn' as their $id at some point...
  	return $migrated if -d $svn_dir && ! -f "$svn_dir/info/url";
  
  	print STDERR "Migrating from a git-svn v1 layout...\n";
  	mkpath([$svn_dir]);
  	print STDERR "Data from a previous version of git-svn exists, but\n\t",
  	             "$svn_dir\n\t(required for this version ",
  	             "($::VERSION) of git-svn) does not exist.\n";
  	my ($fh, $ctx) = command_output_pipe(qw/rev-parse --symbolic --all/);
  	while (<$fh>) {
  		my $x = $_;
  		next unless $x =~ s#^refs/remotes/##;
  		chomp $x;
  		my $info_url = command_oneline(qw(rev-parse --git-path),
  						"$x/info/url");
  		next unless -f $info_url;
  		my $u = eval { ::file_to_s($info_url) };
  		next unless $u;
  		my $dn = dirname("$svn_dir/$x");
  		mkpath([$dn]) unless -d $dn;
  		if ($x eq 'svn') { # they used 'svn' as GIT_SVN_ID:
  			mkpath(["$svn_dir/svn"]);
  			print STDERR " - $git_dir/$x/info => ",
  			                "$svn_dir/$x/info\n";
  			rename "$git_dir/$x/info", "$svn_dir/$x/info" or
  			       croak "$!: $x";
  			# don't worry too much about these, they probably
  			# don't exist with repos this old (save for index,
  			# and we can easily regenerate that)
  			foreach my $f (qw/unhandled.log index .rev_db/) {
  				rename "$git_dir/$x/$f", "$svn_dir/$x/$f";
  			}
  		} else {
  			print STDERR " - $git_dir/$x => $svn_dir/$x\n";
  			rename "$git_dir/$x", "$svn_dir/$x" or croak "$!: $x";
  		}
  		$migrated++;
  	}
  	command_close_pipe($fh, $ctx);
  	print STDERR "Done migrating from a git-svn v1 layout\n";
  	$migrated;
  }
  
  sub read_old_urls {
  	my ($l_map, $pfx, $path) = @_;
  	my @dir;
  	foreach (<$path/*>) {
  		if (-r "$_/info/url") {
  			$pfx .= '/' if $pfx && $pfx !~ m!/$!;
  			my $ref_id = $pfx . basename $_;
  			my $url = ::file_to_s("$_/info/url");
  			$l_map->{$ref_id} = $url;
  		} elsif (-d $_) {
  			push @dir, $_;
  		}
  	}
  	my $svn_dir = Git::SVN::svn_dir();
  	foreach (@dir) {
  		my $x = $_;
  		$x =~ s!^\Q$svn_dir\E/!!o;
  		read_old_urls($l_map, $x, $_);
  	}
  }
  
  sub migrate_from_v2 {
  	my @cfg = command(qw/config -l/);
  	return if grep /^svn-remote\..+\.url=/, @cfg;
  	my %l_map;
  	read_old_urls(\%l_map, '', Git::SVN::svn_dir());
  	my $migrated = 0;
  
  	require Git::SVN;
  	foreach my $ref_id (sort keys %l_map) {
  		eval { Git::SVN->init($l_map{$ref_id}, '', undef, $ref_id) };
  		if ($@) {
  			Git::SVN->init($l_map{$ref_id}, '', $ref_id, $ref_id);
  		}
  		$migrated++;
  	}
  	$migrated;
  }
  
  sub minimize_connections {
  	require Git::SVN;
  	require Git::SVN::Ra;
  
  	my $r = Git::SVN::read_all_remotes();
  	my $new_urls = {};
  	my $root_repos = {};
  	foreach my $repo_id (keys %$r) {
  		my $url = $r->{$repo_id}->{url} or next;
  		my $fetch = $r->{$repo_id}->{fetch} or next;
  		my $ra = Git::SVN::Ra->new($url);
  
  		# skip existing cases where we already connect to the root
  		if (($ra->url eq $ra->{repos_root}) ||
  		    ($ra->{repos_root} eq $repo_id)) {
  			$root_repos->{$ra->url} = $repo_id;
  			next;
  		}
  
  		my $root_ra = Git::SVN::Ra->new($ra->{repos_root});
  		my $root_path = $ra->url;
  		$root_path =~ s#^\Q$ra->{repos_root}\E(/|$)##;
  		foreach my $path (keys %$fetch) {
  			my $ref_id = $fetch->{$path};
  			my $gs = Git::SVN->new($ref_id, $repo_id, $path);
  
  			# make sure we can read when connecting to
  			# a higher level of a repository
  			my ($last_rev, undef) = $gs->last_rev_commit;
  			if (!defined $last_rev) {
  				$last_rev = eval {
  					$root_ra->get_latest_revnum;
  				};
  				next if $@;
  			}
  			my $new = $root_path;
  			$new .= length $path ? "/$path" : '';
  			eval {
  				$root_ra->get_log([$new], $last_rev, $last_rev,
  			                          0, 0, 1, sub { });
  			};
  			next if $@;
  			$new_urls->{$ra->{repos_root}}->{$new} =
  			        { ref_id => $ref_id,
  				  old_repo_id => $repo_id,
  				  old_path => $path };
  		}
  	}
  
  	my @emptied;
  	foreach my $url (keys %$new_urls) {
  		# see if we can re-use an existing [svn-remote "repo_id"]
  		# instead of creating a(n ugly) new section:
  		my $repo_id = $root_repos->{$url} || $url;
  
  		my $fetch = $new_urls->{$url};
  		foreach my $path (keys %$fetch) {
  			my $x = $fetch->{$path};
  			Git::SVN->init($url, $path, $repo_id, $x->{ref_id});
  			my $pfx = "svn-remote.$x->{old_repo_id}";
  
  			my $old_fetch = quotemeta("$x->{old_path}:".
  			                          "$x->{ref_id}");
  			command_noisy(qw/config --unset/,
  			              "$pfx.fetch", '^'. $old_fetch . '$');
  			delete $r->{$x->{old_repo_id}}->
  			       {fetch}->{$x->{old_path}};
  			if (!keys %{$r->{$x->{old_repo_id}}->{fetch}}) {
  				command_noisy(qw/config --unset/,
  				              "$pfx.url");
  				push @emptied, $x->{old_repo_id}
  			}
  		}
  	}
  	if (@emptied) {
  		my $file = $ENV{GIT_CONFIG} ||
  			command_oneline(qw(rev-parse --git-path config));
  		print STDERR <<EOF;
  The following [svn-remote] sections in your config file ($file) are empty
  and can be safely removed:
  EOF
  		print STDERR "[svn-remote \"$_\"]\n" foreach @emptied;
  	}
  }
  
  sub migration_check {
  	migrate_from_v0();
  	migrate_from_v1();
  	migrate_from_v2();
  	minimize_connections() if $_minimize;
  }
  
  1;
GIT_SVN_MIGRATION

$fatpacked{"Git/SVN/Prompt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_PROMPT';
  package Git::SVN::Prompt;
  use strict;
  use warnings;
  require SVN::Core;
  use vars qw/$_no_auth_cache $_username/;
  
  sub simple {
  	my ($cred, $realm, $default_username, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	$default_username = $_username if defined $_username;
  	if (defined $default_username && length $default_username) {
  		if (defined $realm && length $realm) {
  			print STDERR "Authentication realm: $realm\n";
  			STDERR->flush;
  		}
  		$cred->username($default_username);
  	} else {
  		username($cred, $realm, $may_save, $pool);
  	}
  	$cred->password(_read_password("Password for '" .
  	                               $cred->username . "': ", $realm));
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_server_trust {
  	my ($cred, $realm, $failures, $cert_info, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	print STDERR "Error validating server certificate for '$realm':\n";
  	{
  		no warnings 'once';
  		# All variables SVN::Auth::SSL::* are used only once,
  		# so we're shutting up Perl warnings about this.
  		if ($failures & $SVN::Auth::SSL::UNKNOWNCA) {
  			print STDERR " - The certificate is not issued ",
  			    "by a trusted authority. Use the\n",
  			    "   fingerprint to validate ",
  			    "the certificate manually!\n";
  		}
  		if ($failures & $SVN::Auth::SSL::CNMISMATCH) {
  			print STDERR " - The certificate hostname ",
  			    "does not match.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::NOTYETVALID) {
  			print STDERR " - The certificate is not yet valid.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::EXPIRED) {
  			print STDERR " - The certificate has expired.\n";
  		}
  		if ($failures & $SVN::Auth::SSL::OTHER) {
  			print STDERR " - The certificate has ",
  			    "an unknown error.\n";
  		}
  	} # no warnings 'once'
  	printf STDERR
  	        "Certificate information:\n".
  	        " - Hostname: %s\n".
  	        " - Valid: from %s until %s\n".
  	        " - Issuer: %s\n".
  	        " - Fingerprint: %s\n",
  	        map $cert_info->$_, qw(hostname valid_from valid_until
  	                               issuer_dname fingerprint);
  	my $choice;
  prompt:
  	my $options = $may_save ?
  	      "(R)eject, accept (t)emporarily or accept (p)ermanently? " :
  	      "(R)eject or accept (t)emporarily? ";
  	STDERR->flush;
  	$choice = lc(substr(Git::prompt("Certificate problem.\n" . $options) || 'R', 0, 1));
  	if ($choice eq 't') {
  		$cred->may_save(undef);
  	} elsif ($choice eq 'r') {
  		return -1;
  	} elsif ($may_save && $choice eq 'p') {
  		$cred->may_save($may_save);
  	} else {
  		goto prompt;
  	}
  	$cred->accepted_failures($failures);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_client_cert {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	print STDERR "Client certificate filename: ";
  	STDERR->flush;
  	chomp(my $filename = <STDIN>);
  	$cred->cert_file($filename);
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub ssl_client_cert_pw {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	$cred->password(_read_password("Password: ", $realm));
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub username {
  	my ($cred, $realm, $may_save, $pool) = @_;
  	$may_save = undef if $_no_auth_cache;
  	if (defined $realm && length $realm) {
  		print STDERR "Authentication realm: $realm\n";
  	}
  	my $username;
  	if (defined $_username) {
  		$username = $_username;
  	} else {
  		$username = Git::prompt("Username: ");
  	}
  	$cred->username($username);
  	$cred->may_save($may_save);
  	$SVN::_Core::SVN_NO_ERROR;
  }
  
  sub _read_password {
  	my ($prompt, $realm) = @_;
  	my $password = Git::prompt($prompt, 1);
  	$password;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Prompt - authentication callbacks for git-svn
  
  =head1 SYNOPSIS
  
      use Git::SVN::Prompt qw(simple ssl_client_cert ssl_client_cert_pw
                              ssl_server_trust username);
      use SVN::Client ();
  
      my $cached_simple = SVN::Client::get_simple_provider();
      my $git_simple = SVN::Client::get_simple_prompt_provider(\&simple, 2);
      my $cached_ssl = SVN::Client::get_ssl_server_trust_file_provider();
      my $git_ssl = SVN::Client::get_ssl_server_trust_prompt_provider(
          \&ssl_server_trust);
      my $cached_cert = SVN::Client::get_ssl_client_cert_file_provider();
      my $git_cert = SVN::Client::get_ssl_client_cert_prompt_provider(
          \&ssl_client_cert, 2);
      my $cached_cert_pw = SVN::Client::get_ssl_client_cert_pw_file_provider();
      my $git_cert_pw = SVN::Client::get_ssl_client_cert_pw_prompt_provider(
          \&ssl_client_cert_pw, 2);
      my $cached_username = SVN::Client::get_username_provider();
      my $git_username = SVN::Client::get_username_prompt_provider(
          \&username, 2);
  
      my $ctx = new SVN::Client(
          auth => [
              $cached_simple, $git_simple,
              $cached_ssl, $git_ssl,
              $cached_cert, $git_cert,
              $cached_cert_pw, $git_cert_pw,
              $cached_username, $git_username
          ]);
  
  =head1 DESCRIPTION
  
  This module is an implementation detail of the "git svn" command.
  It implements git-svn's authentication policy.  Do not use it unless
  you are developing git-svn.
  
  The interface will change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  L<SVN::Core>.
  
  =head1 SEE ALSO
  
  L<SVN::Client>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_PROMPT

$fatpacked{"Git/SVN/Ra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_RA';
  package Git::SVN::Ra;
  use vars qw/@ISA $config_dir $_ignore_refs_regex $_log_window_size/;
  use strict;
  use warnings;
  use Memoize;
  use Git::SVN::Utils qw(
  	canonicalize_url
  	canonicalize_path
  	add_path_to_url
  );
  
  use SVN::Ra;
  BEGIN {
  	@ISA = qw(SVN::Ra);
  }
  
  my ($ra_invalid, $can_do_switch, %ignored_err, $RA);
  
  BEGIN {
  	# enforce temporary pool usage for some simple functions
  	no strict 'refs';
  	for my $f (qw/rev_proplist get_latest_revnum get_uuid get_repos_root
  	              get_file/) {
  		my $SUPER = "SUPER::$f";
  		*$f = sub {
  			my $self = shift;
  			my $pool = SVN::Pool->new;
  			my @ret = $self->$SUPER(@_,$pool);
  			$pool->clear;
  			wantarray ? @ret : $ret[0];
  		};
  	}
  }
  
  # serf has a bug that leads to a coredump upon termination if the
  # remote access object is left around (not fixed yet in serf 1.3.1).
  # Explicitly free it to work around the issue.
  END {
  	$RA = undef;
  	$ra_invalid = 1;
  }
  
  sub _auth_providers () {
  	require SVN::Client;
  	my @rv = (
  	  SVN::Client::get_simple_provider(),
  	  SVN::Client::get_ssl_server_trust_file_provider(),
  	  SVN::Client::get_simple_prompt_provider(
  	    \&Git::SVN::Prompt::simple, 2),
  	  SVN::Client::get_ssl_client_cert_file_provider(),
  	  SVN::Client::get_ssl_client_cert_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_client_cert, 2),
  	  SVN::Client::get_ssl_client_cert_pw_file_provider(),
  	  SVN::Client::get_ssl_client_cert_pw_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_client_cert_pw, 2),
  	  SVN::Client::get_username_provider(),
  	  SVN::Client::get_ssl_server_trust_prompt_provider(
  	    \&Git::SVN::Prompt::ssl_server_trust),
  	  SVN::Client::get_username_prompt_provider(
  	    \&Git::SVN::Prompt::username, 2)
  	);
  
  	# earlier 1.6.x versions would segfault, and <= 1.5.x didn't have
  	# this function
  	if (::compare_svn_version('1.6.15') >= 0) {
  		my $config = SVN::Core::config_get_config($config_dir);
  		my ($p, @a);
  		# config_get_config returns all config files from
  		# ~/.subversion, auth_get_platform_specific_client_providers
  		# just wants the config "file".
  		@a = ($config->{'config'}, undef);
  		$p = SVN::Core::auth_get_platform_specific_client_providers(@a);
  		# Insert the return value from
  		# auth_get_platform_specific_providers
  		unshift @rv, @$p;
  	}
  	\@rv;
  }
  
  sub prepare_config_once {
  	SVN::_Core::svn_config_ensure($config_dir, undef);
  	my ($baton, $callbacks) = SVN::Core::auth_open_helper(_auth_providers);
  	my $config = SVN::Core::config_get_config($config_dir);
  	my $conf_t = $config->{'config'};
  
  	no warnings 'once';
  	# The usage of $SVN::_Core::SVN_CONFIG_* variables
  	# produces warnings that variables are used only once.
  	# I had not found the better way to shut them up, so
  	# the warnings of type 'once' are disabled in this block.
  	if (SVN::_Core::svn_config_get_bool($conf_t,
  	    $SVN::_Core::SVN_CONFIG_SECTION_AUTH,
  	    $SVN::_Core::SVN_CONFIG_OPTION_STORE_PASSWORDS,
  	    1) == 0) {
  		my $val = '1';
  		if (::compare_svn_version('1.9.0') < 0) { # pre-SVN r1553823
  			my $dont_store_passwords = 1;
  			$val = bless \$dont_store_passwords, "_p_void";
  		}
  		SVN::_Core::svn_auth_set_parameter($baton,
  		    $SVN::_Core::SVN_AUTH_PARAM_DONT_STORE_PASSWORDS,
  		    $val);
  	}
  	if (SVN::_Core::svn_config_get_bool($conf_t,
  	    $SVN::_Core::SVN_CONFIG_SECTION_AUTH,
  	    $SVN::_Core::SVN_CONFIG_OPTION_STORE_AUTH_CREDS,
  	    1) == 0) {
  		$Git::SVN::Prompt::_no_auth_cache = 1;
  	}
  
  	return ($config, $baton, $callbacks);
  } # no warnings 'once'
  
  INIT {
  	Memoize::memoize '_auth_providers';
  	Memoize::memoize 'prepare_config_once';
  }
  
  sub new {
  	my ($class, $url) = @_;
  	$url = canonicalize_url($url);
  	return $RA if ($RA && $RA->url eq $url);
  
  	::_req_svn();
  
  	$RA = undef;
  	my ($config, $baton, $callbacks) = prepare_config_once();
  	my $self = SVN::Ra->new(url => $url, auth => $baton,
  	                      config => $config,
  			      pool => SVN::Pool->new,
  	                      auth_provider_callbacks => $callbacks);
  	$RA = bless $self, $class;
  
  	# Make sure its canonicalized
  	$self->url($url);
  	$self->{svn_path} = $url;
  	$self->{repos_root} = $self->get_repos_root;
  	$self->{svn_path} =~ s#^\Q$self->{repos_root}\E(/|$)##;
  	$self->{cache} = { check_path => { r => 0, data => {} },
  	                   get_dir => { r => 0, data => {} } };
  
  	return $RA;
  }
  
  sub url {
  	my $self = shift;
  
  	if (@_) {
  		my $url = shift;
  		$self->{url} = canonicalize_url($url);
  		return;
  	}
  
  	return $self->{url};
  }
  
  sub check_path {
  	my ($self, $path, $r) = @_;
  	my $cache = $self->{cache}->{check_path};
  	if ($r == $cache->{r} && exists $cache->{data}->{$path}) {
  		return $cache->{data}->{$path};
  	}
  	my $pool = SVN::Pool->new;
  	my $t = $self->SUPER::check_path($path, $r, $pool);
  	$pool->clear;
  	if ($r != $cache->{r}) {
  		%{$cache->{data}} = ();
  		$cache->{r} = $r;
  	}
  	$cache->{data}->{$path} = $t;
  }
  
  sub get_dir {
  	my ($self, $dir, $r) = @_;
  	my $cache = $self->{cache}->{get_dir};
  	if ($r == $cache->{r}) {
  		if (my $x = $cache->{data}->{$dir}) {
  			return wantarray ? @$x : $x->[0];
  		}
  	}
  	my $pool = SVN::Pool->new;
  	my ($d, undef, $props);
  
  	if (::compare_svn_version('1.4.0') >= 0) {
  		# n.b. in addition to being potentially more efficient,
  		# this works around what appears to be a bug in some
  		# SVN 1.8 versions
  		my $kind = 1; # SVN_DIRENT_KIND
  		($d, undef, $props) = $self->get_dir2($dir, $r, $kind, $pool);
  	} else {
  		($d, undef, $props) = $self->SUPER::get_dir($dir, $r, $pool);
  	}
  	my %dirents = map { $_ => { kind => $d->{$_}->kind } } keys %$d;
  	$pool->clear;
  	if ($r != $cache->{r}) {
  		%{$cache->{data}} = ();
  		$cache->{r} = $r;
  	}
  	$cache->{data}->{$dir} = [ \%dirents, $r, $props ];
  	wantarray ? (\%dirents, $r, $props) : \%dirents;
  }
  
  # get_log(paths, start, end, limit,
  #         discover_changed_paths, strict_node_history, receiver)
  sub get_log {
  	my ($self, @args) = @_;
  	my $pool = SVN::Pool->new;
  
  	# svn_log_changed_path_t objects passed to get_log are likely to be
  	# overwritten even if only the refs are copied to an external variable,
  	# so we should dup the structures in their entirety.  Using an
  	# externally passed pool (instead of our temporary and quickly cleared
  	# pool in Git::SVN::Ra) does not help matters at all...
  	my $receiver = pop @args;
  	my $prefix = "/".$self->{svn_path};
  	$prefix =~ s#/+($)##;
  	my $prefix_regex = qr#^\Q$prefix\E#;
  	push(@args, sub {
  		my ($paths) = $_[0];
  		return &$receiver(@_) unless $paths;
  		$_[0] = ();
  		foreach my $p (keys %$paths) {
  			my $i = $paths->{$p};
  			# Make path relative to our url, not repos_root
  			$p =~ s/$prefix_regex//;
  			my %s = map { $_ => $i->$_; }
  				qw/copyfrom_path copyfrom_rev action/;
  			if ($s{'copyfrom_path'}) {
  				$s{'copyfrom_path'} =~ s/$prefix_regex//;
  				$s{'copyfrom_path'} = canonicalize_path($s{'copyfrom_path'});
  			}
  			$_[0]{$p} = \%s;
  		}
  		&$receiver(@_);
  	});
  
  
  	# the limit parameter was not supported in SVN 1.1.x, so we
  	# drop it.  Therefore, the receiver callback passed to it
  	# is made aware of this limitation by being wrapped if
  	# the limit passed to is being wrapped.
  	if (::compare_svn_version('1.2.0') <= 0) {
  		my $limit = splice(@args, 3, 1);
  		if ($limit > 0) {
  			my $receiver = pop @args;
  			push(@args, sub { &$receiver(@_) if (--$limit >= 0) });
  		}
  	}
  	my $ret = $self->SUPER::get_log(@args, $pool);
  	$pool->clear;
  	$ret;
  }
  
  # uncommon, only for ancient SVN (<= 1.4.2)
  sub trees_match {
  	require IO::File;
  	require SVN::Client;
  	my ($self, $url1, $rev1, $url2, $rev2) = @_;
  	my $ctx = SVN::Client->new(auth => _auth_providers);
  	my $out = IO::File->new_tmpfile;
  
  	# older SVN (1.1.x) doesn't take $pool as the last parameter for
  	# $ctx->diff(), so we'll create a default one
  	my $pool = SVN::Pool->new_default_sub;
  
  	$ra_invalid = 1; # this will open a new SVN::Ra connection to $url1
  	$ctx->diff([], $url1, $rev1, $url2, $rev2, 1, 1, 0, $out, $out);
  	$out->flush;
  	my $ret = (($out->stat)[7] == 0);
  	close $out or croak $!;
  
  	$ret;
  }
  
  sub get_commit_editor {
  	my ($self, $log, $cb, $pool) = @_;
  
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef, 0) : ();
  	$self->SUPER::get_commit_editor($log, $cb, @lock, $pool);
  }
  
  sub gs_do_update {
  	my ($self, $rev_a, $rev_b, $gs, $editor) = @_;
  	my $new = ($rev_a == $rev_b);
  	my $path = $gs->path;
  
  	if ($new && -e $gs->{index}) {
  		unlink $gs->{index} or die
  		  "Couldn't unlink index: $gs->{index}: $!\n";
  	}
  	my $pool = SVN::Pool->new;
  	$editor->set_path_strip($path);
  	my (@pc) = split m#/#, $path;
  	my $reporter = $self->do_update($rev_b, (@pc ? shift @pc : ''),
  	                                1, $editor, $pool);
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef) : ();
  
  	# Since we can't rely on svn_ra_reparent being available, we'll
  	# just have to do some magic with set_path to make it so
  	# we only want a partial path.
  	my $sp = '';
  	my $final = join('/', @pc);
  	while (@pc) {
  		$reporter->set_path($sp, $rev_b, 0, @lock, $pool);
  		$sp .= '/' if length $sp;
  		$sp .= shift @pc;
  	}
  	die "BUG: '$sp' != '$final'\n" if ($sp ne $final);
  
  	$reporter->set_path($sp, $rev_a, $new, @lock, $pool);
  
  	$reporter->finish_report($pool);
  	$pool->clear;
  	$editor->{git_commit_ok};
  }
  
  # this requires SVN 1.4.3 or later (do_switch didn't work before 1.4.3, and
  # svn_ra_reparent didn't work before 1.4)
  sub gs_do_switch {
  	my ($self, $rev_a, $rev_b, $gs, $url_b, $editor) = @_;
  	my $path = $gs->path;
  	my $pool = SVN::Pool->new;
  
  	my $old_url = $self->url;
  	my $full_url = add_path_to_url( $self->url, $path );
  	my ($ra, $reparented);
  
  	if ($old_url =~ m#^svn(\+\w+)?://# ||
  	    ($full_url =~ m#^https?://# &&
  	     canonicalize_url($full_url) ne $full_url)) {
  		$_[0] = undef;
  		$self = undef;
  		$RA = undef;
  		$ra = Git::SVN::Ra->new($full_url);
  		$ra_invalid = 1;
  	} elsif ($old_url ne $full_url) {
  		SVN::_Ra::svn_ra_reparent(
  			$self->{session},
  			canonicalize_url($full_url),
  			$pool
  		);
  		$self->url($full_url);
  		$reparented = 1;
  	}
  
  	$ra ||= $self;
  	$url_b = canonicalize_url($url_b);
  	my $reporter = $ra->do_switch($rev_b, '', 1, $url_b, $editor, $pool);
  	my @lock = (::compare_svn_version('1.2.0') >= 0) ? (undef) : ();
  	$reporter->set_path('', $rev_a, 0, @lock, $pool);
  	$reporter->finish_report($pool);
  
  	if ($reparented) {
  		SVN::_Ra::svn_ra_reparent($self->{session}, $old_url, $pool);
  		$self->url($old_url);
  	}
  
  	$pool->clear;
  	$editor->{git_commit_ok};
  }
  
  sub longest_common_path {
  	my ($gsv, $globs) = @_;
  	my %common;
  	my $common_max = scalar @$gsv;
  
  	foreach my $gs (@$gsv) {
  		my @tmp = split m#/#, $gs->path;
  		my $p = '';
  		foreach (@tmp) {
  			$p .= length($p) ? "/$_" : $_;
  			$common{$p} ||= 0;
  			$common{$p}++;
  		}
  	}
  	$globs ||= [];
  	$common_max += scalar @$globs;
  	foreach my $glob (@$globs) {
  		my @tmp = split m#/#, $glob->{path}->{left};
  		my $p = '';
  		foreach (@tmp) {
  			$p .= length($p) ? "/$_" : $_;
  			$common{$p} ||= 0;
  			$common{$p}++;
  		}
  	}
  
  	my $longest_path = '';
  	foreach (sort {length $b <=> length $a} keys %common) {
  		if ($common{$_} == $common_max) {
  			$longest_path = $_;
  			last;
  		}
  	}
  	$longest_path;
  }
  
  sub gs_fetch_loop_common {
  	my ($self, $base, $head, $gsv, $globs) = @_;
  	return if ($base > $head);
  	# Make sure the cat_blob open2 FileHandle is created before calling
  	# SVN::Pool::new_default so that it does not incorrectly end up in the pool.
  	$::_repository->_open_cat_blob_if_needed;
  	my $gpool = SVN::Pool->new_default;
  	my $ra_url = $self->url;
  	my $reload_ra = sub {
  		$_[0] = undef;
  		$self = undef;
  		$RA = undef;
  		$gpool->clear;
  		$self = Git::SVN::Ra->new($ra_url);
  		$ra_invalid = undef;
  	};
  	my $inc = $_log_window_size;
  	my ($min, $max) = ($base, $head < $base + $inc ? $head : $base + $inc);
  	my $longest_path = longest_common_path($gsv, $globs);
  	my $find_trailing_edge;
  	while (1) {
  		my %revs;
  		my $err;
  		my $err_handler = $SVN::Error::handler;
  		$SVN::Error::handler = sub {
  			($err) = @_;
  			skip_unknown_revs($err);
  		};
  		sub _cb {
  			my ($paths, $r, $author, $date, $log) = @_;
  			[ $paths,
  			  { author => $author, date => $date, log => $log } ];
  		}
  		$self->get_log([$longest_path], $min, $max, 0, 1, 1,
  		               sub { $revs{$_[1]} = _cb(@_) });
  		if ($err) {
  			print "Checked through r$max\r";
  		} else {
  			$find_trailing_edge = 1;
  		}
  		if ($err and $find_trailing_edge) {
  			print STDERR "Path '$longest_path' ",
  				     "was probably deleted:\n",
  				     $err->expanded_message,
  				     "\nWill attempt to follow ",
  				     "revisions r$min .. r$max ",
  				     "committed before the deletion\n";
  			my $hi = $max;
  			while (--$hi >= $min) {
  				my $ok;
  				$self->get_log([$longest_path], $min, $hi,
  				               0, 1, 1, sub {
  				               $ok = $_[1];
  				               $revs{$_[1]} = _cb(@_) });
  				if ($ok) {
  					print STDERR "r$min .. r$ok OK\n";
  					last;
  				}
  			}
  			$find_trailing_edge = 0;
  		}
  		$SVN::Error::handler = $err_handler;
  
  		my %exists = map { $_->path => $_ } @$gsv;
  		foreach my $r (sort {$a <=> $b} keys %revs) {
  			my ($paths, $logged) = @{delete $revs{$r}};
  
  			foreach my $gs ($self->match_globs(\%exists, $paths,
  			                                   $globs, $r)) {
  				if ($gs->rev_map_max >= $r) {
  					next;
  				}
  				next unless $gs->match_paths($paths, $r);
  				$gs->{logged_rev_props} = $logged;
  				if (my $last_commit = $gs->last_commit) {
  					$gs->assert_index_clean($last_commit);
  				}
  				my $log_entry = $gs->do_fetch($paths, $r);
  				if ($log_entry) {
  					$gs->do_git_commit($log_entry);
  				}
  				$Git::SVN::INDEX_FILES{$gs->{index}} = 1;
  			}
  			foreach my $g (@$globs) {
  				my $k = "svn-remote.$g->{remote}." .
  				        "$g->{t}-maxRev";
  				Git::SVN::tmp_config($k, $r);
  			}
  			$reload_ra->() if $ra_invalid;
  		}
  		# pre-fill the .rev_db since it'll eventually get filled in
  		# with '0' x40 if something new gets committed
  		foreach my $gs (@$gsv) {
  			next if $gs->rev_map_max >= $max;
  			next if defined $gs->rev_map_get($max);
  			$gs->rev_map_set($max, 0 x40);
  		}
  		foreach my $g (@$globs) {
  			my $k = "svn-remote.$g->{remote}.$g->{t}-maxRev";
  			Git::SVN::tmp_config($k, $max);
  		}
  		last if $max >= $head;
  		$min = $max + 1;
  		$max += $inc;
  		$max = $head if ($max > $head);
  
  		$reload_ra->();
  	}
  	Git::SVN::gc();
  }
  
  sub get_dir_globbed {
  	my ($self, $left, $depth, $r) = @_;
  
  	my @x = eval { $self->get_dir($left, $r) };
  	return unless scalar @x == 3;
  	my $dirents = $x[0];
  	my @finalents;
  	foreach my $de (keys %$dirents) {
  		next if $dirents->{$de}->{kind} != $SVN::Node::dir;
  		if ($depth > 1) {
  			my @args = ("$left/$de", $depth - 1, $r);
  			foreach my $dir ($self->get_dir_globbed(@args)) {
  				push @finalents, "$de/$dir";
  			}
  		} else {
  			push @finalents, $de;
  		}
  	}
  	@finalents;
  }
  
  # return value: 0 -- don't ignore, 1 -- ignore
  sub is_ref_ignored {
  	my ($g, $p) = @_;
  	my $refname = $g->{ref}->full_path($p);
  	return 1 if defined($g->{ignore_refs_regex}) &&
  	            $refname =~ m!$g->{ignore_refs_regex}!;
  	return 0 unless defined($_ignore_refs_regex);
  	return 1 if $refname =~ m!$_ignore_refs_regex!o;
  	return 0;
  }
  
  sub match_globs {
  	my ($self, $exists, $paths, $globs, $r) = @_;
  
  	sub get_dir_check {
  		my ($self, $exists, $g, $r) = @_;
  
  		my @dirs = $self->get_dir_globbed($g->{path}->{left},
  		                                  $g->{path}->{depth},
  		                                  $r);
  
  		foreach my $de (@dirs) {
  			my $p = $g->{path}->full_path($de);
  			next if $exists->{$p};
  			next if (length $g->{path}->{right} &&
  				 ($self->check_path($p, $r) !=
  				  $SVN::Node::dir));
  			next unless $p =~ /$g->{path}->{regex}/;
  			$exists->{$p} = Git::SVN->init($self->url, $p, undef,
  					 $g->{ref}->full_path($de), 1);
  		}
  	}
  	foreach my $g (@$globs) {
  		if (my $path = $paths->{"/$g->{path}->{left}"}) {
  			if ($path->{action} =~ /^[AR]$/) {
  				get_dir_check($self, $exists, $g, $r);
  			}
  		}
  		foreach (keys %$paths) {
  			if (/$g->{path}->{left_regex}/ &&
  			    !/$g->{path}->{regex}/) {
  				next if $paths->{$_}->{action} !~ /^[AR]$/;
  				get_dir_check($self, $exists, $g, $r);
  			}
  			next unless /$g->{path}->{regex}/;
  			my $p = $1;
  			my $pathname = $g->{path}->full_path($p);
  			next if is_ref_ignored($g, $p);
  			next if $exists->{$pathname};
  			next if ($self->check_path($pathname, $r) !=
  			         $SVN::Node::dir);
  			$exists->{$pathname} = Git::SVN->init(
  			                      $self->url, $pathname, undef,
  			                      $g->{ref}->full_path($p), 1);
  		}
  		my $c = '';
  		foreach (split m#/#, $g->{path}->{left}) {
  			$c .= "/$_";
  			next unless ($paths->{$c} &&
  			             ($paths->{$c}->{action} =~ /^[AR]$/));
  			get_dir_check($self, $exists, $g, $r);
  		}
  	}
  	values %$exists;
  }
  
  sub minimize_url {
  	my ($self) = @_;
  	return $self->url if ($self->url eq $self->{repos_root});
  	my $url = $self->{repos_root};
  	my @components = split(m!/!, $self->{svn_path});
  	my $c = '';
  	do {
  		$url = add_path_to_url($url, $c);
  		eval {
  			my $ra = (ref $self)->new($url);
  			my $latest = $ra->get_latest_revnum;
  			$ra->get_log("", $latest, 0, 1, 0, 1, sub {});
  		};
  	} while ($@ && defined($c = shift @components));
  
  	return canonicalize_url($url);
  }
  
  sub can_do_switch {
  	my $self = shift;
  	unless (defined $can_do_switch) {
  		my $pool = SVN::Pool->new;
  		my $rep = eval {
  			$self->do_switch(1, '', 0, $self->url,
  			                 SVN::Delta::Editor->new, $pool);
  		};
  		if ($@) {
  			$can_do_switch = 0;
  		} else {
  			$rep->abort_report($pool);
  			$can_do_switch = 1;
  		}
  		$pool->clear;
  	}
  	$can_do_switch;
  }
  
  sub skip_unknown_revs {
  	my ($err) = @_;
  	my $errno = $err->apr_err();
  	# Maybe the branch we're tracking didn't
  	# exist when the repo started, so it's
  	# not an error if it doesn't, just continue
  	#
  	# Wonderfully consistent library, eh?
  	# 160013 - svn:// and file://
  	# 175002 - http(s)://
  	# 175007 - http(s):// (this repo required authorization, too...)
  	#   More codes may be discovered later...
  	if ($errno == 175007 || $errno == 175002 || $errno == 160013) {
  		my $err_key = $err->expanded_message;
  		# revision numbers change every time, filter them out
  		$err_key =~ s/\d+/\0/g;
  		$err_key = "$errno\0$err_key";
  		unless ($ignored_err{$err_key}) {
  			warn "W: Ignoring error from SVN, path probably ",
  			     "does not exist: ($errno): ",
  			     $err->expanded_message,"\n";
  			warn "W: Do not be alarmed at the above message ",
  			     "git-svn is just searching aggressively for ",
  			     "old history.\n",
  			     "This may take a while on large repositories\n";
  			$ignored_err{$err_key} = 1;
  		}
  		return;
  	}
  	die "Error from SVN, ($errno): ", $err->expanded_message,"\n";
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Git::SVN::Ra - Subversion remote access functions for git-svn
  
  =head1 SYNOPSIS
  
      use Git::SVN::Ra;
  
      my $ra = Git::SVN::Ra->new($branchurl);
      my ($dirents, $fetched_revnum, $props) =
          $ra->get_dir('.', $SVN::Core::INVALID_REVNUM);
  
  =head1 DESCRIPTION
  
  This is a wrapper around the L<SVN::Ra> module for use by B<git-svn>.
  It fills in some default parameters (such as the authentication
  scheme), smooths over incompatibilities between libsvn versions, adds
  caching, and implements some functions specific to B<git-svn>.
  
  Do not use it unless you are developing git-svn.  The interface will
  change as git-svn evolves.
  
  =head1 DEPENDENCIES
  
  Subversion perl bindings,
  L<Git::SVN>.
  
  C<Git::SVN::Ra> has not been tested using callers other than
  B<git-svn> itself.
  
  =head1 SEE ALSO
  
  L<SVN::Ra>.
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  =head1 BUGS
  
  None.
GIT_SVN_RA

$fatpacked{"Git/SVN/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT_SVN_UTILS';
  package Git::SVN::Utils;
  
  use strict;
  use warnings;
  
  use SVN::Core;
  
  use base qw(Exporter);
  
  our @EXPORT_OK = qw(
  	fatal
  	can_compress
  	canonicalize_path
  	canonicalize_url
  	join_paths
  	add_path_to_url
  );
  
  
  =head1 NAME
  
  Git::SVN::Utils - utility functions used across Git::SVN
  
  =head1 SYNOPSIS
  
      use Git::SVN::Utils qw(functions to import);
  
  =head1 DESCRIPTION
  
  This module contains functions which are useful across many different
  parts of Git::SVN.  Mostly it's a place to put utility functions
  rather than duplicate the code or have classes grabbing at other
  classes.
  
  =head1 FUNCTIONS
  
  All functions can be imported only on request.
  
  =head3 fatal
  
      fatal(@message);
  
  Display a message and exit with a fatal error code.
  
  =cut
  
  # Note: not certain why this is in use instead of die.  Probably because
  # the exit code of die is 255?  Doesn't appear to be used consistently.
  sub fatal (@) { print STDERR "@_\n"; exit 1 }
  
  
  =head3 can_compress
  
      my $can_compress = can_compress;
  
  Returns true if Compress::Zlib is available, false otherwise.
  
  =cut
  
  my $can_compress;
  sub can_compress {
  	return $can_compress if defined $can_compress;
  
  	return $can_compress = eval { require Compress::Zlib; };
  }
  
  
  =head3 canonicalize_path
  
      my $canoncalized_path = canonicalize_path($path);
  
  Converts $path into a canonical form which is safe to pass to the SVN
  API as a file path.
  
  =cut
  
  # Turn foo/../bar into bar
  sub _collapse_dotdot {
  	my $path = shift;
  
  	1 while $path =~ s{/[^/]+/+\.\.}{};
  	1 while $path =~ s{[^/]+/+\.\./}{};
  	1 while $path =~ s{[^/]+/+\.\.}{};
  
  	return $path;
  }
  
  
  sub canonicalize_path {
  	my $path = shift;
  	my $rv;
  
  	# The 1.7 way to do it
  	if ( defined &SVN::_Core::svn_dirent_canonicalize ) {
  		$path = _collapse_dotdot($path);
  		$rv = SVN::_Core::svn_dirent_canonicalize($path);
  	}
  	# The 1.6 way to do it
  	# This can return undef on subversion-perl-1.4.2-2.el5 (CentOS 5.2)
  	elsif ( defined &SVN::_Core::svn_path_canonicalize ) {
  		$path = _collapse_dotdot($path);
  		$rv = SVN::_Core::svn_path_canonicalize($path);
  	}
  
  	return $rv if defined $rv;
  
  	# No SVN API canonicalization is available, or the SVN API
  	# didn't return a successful result, do it ourselves
  	return _canonicalize_path_ourselves($path);
  }
  
  
  sub _canonicalize_path_ourselves {
  	my ($path) = @_;
  	my $dot_slash_added = 0;
  	if (substr($path, 0, 1) ne "/") {
  		$path = "./" . $path;
  		$dot_slash_added = 1;
  	}
  	$path =~ s#/+#/#g;
  	$path =~ s#/\.(?:/|$)#/#g;
  	$path = _collapse_dotdot($path);
  	$path =~ s#/$##g;
  	$path =~ s#^\./## if $dot_slash_added;
  	$path =~ s#^\.$##;
  	return $path;
  }
  
  
  =head3 canonicalize_url
  
      my $canonicalized_url = canonicalize_url($url);
  
  Converts $url into a canonical form which is safe to pass to the SVN
  API as a URL.
  
  =cut
  
  sub canonicalize_url {
  	my $url = shift;
  
  	# The 1.7 way to do it
  	if ( defined &SVN::_Core::svn_uri_canonicalize ) {
  		return SVN::_Core::svn_uri_canonicalize($url);
  	}
  	# There wasn't a 1.6 way to do it, so we do it ourself.
  	else {
  		return _canonicalize_url_ourselves($url);
  	}
  }
  
  
  sub _canonicalize_url_path {
  	my ($uri_path) = @_;
  
  	my @parts;
  	foreach my $part (split m{/+}, $uri_path) {
  		$part =~ s/([^!\$%&'()*+,.\/\w:=\@_`~-]|%(?![a-fA-F0-9]{2}))/sprintf("%%%02X",ord($1))/eg;
  		push @parts, $part;
  	}
  
  	return join('/', @parts);
  }
  
  sub _canonicalize_url_ourselves {
  	my ($url) = @_;
  	if ($url =~ m#^([^:]+)://([^/]*)(.*)$#) {
  		my ($scheme, $domain, $uri) = ($1, $2, _canonicalize_url_path(canonicalize_path($3)));
  		$url = "$scheme://$domain$uri";
  	}
  	$url;
  }
  
  
  =head3 join_paths
  
      my $new_path = join_paths(@paths);
  
  Appends @paths together into a single path.  Any empty paths are ignored.
  
  =cut
  
  sub join_paths {
  	my @paths = @_;
  
  	@paths = grep { defined $_ && length $_ } @paths;
  
  	return '' unless @paths;
  	return $paths[0] if @paths == 1;
  
  	my $new_path = shift @paths;
  	$new_path =~ s{/+$}{};
  
  	my $last_path = pop @paths;
  	$last_path =~ s{^/+}{};
  
  	for my $path (@paths) {
  		$path =~ s{^/+}{};
  		$path =~ s{/+$}{};
  		$new_path .= "/$path";
  	}
  
  	return $new_path .= "/$last_path";
  }
  
  
  =head3 add_path_to_url
  
      my $new_url = add_path_to_url($url, $path);
  
  Appends $path onto the $url.  If $path is empty, $url is returned unchanged.
  
  =cut
  
  sub add_path_to_url {
  	my($url, $path) = @_;
  
  	return $url if !defined $path or !length $path;
  
  	# Strip trailing and leading slashes so we don't
  	# wind up with http://x.com///path
  	$url  =~ s{/+$}{};
  	$path =~ s{^/+}{};
  
  	# If a path has a % in it, URI escape it so it's not
  	# mistaken for a URI escape later.
  	$path =~ s{%}{%25}g;
  
  	return join '/', $url, $path;
  }
  
  1;
GIT_SVN_UTILS

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use Exporter;
  BEGIN { @JSON::ISA = 'Exporter' }
  
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '4.02';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my %RequiredVersion = (
      'JSON::PP' => '2.27203',
      'JSON::XS' => '2.34',
  );
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw//; # Currently nothing
  
  my @PublicMethodsSince4_0 = qw/allow_tags/;
  my @PropertiesSince4_0 = qw/allow_tags/;
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1') {
          $backend = 'JSON::XS,JSON::PP';
      }
      elsif ($backend eq '0') {
          $backend = 'JSON::PP';
      }
      elsif ($backend eq '2') {
          $backend = 'JSON::XS';
      }
      $backend =~ s/\s+//g;
  
      my @backend_modules = split /,/, $backend;
      while(my $module = shift @backend_modules) {
          if ($module =~ /JSON::XS/) {
              _load_xs($module, @backend_modules ? $_INSTALL_DONT_DIE : 0);
          }
          elsif ($module =~ /JSON::PP/) {
              _load_pp($module);
          }
          elsif ($module =~ /JSON::backportPP/) {
              _load_pp($module);
          }
          else {
              Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
          }
          last if $JSON::Backend;
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend->is_xs);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              my $org_encode = $JSON::Backend->can('encode');
              eval q|
                  require B;
                  local $^W;
                  no strict 'refs';
                  *{"${JSON::Backend}\::encode"} = sub {
                      # only works with Perl 5.18+
                      local *UNIVERSAL::TO_JSON = sub {
                          my $b_obj = B::svref_2object( $_[0] );
                          return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                                  : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                                  : undef
                                  ;
                      };
                      $org_encode->(@_);
                  };
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub boolean {
      # might be called as method or as function, so pop() to get the last arg instead of shift() to get the first
      pop() ? $JSON::true : $JSON::false
  }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $RequiredVersion{'JSON::XS'}; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->backend->is_xs;
  }
  
  
  sub is_pp {
      return $_[0]->backend->is_pp;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub __load_xs {
      my ($module, $opt) = @_;
  
      $JSON::DEBUG and Carp::carp "Load $module.";
      my $required_version = $RequiredVersion{$module} || '';
  
      eval qq|
          use $module $required_version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $module...($@)";
              return 0;
          }
          Carp::croak $@;
      }
      $JSON::BackendModuleXS = $module;
      return 1;
  }
  
  sub _load_xs {
      my ($module, $opt) = @_;
      __load_xs($module, $opt) or return;
  
      my $data = join("", <DATA>); # this code is from Jcode 2.xx.
      close(DATA);
      eval $data;
      JSON::Backend::XS->init($module);
  
      return 1;
  };
  
  
  sub __load_pp {
      my ($module, $opt) = @_;
  
      $JSON::DEBUG and Carp::carp "Load $module.";
      my $required_version = $RequiredVersion{$module} || '';
  
      eval qq| use $module $required_version () |;
  
      if ($@) {
          if ( $module eq 'JSON::PP' ) {
              $JSON::DEBUG and Carp::carp "Can't load $module ($@), so try to load JSON::backportPP";
              $module = 'JSON::backportPP';
              local $^W; # if PP installed but invalid version, backportPP redefines methods.
              eval qq| require $module |;
          }
          Carp::croak $@ if $@;
      }
      $JSON::BackendModulePP = $module;
      return 1;
  }
  
  sub _load_pp {
      my ($module, $opt) = @_;
      __load_pp($module, $opt);
  
      JSON::Backend::PP->init($module);
  };
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      my ($class, $module) = @_;
  
      # name may vary, but the module should (always) be a JSON::PP
  
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::is_bool"} = \&{"JSON::PP::is_bool"};
  
      $JSON::true  = ${"JSON::PP::true"};
      $JSON::false = ${"JSON::PP::false"};
  
      push @JSON::Backend::PP::ISA, 'JSON::PP';
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      my $version = ${"$class\::VERSION"} = $module->VERSION;
      $version =~ s/_//;
      if ($version < 3.99) {
          push @XSOnlyMethods, qw/allow_tags get_allow_tags/;
      } else {
          push @Properties, 'allow_tags';
      }
  
      for my $method (@XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported by $module $version.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 0 };
  sub is_pp { 1 };
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  sub init {
      my ($class, $module) = @_;
  
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"$module\::decode_json"};
      *{"JSON::encode_json"} = \&{"$module\::encode_json"};
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::Backend::XS::ISA, $module;
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      if ( $module->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      for my $method (@PPOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported by $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 1 };
  sub is_pp { 0 };
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      JSON::__load_pp('JSON::PP');
  
      local $^W;
      no strict qw(refs);
  
      for my $method (@methods) {
          my $pp_method = JSON::PP->can($method) or next;
          *{"JSON::$method"} = sub {
              if (!$_[0]->isa('JSON::PP')) {
                  my $xs_self = $_[0];
                  my $pp_self = JSON::PP->new;
                  for (@Properties) {
                       my $getter = "get_$_";
                      $pp_self->$_($xs_self->$getter);
                  }
                  $_[0] = $pp_self;
              }
              $pp_method->(@_);
          };
      }
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  }
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
  
  =head1 VERSION
  
      4.02
  
  =head1 DESCRIPTION
  
  This module is a thin wrapper for L<JSON::XS>-compatible modules with a few
  additional features. All the backend modules convert a Perl data structure
  to a JSON text and vice versa. This module uses L<JSON::XS> by default,
  and when JSON::XS is not available, falls back on L<JSON::PP>, which is
  in the Perl core since 5.14. If JSON::PP is not available either, this
  module then falls back on JSON::backportPP (which is actually JSON::PP
  in a different .pm file) bundled in the same distribution as this module.
  You can also explicitly specify to use L<Cpanel::JSON::XS>, a fork of
  JSON::XS by Reini Urban.
  
  All these backend modules have slight incompatibilities between them,
  including extra features that other modules don't support, but as long as you
  use only common features (most important ones are described below), migration
  from backend to backend should be reasonably easy. For details, see each
  backend module you use.
  
  =head1 CHOOSING BACKEND
  
  This module respects an environmental variable called C<PERL_JSON_BACKEND>
  when it decides a backend module to use. If this environmental variable is
  not set, it tries to load JSON::XS, and if JSON::XS is not available, it
  falls back on JSON::PP, and then JSON::backportPP if JSON::PP is not available
  either.
  
  If you always don't want it to fall back on pure perl modules, set the
  variable like this (C<export> may be C<setenv>, C<set> and the likes,
  depending on your environment):
  
    > export PERL_JSON_BACKEND=JSON::XS
  
  If you prefer Cpanel::JSON::XS to JSON::XS, then:
  
    > export PERL_JSON_BACKEND=Cpanel::JSON::XS,JSON::XS,JSON::PP
  
  You may also want to set this variable at the top of your test files, in order
  not to be bothered with incompatibilities between backends (you need to wrap
  this in C<BEGIN>, and set before actually C<use>-ing JSON module, as it decides
  its backend as soon as it's loaded):
  
    BEGIN { $ENV{PERL_JSON_BACKEND}='JSON::backportPP'; }
    use JSON;
  
  =head1 USING OPTIONAL FEATURES
  
  There are a few options you can set when you C<use> this module.
  These historical options are only kept for backward compatibility,
  and should not be used in a new application.
  
  =over
  
  =item -support_by_pp
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     # escape_slash is for JSON::PP only.
     $json->allow_nonref->escape_slash->encode("/");
  
  With this option, this module loads its pure perl backend along with
  its XS backend (if available), and lets the XS backend to watch if you set
  a flag only JSON::PP supports. When you do, the internal JSON::XS object
  is replaced with a newly created JSON::PP object with the setting copied
  from the XS object, so that you can use JSON::PP flags (and its slower
  C<decode>/C<encode> methods) from then on. In other words, this is not
  something that allows you to hook JSON::XS to change its behavior while
  keeping its speed. JSON::XS and JSON::PP objects are quite different
  (JSON::XS object is a blessed scalar reference, while JSON::PP object is
  a blessed hash reference), and can't share their internals.
  
  To avoid needless overhead (by copying settings), you are advised not
  to use this option and just to use JSON::PP explicitly when you need
  JSON::PP features.
  
  =item -convert_blessed_universally
  
     use JSON -convert_blessed_universally;
  
     my $json = JSON->new->allow_nonref->convert_blessed;
     my $object = bless {foo => 'bar'}, 'Foo';
     $json->encode($object); # => {"foo":"bar"}
  
  JSON::XS-compatible backend modules don't encode blessed objects by
  default (except for their boolean values, which are typically blessed
  JSON::PP::Boolean objects). If you need to encode a data structure
  that may contain objects, you usually need to look into the structure
  and replace objects with alternative non-blessed values, or enable
  C<convert_blessed> and provide a C<TO_JSON> method for each object's
  (base) class that may be found in the structure, in order to let the
  methods replace the objects with whatever scalar values the methods
  return.
  
  If you need to serialise data structures that may contain arbitrary
  objects, it's probably better to use other serialisers (such as
  L<Sereal> or L<Storable> for example), but if you do want to use
  this module for that purpose, C<-convert_blessed_universally> option
  may help, which tweaks C<encode> method of the backend to install
  C<UNIVERSAL::TO_JSON> method (locally) before encoding, so that
  all the objects that don't have their own C<TO_JSON> method can
  fall back on the method in the C<UNIVERSAL> namespace. Note that you
  still need to enable C<convert_blessed> flag to actually encode
  objects in a data structure, and C<UNIVERSAL::TO_JSON> method
  installed by this option only converts blessed hash/array references
  into their unblessed clone (including private keys/values that are
  not supposed to be exposed). Other blessed references will be
  converted into null.
  
  This feature is experimental and may be removed in the future.
  
  =item -no_export
  
  When you don't want to import functional interfaces from a module, you
  usually supply C<()> to its C<use> statement.
  
      use JSON (); # no functional interfaces
  
  If you don't want to import functional interfaces, but you also want to
  use any of the above options, add C<-no_export> to the option list.
  
     # no functional interfaces, while JSON::PP support is enabled.
     use JSON -support_by_pp, -no_export;
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS. C<encode_json> and C<decode_json>
  are exported by default.
  
  This module also exports C<to_json> and C<from_json> for backward
  compatibility. These are slower, and may expect/generate different stuff
  from what C<encode_json> and C<decode_json> do, depending on their
  options. It's better just to use Object-Oriented interfaces than using
  these two functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar[, $optional_hashref])
  
  Converts the given Perl data structure to a Unicode string by default.
  Croaks on error.
  
  Basically, this function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Except being slower.
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<to_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
     # => JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text[, $optional_hashref])
  
  The opposite of C<to_json>: expects a Unicode string and tries
  to parse it, returning the resulting reference. Croaks on error.
  
  Basically, this function call is functionally identical to:
  
      $perl_scalar = JSON->new->decode($json_text)
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<from_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
      # => JSON->new->utf8(1)->decode($json_text)
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON->new
  
  Creates a new JSON::XS-compatible backend object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>
  (with the exception of C<allow_nonref>, which defaults to I<enabled> since
  version C<4.0>).
  
  The mutators for flags all return the backend object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in any way. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  Unlike other boolean options, this opotion is enabled by default beginning
  with version C<4.0>.
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_blessed>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 allow_tags (since version 3.0)
  
      $json = $json->allow_tags([$enable])
  
      $enabled = $json->get_allow_tags
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialise the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialise
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =head2 boolean_values (since version 4.0)
  
      $json->boolean_values([$false, $true])
  
      ($false,  $true) = $json->get_boolean_values
  
  By default, JSON booleans will be decoded as overloaded
  C<$JSON::false> and C<$JSON::true> objects.
  
  With this method you can specify your own boolean values for decoding -
  on decode, JSON C<false> will be decoded as a copy of C<$false>, and JSON
  C<true> will be decoded as C<$true> ("copy" here is the same thing as
  assigning a value to another variable, i.e. C<$copy = $false>).
  
  This is useful when you want to pass a decoded data structure directly
  to other serialisers like YAML, Data::MessagePack and so on.
  
  Note that this works only when you C<decode>. You can set incompatible
  boolean objects (like L<boolean>), but when you C<encode> a data structure
  with such boolean objects, you still need to enable C<convert_blessed>
  (and add a C<TO_JSON> method if necessary).
  
  Calling this method without any arguments will reset the booleans
  to their default values.
  
  C<get_boolean_values> will return both C<$false> and C<$true> values, or
  the empty list when they are set to the default.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to
  the newly-created hash. If the code references returns a single scalar
  (which need not be a reference), this value (or rather a copy of it) is
  inserted into the deserialised data structure. If it returns an empty
  list (NOTE: I<not> C<undef>, which is a valid scalar), the original
  deserialised hash will be inserted. This setting can slow down decoding
  considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object(sub { 5 });
     # returns [5]
     $js->decode('[{}]');
     # returns 5
     $js->decode('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 ADDITIONAL METHODS
  
  The following methods are for this module only.
  
  =head2 backend
  
      $backend = $json->backend
  
  Since 2.92, C<backend> method returns an abstract backend module used currently,
  which should be JSON::Backend::XS (which inherits JSON::XS or Cpanel::JSON::XS),
  or JSON::Backend::PP (which inherits JSON::PP), not to monkey-patch the actual
  backend module globally.
  
  If you need to know what is used actually, use C<isa>, instead of string comparison.
  
  =head2 is_xs
  
      $boolean = $json->is_xs
  
  Returns true if the backend inherits JSON::XS or Cpanel::JSON::XS.
  
  =head2 is_pp
  
      $boolean = $json->is_pp
  
  Returns true if the backend inherits JSON::PP.
  
  =head2 property
  
      $settings = $json->property()
  
  Returns a reference to a hash that holds all the common flag settings.
  
      $json = $json->property('utf8' => 1)
      $value = $json->property('utf8') # 1
  
  You can use this to get/set a value of a particular flag.
  
  =head2 boolean
  
      $boolean_object = JSON->boolean($scalar)
  
  Returns $JSON::true if $scalar contains a true value, $JSON::false otherwise.
  You can use this as a full-qualified function (C<JSON::boolean($scalar)>).
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how the backend modules map Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, this module will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, this module only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALISATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. This module can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same data structure will
  serialise to the same JSON text (given same settings and version of
  the same backend), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     encode_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: this module will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Since version 2.91_01, JSON::PP uses a different number detection logic
  that converts a scalar that is possible to turn into a number safely.
  The new logic is slightly faster, and tends to help people who use older
  perl or who want to encode complicated data structure. However, this may
  results in a different JSON text from the one JSON::XS encodes (and
  thus may break tests that compare entire JSON texts). If you do
  need the previous behavior for better compatibility or for finer control,
  set PERL_JSON_PP_USE_B environmental variable to true before you
  C<use> JSON.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  JSON.pm backend modules trust what you pass to C<encode> method
  (or C<encode_json> function) is a clean, validated data structure with
  values that can be represented as valid JSON values only, because it's
  not from an external data source (as opposed to JSON texts you pass to
  C<decode> or C<decode_json>, which JSON backends consider tainted and
  don't trust). As JSON backends don't know exactly what you and consumers
  of your JSON texts want the unexpected values to be (you may want to
  convert them into null, or to stringify them with or without
  normalisation (string representation of infinities/NaN may vary
  depending on platforms), or to croak without conversion), you're advised
  to do what you and your consumers need before you encode, and also not
  to numify values that may start with values that look like a number
  (including infinities/NaN), without validating.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialise the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALISATION
  
  What happens when this module encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_tags> settings, which
  are used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<JSON> creates a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialise, and the second argument being the
  constant string C<JSON> to distinguish it from other serialisers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serialiser) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  this module throws an exception.
  
  =back
  
  =head3 DESERIALISATION
  
  For deserialisation there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialised, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, this module will look up the C<THAW> method
  of the package/classname used during serialisation (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<allow_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serialiser, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 BACKWARD INCOMPATIBILITY
  
  Since version 2.90, stringification (and string comparison) for
  C<JSON::true> and C<JSON::false> has not been overloaded. It shouldn't
  matter as long as you treat them as boolean values, but a code that
  expects they are stringified as "true" or "false" doesn't work as
  you have expected any more.
  
      if (JSON::true eq 'true') {  # now fails
  
      print "The result is $JSON::true now."; # => The result is 1 now.
  
  And now these boolean values don't inherit JSON::Boolean, either.
  When you need to test a value is a JSON boolean value or not, use
  C<JSON::is_bool> function, instead of testing the value inherits
  a particular boolean class or not.
  
  =head1 BUGS
  
  Please report bugs on backend selection and additional features
  this module provides to RT or GitHub issues for this module:
  
  L<https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON>
  
  L<https://github.com/makamaka/JSON/issues>
  
  As for bugs on a specific behavior, please report to the author
  of the backend module you are using.
  
  As for new features and requests to change common behaviors, please
  ask the author of JSON::XS (Marc Lehmann, E<lt>schmorp[at]schmorp.deE<gt>)
  first, by email (important!), to keep compatibility among JSON.pm
  backends.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, L<JSON::PP> for backends.
  
  L<JSON::MaybeXS>, an alternative that prefers Cpanel::JSON::XS.
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  RFC7159 (L<http://www.ietf.org/rfc/rfc7159.txt>)
  
  RFC8259 (L<http://www.ietf.org/rfc/rfc8259.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann E<lt>schmorp[at]schmorp.deE<gt>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  =head1 CURRENT MAINTAINER
  
  Kenichi Ishigaki, E<lt>ishigaki[at]cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  Most of the documentation is taken from JSON::XS by Marc Lehmann
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  
  use Exporter ();
  BEGIN { @JSON::backportPP::ISA = ('Exporter') }
  
  use overload ();
  use JSON::backportPP::Boolean;
  
  use Carp ();
  #use Devel::Peek;
  
  $JSON::backportPP::VERSION = '4.02';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  use constant P_ALLOW_TAGS           => 19;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  use constant USE_B => $ENV{PERL_JSON_PP_USE_B} || 0;
  
  BEGIN {
      if (USE_B) {
          require B;
      }
  }
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
              allow_tags
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enabled?
      # Helper module sets @JSON::PP::_properties.
      if ( OLD_PERL ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $property_id = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent_length => 3,
      };
  
      $self->{PROPS}[P_ALLOW_NONREF] = 1;
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  sub boolean_values {
      my $self = shift;
      if (@_) {
          my ($false, $true) = @_;
          $self->{false} = $false;
          $self->{true} = $true;
          return ($false, $true);
      } else {
          delete $self->{false};
          delete $self->{true};
          return;
      }
  }
  
  sub get_boolean_values {
      my $self = shift;
      if (exists $self->{true} and exists $self->{false}) {
          return @$self{qw/false true/};
      }
      return;
  }
  
  sub filter_json_object {
      if (defined $_[1] and ref $_[1] eq 'CODE') {
          $_[0]->{cb_object} = $_[1];
      } else {
          delete $_[0]->{cb_object};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ == 1 or @_ > 3) {
          Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)");
      }
      if (defined $_[2] and ref $_[2] eq 'CODE') {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      } else {
          delete $_[0]->{cb_sk_object}->{$_[1]};
          delete $_[0]->{cb_sk_object} unless %{$_[0]->{cb_sk_object} || {}};
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");
      $_[0]->allow_bignum;
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
      my $allow_tags;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $props = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed, $allow_tags)
           = @{$props}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED, P_ALLOW_TAGS];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$props->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($props->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $allow_tags and $obj->can('FREEZE') ) {
                      my $obj_class = ref $obj || $obj;
                      $obj = bless $obj, $obj_class;
                      my @results = $obj->FREEZE('JSON');
                      if ( @results and ref $results[0] ) {
                          if ( refaddr( $obj ) eq refaddr( $results[0] ) ) {
                              encode_error( sprintf(
                                  "%s::FREEZE method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
                      return '("'.$obj_class.'")['.join(',', @results).']';
                  }
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
  
                  if ($allow_blessed) {
                      return $self->blessed_to_json($obj) if ($as_nonblessed); # will be removed.
                      return 'null';
                  }
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)", $obj)
                  );
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, $self->string_to_json( $k )
                            .  $del
                            . ( ref $obj->{$k} ? $self->object_to_json( $obj->{$k} ) : $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '{}' unless @res;
          return '{' . $pre . join( ",$pre", @res ) . $post . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, ref($v) ? $self->object_to_json($v) : $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[]' unless @res;
          return '[' . $pre . join( ",$pre", @res ) . $post . ']';
      }
  
      sub _looks_like_number {
          my $value = shift;
          if (USE_B) {
              my $b_obj = B::svref_2object(\$value);
              my $flags = $b_obj->FLAGS;
              return 1 if $flags & ( B::SVp_IOK() | B::SVp_NOK() ) and !( $flags & B::SVp_POK() );
              return;
          } else {
              no warnings 'numeric';
              # if the utf8 flag is on, it almost certainly started as a string
              return if utf8::is_utf8($value);
              # detect numbers
              # string & "" -> ""
              # number & "" -> 0 (with warning)
              # nan and inf can detect as numbers, so check with * 0
              return unless length((my $dummy = "") & $value);
              return unless 0 + $value eq $value;
              return 1 if $value * 0 == 0;
              return -1; # inf/nan
          }
      }
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $type = ref($value);
  
          if (!$type) {
              if (_looks_like_number($value)) {
                  return $value;
              }
              return $self->string_to_json($value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          else {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
              if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                  return 'null';
              }
              else {
                  if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                  }
                  else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                  }
              }
  
          }
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # first character
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bignum;   # using Math::BigInt/BigFloat
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
      my $allow_tags;
  
      my $alt_true;
      my $alt_false;
  
      sub _detect_utf_encoding {
          my $text = shift;
          my @octets = unpack('C4', $text);
          return 'unknown' unless defined $octets[3];
          return ( $octets[0] and  $octets[1]) ? 'UTF-8'
               : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
               : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
               : ( $octets[2]                ) ? 'UTF-16LE'
               : (!$octets[2]                ) ? 'UTF-32LE'
               : 'unknown';
      }
  
      sub PP_decode_json {
          my ($self, $want_offset);
  
          ($self, $text, $want_offset) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $props = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bignum, $allow_barekey, $singlequote, $allow_tags)
              = @{$props}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE, P_ALLOW_TAGS];
  
          ($alt_true, $alt_false) = @$self{qw/true false/};
  
          if ( $utf8 ) {
              $encoding = _detect_utf_encoding($text);
              if ($encoding ne 'UTF-8' and $encoding ne 'unknown') {
                  require Encode;
                  Encode::from_to($text, $encoding, 'utf-8');
              } else {
                  utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
              }
          }
          else {
              utf8::upgrade( $text );
              utf8::encode( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          white(); # remove head white space
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          if ( !$props->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          return ( $result, $consumed ) if $want_offset; # all right if decode_prefix
  
          decode_error("garbage after JSON object") if defined $ch;
  
          $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return tag()    if($ch eq '(');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          my $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          unless( $ch = is_valid_utf8($ch) ) {
                              $at -= 1;
                              decode_error("malformed UTF-8 character in JSON string");
                          }
                          else {
                              $at += $utf8_len - 1;
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              if (!$relaxed or $ch ne "\t") {
                                  $at--;
                                  decode_error('invalid character encountered while parsing JSON string');
                              }
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){
                  next_chr();
              }
              elsif($relaxed and $ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or ] expected while parsing array");
      }
  
      sub tag {
          decode_error('malformed JSON string, neither array, object, number, string or atom') unless $allow_tags;
  
          next_chr();
          white();
  
          my $tag = value();
          return unless defined $tag;
          decode_error('malformed JSON string, (tag) must be a string') if ref $tag;
  
          white();
  
          if (!defined $ch or $ch ne ')') {
              decode_error(') expected after tag');
          }
  
          next_chr();
          white();
  
          my $val = value();
          return unless defined $val;
          decode_error('malformed JSON string, tag value must be an array') unless ref $val eq 'ARRAY';
  
          if (!eval { $tag->can('THAW') }) {
               decode_error('cannot decode perl-object (package does not exist)') if $@;
               decode_error('cannot decode perl-object (package does not have a THAW method)');
          }
          $tag->THAW('JSON', @$val);
      }
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at-- if defined $ch and $ch ne '';
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return defined $alt_true ? $alt_true : $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return defined $alt_false ? $alt_false : $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
          my $is_dec;
          my $is_exp;
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              if($peek =~ /^[0-9a-dfA-DF]/){ # e may be valid (exponential)
                  decode_error("malformed number (leading zero must not be followed by another digit)");
              }
              $n .= $ch;
              next_chr;
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
              $is_dec = 1;
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              $is_exp = 1;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($is_dec or $is_exp) {
              if ($allow_bignum) {
                  require Math::BigFloat;
                  return Math::BigFloat->new($v);
              }
          } else {
              if (length $v > $max_intsize) {
                  if ($allow_bignum) { # from Adam Sussman
                      require Math::BigInt;
                      return Math::BigInt->new($v);
                  }
                  else {
                      return "$v";
                  }
              }
          }
  
          return $is_dec ? $v/1.0 : 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = 'U*';
  
          if ( OLD_PERL ) {
              my $type   =  $] <  5.006           ? 'C*'
                          : utf8::is_utf8( $str ) ? 'U*' # 5.6
                          : 'C*'
                          ;
          }
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 0) {
                  return $o;
              }
              elsif (@val == 1) {
                  return $val[0];
              }
              else {
                  Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar");
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0) {
              return $o;
          }
          elsif (@val == 1) {
              return $val[0];
          }
          else {
              Carp::croak("filter_json_object callbacks must not return more than one scalar");
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( !OLD_PERL ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
          if ($] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
              package # hide from PAUSE
                JSON::PP;
              require subs;
              subs->import('join');
              eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |;
          }
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          require B;
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { blessed $_[0] and ( $_[0]->isa("JSON::PP::Boolean") or $_[0]->isa("Types::Serialiser::BooleanBase") or $_[0]->isa("JSON::XS::Boolean") ); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package # hide from PAUSE
    JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  use constant INCR_M_TFN  => 6;
  use constant INCR_M_NUM  => 7;
  
  $JSON::backportPP::IncrParser::VERSION = '1.01';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_pos     => 0,
          incr_mode    => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
      if ( defined wantarray ) {
          my $max_size = $coder->get_max_size;
          my $p = $self->{incr_pos};
          my @ret;
          {
              do {
                  unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->_incr_parse( $coder );
  
                      if ( $max_size and $self->{incr_pos} > $max_size ) {
                          Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size");
                      }
                      unless ( $self->{incr_nest} <= 0 and $self->{incr_mode} == INCR_M_JSON ) {
                          # as an optimisation, do not accumulate white space in the incr buffer
                          if ( $self->{incr_mode} == INCR_M_WS and $self->{incr_pos} ) {
                              $self->{incr_pos} = 0;
                              $self->{incr_text} = '';
                          }
                          last;
                      }
                  }
  
                  my ($obj, $offset) = $coder->PP_decode_json( $self->{incr_text}, 0x00000001 );
                  push @ret, $obj;
                  use bytes;
                  $self->{incr_text} = substr( $self->{incr_text}, $offset || 0 );
                  $self->{incr_pos} = 0;
                  $self->{incr_nest} = 0;
                  $self->{incr_mode} = 0;
                  last unless wantarray;
              } while ( wantarray );
          }
  
          if ( wantarray ) {
              return @ret;
          }
          else { # in scalar context
              return defined $ret[0] ? $ret[0] : undef;
          }
      }
  }
  
  
  sub _incr_parse {
      my ($self, $coder) = @_;
      my $text = $self->{incr_text};
      my $len = length $text;
      my $p = $self->{incr_pos};
  
  INCR_PARSE:
      while ( $len > $p ) {
          my $s = substr( $text, $p, 1 );
          last INCR_PARSE unless defined $s;
          my $mode = $self->{incr_mode};
  
          if ( $mode == INCR_M_WS ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( ord($s) > 0x20 ) {
                      if ( $s eq '#' ) {
                          $self->{incr_mode} = INCR_M_C0;
                          redo INCR_PARSE;
                      } else {
                          $self->{incr_mode} = INCR_M_JSON;
                          redo INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_BS ) {
              $p++;
              $self->{incr_mode} = INCR_M_STR;
              redo INCR_PARSE;
          } elsif ( $mode == INCR_M_C0 or $mode == INCR_M_C1 ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq "\n" ) {
                      $self->{incr_mode} = $self->{incr_mode} == INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;
                      last;
                  }
                  $p++;
              }
              next;
          } elsif ( $mode == INCR_M_TFN ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p++, 1 );
                  next if defined $s and $s =~ /[rueals]/;
                  last;
              }
              $p--;
              $self->{incr_mode} = INCR_M_JSON;
  
              last INCR_PARSE unless $self->{incr_nest};
              redo INCR_PARSE;
          } elsif ( $mode == INCR_M_NUM ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p++, 1 );
                  next if defined $s and $s =~ /[0-9eE.+\-]/;
                  last;
              }
              $p--;
              $self->{incr_mode} = INCR_M_JSON;
  
              last INCR_PARSE unless $self->{incr_nest};
              redo INCR_PARSE;
          } elsif ( $mode == INCR_M_STR ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p, 1 );
                  last INCR_PARSE unless defined $s;
                  if ( $s eq '"' ) {
                      $p++;
                      $self->{incr_mode} = INCR_M_JSON;
  
                      last INCR_PARSE unless $self->{incr_nest};
                      redo INCR_PARSE;
                  }
                  elsif ( $s eq '\\' ) {
                      $p++;
                      if ( !defined substr($text, $p, 1) ) {
                          $self->{incr_mode} = INCR_M_BS;
                          last INCR_PARSE;
                      }
                  }
                  $p++;
              }
          } elsif ( $mode == INCR_M_JSON ) {
              while ( $len > $p ) {
                  $s = substr( $text, $p++, 1 );
                  if ( $s eq "\x00" ) {
                      $p--;
                      last INCR_PARSE;
                  } elsif ( $s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20" ) {
                      if ( !$self->{incr_nest} ) {
                          $p--; # do not eat the whitespace, let the next round do it
                          last INCR_PARSE;
                      }
                      next;
                  } elsif ( $s eq 't' or $s eq 'f' or $s eq 'n' ) {
                      $self->{incr_mode} = INCR_M_TFN;
                      redo INCR_PARSE;
                  } elsif ( $s =~ /^[0-9\-]$/ ) {
                      $self->{incr_mode} = INCR_M_NUM;
                      redo INCR_PARSE;
                  } elsif ( $s eq '"' ) {
                      $self->{incr_mode} = INCR_M_STR;
                      redo INCR_PARSE;
                  } elsif ( $s eq '[' or $s eq '{' ) {
                      if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                          Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                      }
                      next;
                  } elsif ( $s eq ']' or $s eq '}' ) {
                      if ( --$self->{incr_nest} <= 0 ) {
                          last INCR_PARSE;
                      }
                  } elsif ( $s eq '#' ) {
                      $self->{incr_mode} = INCR_M_C1;
                      redo INCR_PARSE;
                  }
              }
          }
      }
  
      $self->{incr_pos} = $p;
      $self->{incr_parsing} = $p ? 1 : 0; # for backward compatibility
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_pos} ) {
          Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_pos} );
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_pos}     = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $json = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $pretty_printed_json_text = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      4.02
  
  =head1 DESCRIPTION
  
  JSON::PP is a pure perl JSON decoder/encoder, and (almost) compatible to much
  faster L<JSON::XS> written by Marc Lehmann in C. JSON::PP works as
  a fallback module when you use L<JSON> module without having
  installed JSON::XS.
  
  Because of this fallback feature of JSON.pm, JSON::PP tries not to
  be more JavaScript-friendly than JSON::XS (i.e. not to escape extra
  characters such as U+2028 and U+2029, etc),
  in order for you not to lose such JavaScript-friendliness silently
  when you use JSON.pm and install JSON::XS for speed or by accident.
  If you need JavaScript-friendly RFC7159-compliant pure perl module,
  try L<JSON::Tiny>, which is derived from L<Mojolicious> web
  framework and is also smaller and faster than JSON::PP.
  
  JSON::PP has been in the Perl core since Perl 5.14, mainly for
  CPAN toolchain modules to parse META.json.
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS almost verbatim. C<encode_json>
  and C<decode_json> are exported by default.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Creates a new JSON::PP object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>
  (with the exception of C<allow_nonref>, which defaults to I<enabled> since
  version C<4.0>).
  
  The mutators for flags all return the JSON::PP object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::PP->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =item * C-style multiple-line '/* */'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C-style multiple-line comments are additionally
  allowed. Everything between C</*> and C<*/> is a comment, after which
  more white-space and comments are allowed.
  
    [
       1, /* this comment not allowed in JSON */
          /* neither this one... */
    ]
  
  =item * C++-style one-line '//'-comments (JSON::PP only)
  
  Whenever JSON allows whitespace, C++-style one-line comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, // this comment not allowed in JSON
          // neither this one...
    ]
  
  =item * literal ASCII TAB characters in strings
  
  Literal ASCII TAB characters are now allowed in strings (and treated as
  C<\t>).
  
    [
       "Hello\tWorld",
       "Hello<TAB>World", # literal <TAB> would not normally be allowed
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  Unlike other boolean options, this opotion is enabled by default beginning
  with version C<4.0>.
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value without enabled C<allow_nonref>,
  resulting in an error:
  
     JSON::PP->new->allow_nonref(0)->encode ("Hello, World!")
     => hash- or arrayref expected...
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_blessed>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 allow_tags
  
      $json = $json->allow_tags([$enable])
  
      $enabled = $json->get_allow_tags
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialise the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialise
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =head2 boolean_values
  
      $json->boolean_values([$false, $true])
  
      ($false,  $true) = $json->get_boolean_values
  
  By default, JSON booleans will be decoded as overloaded
  C<$JSON::PP::false> and C<$JSON::PP::true> objects.
  
  With this method you can specify your own boolean values for decoding -
  on decode, JSON C<false> will be decoded as a copy of C<$false>, and JSON
  C<true> will be decoded as C<$true> ("copy" here is the same thing as
  assigning a value to another variable, i.e. C<$copy = $false>).
  
  This is useful when you want to pass a decoded data structure directly
  to other serialisers like YAML, Data::MessagePack and so on.
  
  Note that this works only when you C<decode>. You can set incompatible
  boolean objects (like L<boolean>), but when you C<encode> a data structure
  with such boolean objects, you still need to enable C<convert_blessed>
  (and add a C<TO_JSON> method if necessary).
  
  Calling this method without any arguments will reset the booleans
  to their default values.
  
  C<get_boolean_values> will return both C<$false> and C<$true> values, or
  the empty list when they are set to the default.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to
  the newly-created hash. If the code references returns a single scalar
  (which need not be a reference), this value (or rather a copy of it) is
  inserted into the deserialised data structure. If it returns an empty
  list (NOTE: I<not> C<undef>, which is a valid scalar), the original
  deserialised hash will be inserted. This setting can slow down decoding
  considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object(sub { 5 });
     # returns [5]
     $js->decode('[{}]');
     # returns 5
     $js->decode('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk (i.e. downgraded if possible).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is false, then JSON::PP does nothing.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON::PP->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 FLAGS FOR JSON::PP ONLY
  
  The following flags and properties are for JSON::PP only. If you use
  any of these, you can't make your application run faster by replacing
  JSON::PP with JSON::XS. If you need these and also speed boost,
  you might want to try L<Cpanel::JSON::XS>, a fork of JSON::XS by
  Reini Urban, which supports some of these (with a different set of
  incompatibilities). Most of these historical flags are only kept
  for backward compatibility, and should not be used in a new application.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
      $enabled = $json->get_allow_singlequote
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain strings that begin and end with
  single quotation marks. C<encode> will not be affected in any way.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_singlequote->decode(qq|{"foo":'bar'}|);
      $json->allow_singlequote->decode(qq|{'foo':"bar"}|);
      $json->allow_singlequote->decode(qq|{'foo':'bar'}|);
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
      $enabled = $json->get_allow_barekey
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain JSON objects whose names don't
  begin and end with quotation marks. C<encode> will not be affected
  in any way. I<Be aware that this option makes you accept invalid JSON
  texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->allow_barekey->decode(qq|{foo:"bar"}|);
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
      $enabled = $json->get_allow_bignum
  
  If C<$enable> is true (or missing), then C<decode> will convert
  big integers Perl cannot handle as integer into L<Math::BigInt>
  objects and convert floating numbers into L<Math::BigFloat>
  objects. C<encode> will convert C<Math::BigInt> and C<Math::BigFloat>
  objects into JSON numbers.
  
     $json->allow_nonref->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See also L<MAPPING>.
  
  =head2 loose
  
      $json = $json->loose([$enable])
      $enabled = $json->get_loose
  
  If C<$enable> is true (or missing), then C<decode> will accept
  invalid JSON texts that contain unescaped [\x00-\x1f\x22\x5c]
  characters. C<encode> will not be affected in any way.
  I<Be aware that this option makes you accept invalid JSON texts
  as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration
  files, resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
      $enabled = $json->get_escape_slash
  
  If C<$enable> is true (or missing), then C<encode> will explicitly
  escape I<slash> (solidus; C<U+002F>) characters to reduce the risk of
  XSS (cross site scripting) that may be caused by C<< </script> >>
  in a JSON text, with the cost of bloating the size of JSON texts.
  
  This option may be useful when you embed JSON in HTML, but embedding
  arbitrary JSON in HTML (by some HTML template toolkit or by string
  interpolation) is risky in general. You must escape necessary
  characters in correct order, depending on the context.
  
  C<decode> will not be affected in any way.
  
  =head2 indent_length
  
      $json = $json->indent_length($number_of_spaces)
      $length = $json->get_indent_length
  
  This option is only useful when you also enable C<indent> or C<pretty>.
  
  JSON::XS indents with three spaces when you C<encode> (if requested
  by C<indent> or C<pretty>), and the number cannot be changed.
  JSON::PP allows you to change/get the number of indent spaces with these
  mutator/accessor. The default number of spaces is three (the same as
  JSON::XS), and the acceptable range is from C<0> (no indentation;
  it'd be better to disable indentation by C<indent(0)>) to C<15>.
  
  =head2 sort_by
  
      $json = $json->sort_by($code_ref)
      $json = $json->sort_by($subroutine_name)
  
  If you just want to sort keys (names) in JSON objects when you
  C<encode>, enable C<canonical> option (see above) that allows you to
  sort object keys alphabetically.
  
  If you do need to sort non-alphabetically for whatever reasons,
  you can give a code reference (or a subroutine name) to C<sort_by>,
  then the argument will be passed to Perl's C<sort> built-in function.
  
  As the sorting is done in the JSON::PP scope, you usually need to
  prepend C<JSON::PP::> to the subroutine name, and the special variables
  C<$a> and C<$b> used in the subrontine used by C<sort> function.
  
  Example:
  
     my %ORDER = (id => 1, class => 2, name => 3);
     $json->sort_by(sub {
         ($ORDER{$JSON::PP::a} // 999) <=> ($ORDER{$JSON::PP::b} // 999)
         or $JSON::PP::a cmp $JSON::PP::b
     });
     print $json->encode([
         {name => 'CPAN', id => 1, href => 'http://cpan.org'}
     ]);
     # [{"id":1,"name":"CPAN","href":"http://cpan.org"}]
  
  Note that C<sort_by> affects all the plain hashes in the data structure.
  If you need finer control, C<tie> necessary hashes with a module that
  implements ordered hash (such as L<Hash::Ordered> and L<Tie::IxHash>).
  C<canonical> and C<sort_by> don't affect the key order in C<tie>d
  hashes.
  
     use Hash::Ordered;
     tie my %hash, 'Hash::Ordered',
         (name => 'CPAN', id => 1, href => 'http://cpan.org');
     print $json->encode([\%hash]);
     # [{"name":"CPAN","id":1,"href":"http://cpan.org"}] # order is kept
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::PP will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON::PP->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how JSON::PP maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::PP will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::PP only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enabled, big integer values and any numeric
  values will be converted into L<Math::BigInt> and L<Math::BigFloat>
  objects respectively, without becoming string scalars or losing
  precision.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::PP::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALISATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. JSON::PP can optionally sort the hash keys
  (determined by the I<canonical> flag and/or I<sort_by> property), so
  the same data structure will serialise to the same JSON text (given
  same settings and version of JSON::PP), but this incurs a runtime
  overhead and is only rarely useful, e.g. when you want to compare some
  JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::PP::false> and C<JSON::PP::true> to improve
  readability.
  
     to_json [\0, JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item JSON::PP::null
  
  This special value becomes JSON null.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::PP>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a JSON string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
                  # (but for older perls)
  
  You can force the type to be a JSON number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Since version 2.91_01, JSON::PP uses a different number detection logic
  that converts a scalar that is possible to turn into a number safely.
  The new logic is slightly faster, and tends to help people who use older
  perl or who want to encode complicated data structure. However, this may
  results in a different JSON text from the one JSON::XS encodes (and
  thus may break tests that compare entire JSON texts). If you do
  need the previous behavior for compatibility or for finer control,
  set PERL_JSON_PP_USE_B environmental variable to true before you
  C<use> JSON::PP (or JSON.pm).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  JSON::PP (and JSON::XS) trusts what you pass to C<encode> method
  (or C<encode_json> function) is a clean, validated data structure with
  values that can be represented as valid JSON values only, because it's
  not from an external data source (as opposed to JSON texts you pass to
  C<decode> or C<decode_json>, which JSON::PP considers tainted and
  doesn't trust). As JSON::PP doesn't know exactly what you and consumers
  of your JSON texts want the unexpected values to be (you may want to
  convert them into null, or to stringify them with or without
  normalisation (string representation of infinities/NaN may vary
  depending on platforms), or to croak without conversion), you're advised
  to do what you and your consumers need before you encode, and also not
  to numify values that may start with values that look like a number
  (including infinities/NaN), without validating.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialise the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALISATION
  
  What happens when C<JSON::PP> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed>, C<allow_tags> and C<allow_bignum>
  settings, which are used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<JSON::PP> creates a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialise, and the second argument being the
  constant string C<JSON> to distinguish it from other serialisers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serialiser) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 3. C<allow_bignum> is enabled and the object is a C<Math::BigInt> or C<Math::BigFloat>.
  
  The object will be serialised as a JSON number value.
  
  =item 4. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 5. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<JSON::PP> throws an exception.
  
  =back
  
  =head3 DESERIALISATION
  
  For deserialisation there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialised, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, C<JSON::PP> will look up the C<THAW> method
  of the package/classname used during serialisation (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<allow_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serialiser, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 BUGS
  
  Please report bugs on a specific behavior of this module to RT or GitHub
  issues (preferred):
  
  L<https://github.com/makamaka/JSON-PP/issues>
  
  L<https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON-PP>
  
  As for new features and requests to change common behaviors, please
  ask the author of JSON::XS (Marc Lehmann, E<lt>schmorp[at]schmorp.deE<gt>)
  first, by email (important!), to keep compatibility among JSON.pm backends.
  
  Generally speaking, if you need something special for you, you are advised
  to create a new module, maybe based on L<JSON::Tiny>, which is smaller and
  written in a much cleaner way than this module.
  
  =head1 SEE ALSO
  
  The F<json_pp> command line utility for quick experiments.
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, and L<JSON::Tiny> for faster alternatives.
  L<JSON> and L<JSON::MaybeXS> for easy migration.
  
  L<JSON::backportPP::Compat5005> and L<JSON::backportPP::Compat5006> for older perl users.
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  RFC7159 (L<http://www.ietf.org/rfc/rfc7159.txt>)
  
  RFC8259 (L<http://www.ietf.org/rfc/rfc8259.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  =head1 CURRENT MAINTAINER
  
  Kenichi Ishigaki, E<lt>ishigaki[at]cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2016 by Makamaka Hannyaharamitu
  
  Most of the documentation is taken from JSON::XS by Marc Lehmann
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  package # This is JSON::backportPP
      JSON::PP::Boolean;
  
  use strict;
  require overload;
  local $^W;
  overload::import('overload',
      "0+"     => sub { ${$_[0]} },
      "++"     => sub { $_[0] = ${$_[0]} + 1 },
      "--"     => sub { $_[0] = ${$_[0]} - 1 },
      fallback => 1,
  );
  
  $JSON::backportPP::Boolean::VERSION = '4.02';
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"Test/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER';
  package Test::Builder;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN {
      if( $] < 5.008 ) {
          require Test::Builder::IO::Scalar;
      }
  }
  
  use Scalar::Util qw/blessed reftype weaken/;
  
  use Test2::Util qw/USE_THREADS try get_tid/;
  use Test2::API qw/context release/;
  # Make Test::Builder thread-safe for ithreads.
  BEGIN {
      warn "Test::Builder was loaded after Test2 initialization, this is not recommended."
          if Test2::API::test2_init_done() || Test2::API::test2_load_done();
  
      if (USE_THREADS && ! Test2::API::test2_ipc_disabled()) {
          require Test2::IPC;
          require Test2::IPC::Driver::Files;
          Test2::IPC::Driver::Files->import;
          Test2::API::test2_ipc_enable_polling();
          Test2::API::test2_no_wait(1);
          Test2::API::test2_ipc_enable_shm();
      }
  }
  
  use Test2::Event::Subtest;
  use Test2::Hub::Subtest;
  
  use Test::Builder::Formatter;
  use Test::Builder::TodoDiag;
  
  our $Level = 1;
  our $Test = $ENV{TB_NO_EARLY_INIT} ? undef : Test::Builder->new;
  
  sub _add_ts_hooks {
      my $self = shift;
  
      my $hub = $self->{Stack}->top;
  
      # Take a reference to the hash key, we do this to avoid closing over $self
      # which is the singleton. We use a reference because the value could change
      # in rare cases.
      my $epkgr = \$self->{Exported_To};
  
      #$hub->add_context_aquire(sub {$_[0]->{level} += $Level - 1});
  
      $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          my $epkg = $$epkgr;
          my $cpkg = $e->{trace} ? $e->{trace}->{frame}->[0] : undef;
  
          no strict 'refs';
          no warnings 'once';
          my $todo;
          $todo = ${"$cpkg\::TODO"} if $cpkg;
          $todo = ${"$epkg\::TODO"} if $epkg && !$todo;
  
          return $e unless $todo;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          if ($active_hub == $hub) {
              $e->set_todo($todo) if $e->can('set_todo');
              $e->add_amnesty({tag => 'TODO', details => $todo});
          }
          else {
              $e->add_amnesty({tag => 'TODO', details => $todo, inherited => 1});
          }
  
          # Set todo on ok's
          if ($e->isa('Test2::Event::Ok')) {
              $e->set_effective_pass(1);
  
              if (my $result = $e->get_meta(__PACKAGE__)) {
                  $result->{reason} ||= $todo;
                  $result->{type}   ||= 'todo';
                  $result->{ok}       = 1;
              }
          }
  
          return $e;
      }, inherit => 1);
  }
  
  {
      no warnings;
      INIT {
          use warnings;
          Test2::API::test2_load() unless Test2::API::test2_in_preload();
      }
  }
  
  sub new {
      my($class) = shift;
      unless($Test) {
          $Test = $class->create(singleton => 1);
  
          Test2::API::test2_add_callback_post_load(
              sub {
                  $Test->{Original_Pid} = $$ if !$Test->{Original_Pid} || $Test->{Original_Pid} == 0;
                  $Test->reset(singleton => 1);
                  $Test->_add_ts_hooks;
              }
          );
  
          # Non-TB tools normally expect 0 added to the level. $Level is normally 1. So
          # we only want the level to change if $Level != 1.
          # TB->ctx compensates for this later.
          Test2::API::test2_add_callback_context_aquire(sub { $_[0]->{level} += $Level - 1 });
  
          Test2::API::test2_add_callback_exit(sub { $Test->_ending(@_) });
  
          Test2::API::test2_ipc()->set_no_fatal(1) if Test2::API::test2_has_ipc();
      }
      return $Test;
  }
  
  sub create {
      my $class = shift;
      my %params = @_;
  
      my $self = bless {}, $class;
      if ($params{singleton}) {
          $self->{Stack} = Test2::API::test2_stack();
      }
      else {
          $self->{Stack} = Test2::API::Stack->new;
          $self->{Stack}->new_hub(
              formatter => Test::Builder::Formatter->new,
              ipc       => Test2::API::test2_ipc(),
          );
  
          $self->reset(%params);
          $self->_add_ts_hooks;
      }
  
      return $self;
  }
  
  sub ctx {
      my $self = shift;
      context(
          # 1 for our frame, another for the -1 off of $Level in our hook at the top.
          level   => 2,
          fudge   => 1,
          stack   => $self->{Stack},
          hub     => $self->{Hub},
          wrapped => 1,
          @_
      );
  }
  
  sub parent {
      my $self = shift;
      my $ctx = $self->ctx;
      my $chub = $self->{Hub} || $ctx->hub;
      $ctx->release;
  
      my $meta = $chub->meta(__PACKAGE__, {});
      my $parent = $meta->{parent};
  
      return undef unless $parent;
  
      return bless {
          Original_Pid => $$,
          Stack => $self->{Stack},
          Hub => $parent,
      }, blessed($self);
  }
  
  sub child {
      my( $self, $name ) = @_;
  
      $name ||= "Child of " . $self->name;
      my $ctx = $self->ctx;
  
      my $parent = $ctx->hub;
      my $pmeta = $parent->meta(__PACKAGE__, {});
      $self->croak("You already have a child named ($pmeta->{child}) running")
          if $pmeta->{child};
  
      $pmeta->{child} = $name;
  
      # Clear $TODO for the child.
      my $orig_TODO = $self->find_TODO(undef, 1, undef);
  
      my $subevents = [];
  
      my $hub = $ctx->stack->new_hub(
          class => 'Test2::Hub::Subtest',
      );
  
      $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          return $e;
      }, inherit => 1) if $orig_TODO;
  
      $hub->listen(sub { push @$subevents => $_[1] });
  
      $hub->set_nested( $parent->nested + 1 );
  
      my $meta = $hub->meta(__PACKAGE__, {});
      $meta->{Name} = $name;
      $meta->{TODO} = $orig_TODO;
      $meta->{TODO_PKG} = $ctx->trace->package;
      $meta->{parent} = $parent;
      $meta->{Test_Results} = [];
      $meta->{subevents} = $subevents;
      $meta->{subtest_id} = $hub->id;
      $meta->{subtest_uuid} = $hub->uuid;
      $meta->{subtest_buffered} = $parent->format ? 0 : 1;
  
      $self->_add_ts_hooks;
  
      $ctx->release;
      return bless { Original_Pid => $$, Stack => $self->{Stack}, Hub => $hub, no_log_results => $self->{no_log_results} }, blessed($self);
  }
  
  sub finalize {
      my $self = shift;
      my $ok = 1;
      ($ok) = @_ if @_;
  
      my $st_ctx = $self->ctx;
      my $chub = $self->{Hub} || return $st_ctx->release;
  
      my $meta = $chub->meta(__PACKAGE__, {});
      if ($meta->{child}) {
          $self->croak("Can't call finalize() with child ($meta->{child}) active");
      }
  
      local $? = 0;     # don't fail if $subtests happened to set $? nonzero
  
      $self->{Stack}->pop($chub);
  
      $self->find_TODO($meta->{TODO_PKG}, 1, $meta->{TODO});
  
      my $parent = $self->parent;
      my $ctx = $parent->ctx;
      my $trace = $ctx->trace;
      delete $ctx->hub->meta(__PACKAGE__, {})->{child};
  
      $chub->finalize($trace->snapshot(hid => $chub->hid, nested => $chub->nested), 1)
          if $ok
          && $chub->count
          && !$chub->no_ending
          && !$chub->ended;
  
      my $plan   = $chub->plan || 0;
      my $count  = $chub->count;
      my $failed = $chub->failed;
      my $passed = $chub->is_passing;
  
      my $num_extra = $plan =~ m/\D/ ? 0 : $count - $plan;
      if ($count && $num_extra != 0) {
          my $s = $plan == 1 ? '' : 's';
          $st_ctx->diag(<<"FAIL");
  Looks like you planned $plan test$s but ran $count.
  FAIL
      }
  
      if ($failed) {
          my $s = $failed == 1 ? '' : 's';
  
          my $qualifier = $num_extra == 0 ? '' : ' run';
  
          $st_ctx->diag(<<"FAIL");
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
      }
  
      if (!$passed && !$failed && $count && !$num_extra) {
          $st_ctx->diag(<<"FAIL");
  All assertions inside the subtest passed, but errors were encountered.
  FAIL
      }
  
      $st_ctx->release;
  
      unless ($chub->bailed_out) {
          my $plan = $chub->plan;
          if ( $plan && $plan eq 'SKIP' ) {
              $parent->skip($chub->skip_reason, $meta->{Name});
          }
          elsif ( !$chub->count ) {
              $parent->ok( 0, sprintf q[No tests run for subtest "%s"], $meta->{Name} );
          }
          else {
              $parent->{subevents}  = $meta->{subevents};
              $parent->{subtest_id} = $meta->{subtest_id};
              $parent->{subtest_uuid} = $meta->{subtest_uuid};
              $parent->{subtest_buffered} = $meta->{subtest_buffered};
              $parent->ok( $chub->is_passing, $meta->{Name} );
          }
      }
  
      $ctx->release;
      return $chub->is_passing;
  }
  
  sub subtest {
      my $self = shift;
      my ($name, $code, @args) = @_;
      my $ctx = $self->ctx;
      $ctx->throw("subtest()'s second argument must be a code ref")
          unless $code && reftype($code) eq 'CODE';
  
      $name ||= "Child of " . $self->name;
  
  
      $_->($name,$code,@args)
          for Test2::API::test2_list_pre_subtest_callbacks();
  
      $ctx->note("Subtest: $name");
  
      my $child = $self->child($name);
  
      my $start_pid = $$;
      my $st_ctx;
      my ($ok, $err, $finished, $child_error);
      T2_SUBTEST_WRAPPER: {
          my $ctx = $self->ctx;
          $st_ctx = $ctx->snapshot;
          $ctx->release;
          $ok = eval { local $Level = 1; $code->(@args); 1 };
          ($err, $child_error) = ($@, $?);
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && blessed($err) eq 'Test::Builder::Exception')) {
              $ok  = undef;
              $err = undef;
          }
          else {
              $finished = 1;
          }
      }
  
      if ($start_pid != $$ && !$INC{'Test2/IPC.pm'}) {
          warn $ok ? "Forked inside subtest, but subtest never finished!\n" : $err;
          exit 255;
      }
  
      my $trace = $ctx->trace;
  
      if (!$finished) {
          if(my $bailed = $st_ctx->hub->bailed_out) {
              my $chub = $child->{Hub};
              $self->{Stack}->pop($chub);
              $ctx->bail($bailed->reason);
          }
          my $code = $st_ctx->hub->exit_code;
          $ok = !$code;
          $err = "Subtest ended with exit code $code" if $code;
      }
  
      my $st_hub  = $st_ctx->hub;
      my $plan  = $st_hub->plan;
      my $count = $st_hub->count;
  
      if (!$count && (!defined($plan) || "$plan" ne 'SKIP')) {
          $st_ctx->plan(0) unless defined $plan;
          $st_ctx->diag('No tests run!');
      }
  
      $child->finalize($st_ctx->trace);
  
      $ctx->release;
  
      die $err unless $ok;
  
      $? = $child_error if defined $child_error;
  
      return $st_hub->is_passing;
  }
  
  sub name {
      my $self = shift;
      my $ctx = $self->ctx;
      release $ctx, $ctx->hub->meta(__PACKAGE__, {})->{Name};
  }
  
  sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my ($self, %params) = @_;
  
      Test2::API::test2_set_is_end(0);
  
      # We leave this a global because it has to be localized and localizing
      # hash keys is just asking for pain.  Also, it was documented.
      $Level = 1;
  
      $self->{no_log_results} = $ENV{TEST_NO_LOG_RESULTS} ? 1 : 0
          unless $params{singleton};
  
      $self->{Original_Pid} = Test2::API::test2_in_preload() ? -1 : $$;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
      $ctx->release;
      unless ($params{singleton}) {
          $hub->reset_state();
          $hub->_tb_reset();
      }
  
      $ctx = $self->ctx;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {});
      %$meta = (
          Name         => $0,
          Ending       => 0,
          Done_Testing => undef,
          Skip_All     => 0,
          Test_Results => [],
          parent       => $meta->{parent},
      );
  
      $self->{Exported_To} = undef unless $params{singleton};
  
      $self->{Orig_Handles} ||= do {
          my $format = $ctx->hub->format;
          my $out;
          if ($format && $format->isa('Test2::Formatter::TAP')) {
              $out = $format->handles;
          }
          $out ? [@$out] : [];
      };
  
      $self->use_numbers(1);
      $self->no_header(0) unless $params{singleton};
      $self->no_ending(0) unless $params{singleton};
      $self->reset_outputs;
  
      $ctx->release;
  
      return;
  }
  
  
  my %plan_cmds = (
      no_plan  => \&no_plan,
      skip_all => \&skip_all,
      tests    => \&_plan_tests,
  );
  
  sub plan {
      my( $self, $cmd, $arg ) = @_;
  
      return unless $cmd;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      $ctx->throw("You tried to plan twice") if $hub->plan;
  
      local $Level = $Level + 1;
  
      if( my $method = $plan_cmds{$cmd} ) {
          local $Level = $Level + 1;
          $self->$method($arg);
      }
      else {
          my @args = grep { defined } ( $cmd, $arg );
          $ctx->throw("plan() doesn't understand @args");
      }
  
      release $ctx, 1;
  }
  
  
  sub _plan_tests {
      my($self, $arg) = @_;
  
      my $ctx = $self->ctx;
  
      if($arg) {
          local $Level = $Level + 1;
          $self->expected_tests($arg);
      }
      elsif( !defined $arg ) {
          $ctx->throw("Got an undefined number of tests");
      }
      else {
          $ctx->throw("You said to run 0 tests");
      }
  
      $ctx->release;
  }
  
  
  sub expected_tests {
      my $self = shift;
      my($max) = @_;
  
      my $ctx = $self->ctx;
  
      if(@_) {
          $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
            unless $max =~ /^\+?\d+$/;
  
          $ctx->plan($max);
      }
  
      my $hub = $ctx->hub;
  
      $ctx->release;
  
      my $plan = $hub->plan;
      return 0 unless $plan;
      return 0 if $plan =~ m/\D/;
      return $plan;
  }
  
  
  sub no_plan {
      my($self, $arg) = @_;
  
      my $ctx = $self->ctx;
  
      if (defined $ctx->hub->plan) {
          warn "Plan already set, no_plan() is a no-op, this will change to a hard failure in the future.";
          $ctx->release;
          return;
      }
  
      $ctx->alert("no_plan takes no arguments") if $arg;
  
      $ctx->hub->plan('NO PLAN');
  
      release $ctx, 1;
  }
  
  
  sub done_testing {
      my($self, $num_tests) = @_;
  
      my $ctx = $self->ctx;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {});
  
      if ($meta->{Done_Testing}) {
          my ($file, $line) = @{$meta->{Done_Testing}}[1,2];
          local $ctx->hub->{ended}; # OMG This is awful.
          $self->ok(0, "done_testing() was already called at $file line $line");
          $ctx->release;
          return;
      }
      $meta->{Done_Testing} = [$ctx->trace->call];
  
      my $plan = $ctx->hub->plan;
      my $count = $ctx->hub->count;
  
      # If done_testing() specified the number of tests, shut off no_plan
      if( defined $num_tests ) {
          $ctx->plan($num_tests) if !$plan || $plan eq 'NO PLAN';
      }
      elsif ($count && defined $num_tests && $count != $num_tests) {
          $self->ok(0, "planned to run @{[ $self->expected_tests ]} but done_testing() expects $num_tests");
      }
      else {
          $num_tests = $self->current_test;
      }
  
      if( $self->expected_tests && $num_tests != $self->expected_tests ) {
          $self->ok(0, "planned to run @{[ $self->expected_tests ]} ".
                       "but done_testing() expects $num_tests");
      }
  
      $ctx->plan($num_tests) if $ctx->hub->plan && $ctx->hub->plan eq 'NO PLAN';
  
      $ctx->hub->finalize($ctx->trace, 1);
  
      release $ctx, 1;
  }
  
  
  sub has_plan {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $plan = $ctx->hub->plan;
      $ctx->release;
  
      return( $plan ) if $plan && $plan !~ m/\D/;
      return('no_plan') if $plan && $plan eq 'NO PLAN';
      return(undef);
  }
  
  
  sub skip_all {
      my( $self, $reason ) = @_;
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Skip_All} = $reason || 1;
  
      # Work around old perl bug
      if ($] < 5.020000) {
          my $begin = 0;
          my $level = 0;
          while (my @call = caller($level++)) {
              last unless @call && $call[0];
              next unless $call[3] =~ m/::BEGIN$/;
              $begin++;
              last;
          }
          # HACK!
          die 'Label not found for "last T2_SUBTEST_WRAPPER"' if $begin && $ctx->hub->meta(__PACKAGE__, {})->{parent};
      }
  
      $ctx->plan(0, SKIP => $reason);
  }
  
  
  sub exported_to {
      my( $self, $pack ) = @_;
  
      if( defined $pack ) {
          $self->{Exported_To} = $pack;
      }
      return $self->{Exported_To};
  }
  
  
  sub ok {
      my( $self, $test, $name ) = @_;
  
      my $ctx = $self->ctx;
  
      # $test might contain an object which we don't want to accidentally
      # store, so we turn it into a boolean.
      $test = $test ? 1 : 0;
  
      # In case $name is a string overloaded object, force it to stringify.
      no  warnings qw/uninitialized numeric/;
      $name = "$name" if defined $name;
  
      # Profiling showed that the regex here was a huge time waster, doing the
      # numeric addition first cuts our profile time from ~300ms to ~50ms
      $self->diag(<<"    ERR") if 0 + $name && $name =~ /^[\d\s]+$/;
      You named your test '$name'.  You shouldn't use numbers for your test names.
      Very confusing.
      ERR
      use warnings qw/uninitialized numeric/;
  
      my $trace = $ctx->{trace};
      my $hub   = $ctx->{hub};
  
      my $result = {
          ok => $test,
          actual_ok => $test,
          reason => '',
          type => '',
          (name => defined($name) ? $name : ''),
      };
  
      $hub->{_meta}->{+__PACKAGE__}->{Test_Results}[ $hub->{count} ] = $result unless $self->{no_log_results};
  
      my $orig_name = $name;
  
      my @attrs;
      my $subevents  = delete $self->{subevents};
      my $subtest_id = delete $self->{subtest_id};
      my $subtest_uuid = delete $self->{subtest_uuid};
      my $subtest_buffered = delete $self->{subtest_buffered};
      my $epkg = 'Test2::Event::Ok';
      if ($subevents) {
          $epkg = 'Test2::Event::Subtest';
          push @attrs => (subevents => $subevents, subtest_id => $subtest_id, subtest_uuid => $subtest_uuid, buffered => $subtest_buffered);
      }
  
      my $e = bless {
          trace => bless( {%$trace}, 'Test2::EventFacet::Trace'),
          pass  => $test,
          name  => $name,
          _meta => {'Test::Builder' => $result},
          effective_pass => $test,
          @attrs,
      }, $epkg;
      $hub->send($e);
  
      $self->_ok_debug($trace, $orig_name) unless($test);
  
      $ctx->release;
      return $test;
  }
  
  sub _ok_debug {
      my $self = shift;
      my ($trace, $orig_name) = @_;
  
      my $is_todo = defined($self->todo);
  
      my $msg = $is_todo ? "Failed (TODO)" : "Failed";
  
      my (undef, $file, $line) = $trace->call;
      if (defined $orig_name) {
          $self->diag(qq[  $msg test '$orig_name'\n  at $file line $line.\n]);
      }
      else {
          $self->diag(qq[  $msg test at $file line $line.\n]);
      }
  }
  
  sub _diag_fh {
      my $self = shift;
      local $Level = $Level + 1;
      return $self->in_todo ? $self->todo_output : $self->failure_output;
  }
  
  sub _unoverload {
      my ($self, $type, $thing) = @_;
  
      return unless ref $$thing;
      return unless blessed($$thing) || scalar $self->_try(sub{ $$thing->isa('UNIVERSAL') });
      {
          local ($!, $@);
          require overload;
      }
      my $string_meth = overload::Method( $$thing, $type ) || return;
      $$thing = $$thing->$string_meth();
  }
  
  sub _unoverload_str {
      my $self = shift;
  
      $self->_unoverload( q[""], $_ ) for @_;
  }
  
  sub _unoverload_num {
      my $self = shift;
  
      $self->_unoverload( '0+', $_ ) for @_;
  
      for my $val (@_) {
          next unless $self->_is_dualvar($$val);
          $$val = $$val + 0;
      }
  }
  
  # This is a hack to detect a dualvar such as $!
  sub _is_dualvar {
      my( $self, $val ) = @_;
  
      # Objects are not dualvars.
      return 0 if ref $val;
  
      no warnings 'numeric';
      my $numval = $val + 0;
      return ($numval != 0 and $numval ne $val ? 1 : 0);
  }
  
  
  sub is_eq {
      my( $self, $got, $expect, $name ) = @_;
  
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, 'eq', $expect ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, 'eq', $expect, $name );
  }
  
  
  sub is_num {
      my( $self, $got, $expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $expect ) {
          # undef only matches undef and nothing else
          my $test = !defined $got && !defined $expect;
  
          $self->ok( $test, $name );
          $self->_is_diag( $got, '==', $expect ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, '==', $expect, $name );
  }
  
  
  sub _diag_fmt {
      my( $self, $type, $val ) = @_;
  
      if( defined $$val ) {
          if( $type eq 'eq' or $type eq 'ne' ) {
              # quote and force string context
              $$val = "'$$val'";
          }
          else {
              # force numeric context
              $self->_unoverload_num($val);
          }
      }
      else {
          $$val = 'undef';
      }
  
      return;
  }
  
  
  sub _is_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $self->_diag_fmt( $type, $_ ) for \$got, \$expect;
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: $expect
  DIAGNOSTIC
  
  }
  
  sub _isnt_diag {
      my( $self, $got, $type ) = @_;
  
      $self->_diag_fmt( $type, \$got );
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
           got: $got
      expected: anything else
  DIAGNOSTIC
  }
  
  
  sub isnt_eq {
      my( $self, $got, $dont_expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, 'ne' ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, 'ne', $dont_expect, $name );
  }
  
  sub isnt_num {
      my( $self, $got, $dont_expect, $name ) = @_;
      my $ctx = $self->ctx;
      local $Level = $Level + 1;
  
      if( !defined $got || !defined $dont_expect ) {
          # undef only matches undef and nothing else
          my $test = defined $got || defined $dont_expect;
  
          $self->ok( $test, $name );
          $self->_isnt_diag( $got, '!=' ) unless $test;
          $ctx->release;
          return $test;
      }
  
      release $ctx, $self->cmp_ok( $got, '!=', $dont_expect, $name );
  }
  
  
  sub like {
      my( $self, $thing, $regex, $name ) = @_;
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      release $ctx, $self->_regex_ok( $thing, $regex, '=~', $name );
  }
  
  sub unlike {
      my( $self, $thing, $regex, $name ) = @_;
      my $ctx = $self->ctx;
  
      local $Level = $Level + 1;
  
      release $ctx, $self->_regex_ok( $thing, $regex, '!~', $name );
  }
  
  
  my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );
  
  # Bad, these are not comparison operators. Should we include more?
  my %cmp_ok_bl = map { ( $_, 1 ) } ( "=", "+=", ".=", "x=", "^=", "|=", "||=", "&&=", "...");
  
  sub cmp_ok {
      my( $self, $got, $type, $expect, $name ) = @_;
      my $ctx = $self->ctx;
  
      if ($cmp_ok_bl{$type}) {
          $ctx->throw("$type is not a valid comparison operator in cmp_ok()");
      }
  
      my ($test, $succ);
      my $error;
      {
          ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
          my($pack, $file, $line) = $ctx->trace->call();
  
          # This is so that warnings come out at the caller's level
          $succ = eval qq[
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $type \$expect);
  1;
  ];
          $error = $@;
      }
      local $Level = $Level + 1;
      my $ok = $self->ok( $test, $name );
  
      # Treat overloaded objects as numbers if we're asked to do a
      # numeric comparison.
      my $unoverload
        = $numeric_cmps{$type}
        ? '_unoverload_num'
        : '_unoverload_str';
  
      $self->diag(<<"END") unless $succ;
  An error occurred while using $type:
  ------------------------------------
  $error
  ------------------------------------
  END
  
      unless($ok) {
          $self->$unoverload( \$got, \$expect );
  
          if( $type =~ /^(eq|==)$/ ) {
              $self->_is_diag( $got, $type, $expect );
          }
          elsif( $type =~ /^(ne|!=)$/ ) {
              no warnings;
              my $eq = ($got eq $expect || $got == $expect)
                  && (
                      (defined($got) xor defined($expect))
                   || (length($got)  !=  length($expect))
                  );
              use warnings;
  
              if ($eq) {
                  $self->_cmp_diag( $got, $type, $expect );
              }
              else {
                  $self->_isnt_diag( $got, $type );
              }
          }
          else {
              $self->_cmp_diag( $got, $type, $expect );
          }
      }
      return release $ctx, $ok;
  }
  
  sub _cmp_diag {
      my( $self, $got, $type, $expect ) = @_;
  
      $got    = defined $got    ? "'$got'"    : 'undef';
      $expect = defined $expect ? "'$expect'" : 'undef';
  
      local $Level = $Level + 1;
      return $self->diag(<<"DIAGNOSTIC");
      $got
          $type
      $expect
  DIAGNOSTIC
  }
  
  sub _caller_context {
      my $self = shift;
  
      my( $pack, $file, $line ) = $self->caller(1);
  
      my $code = '';
      $code .= "#line $line $file\n" if defined $file and defined $line;
  
      return $code;
  }
  
  
  sub BAIL_OUT {
      my( $self, $reason ) = @_;
  
      my $ctx = $self->ctx;
  
      $self->{Bailed_Out} = 1;
  
      $ctx->bail($reason);
  }
  
  
  {
      no warnings 'once';
      *BAILOUT = \&BAIL_OUT;
  }
  
  sub skip {
      my( $self, $why, $name ) = @_;
      $why ||= '';
      $name = '' unless defined $name;
      $self->_unoverload_str( \$why );
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Test_Results}[ $ctx->hub->count ] = {
          'ok'      => 1,
          actual_ok => 1,
          name      => $name,
          type      => 'skip',
          reason    => $why,
      } unless $self->{no_log_results};
  
      $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
      $name =~ s{\n}{\n# }sg;
      $why =~ s{\n}{\n# }sg;
  
      my $tctx = $ctx->snapshot;
      $tctx->skip('', $why);
  
      return release $ctx, 1;
  }
  
  
  sub todo_skip {
      my( $self, $why ) = @_;
      $why ||= '';
  
      my $ctx = $self->ctx;
  
      $ctx->hub->meta(__PACKAGE__, {})->{Test_Results}[ $ctx->hub->count ] = {
          'ok'      => 1,
          actual_ok => 0,
          name      => '',
          type      => 'todo_skip',
          reason    => $why,
      } unless $self->{no_log_results};
  
      $why =~ s{\n}{\n# }sg;
      my $tctx = $ctx->snapshot;
      $tctx->send_event( 'Skip', todo => $why, todo_diag => 1, reason => $why, pass => 0);
  
      return release $ctx, 1;
  }
  
  
  sub maybe_regex {
      my( $self, $regex ) = @_;
      my $usable_regex = undef;
  
      return $usable_regex unless defined $regex;
  
      my( $re, $opts );
  
      # Check for qr/foo/
      if( _is_qr($regex) ) {
          $usable_regex = $regex;
      }
      # Check for '/foo/' or 'm,foo,'
      elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
            ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
      )
      {
          $usable_regex = length $opts ? "(?$opts)$re" : $re;
      }
  
      return $usable_regex;
  }
  
  sub _is_qr {
      my $regex = shift;
  
      # is_regexp() checks for regexes in a robust manner, say if they're
      # blessed.
      return re::is_regexp($regex) if defined &re::is_regexp;
      return ref $regex eq 'Regexp';
  }
  
  sub _regex_ok {
      my( $self, $thing, $regex, $cmp, $name ) = @_;
  
      my $ok           = 0;
      my $usable_regex = $self->maybe_regex($regex);
      unless( defined $usable_regex ) {
          local $Level = $Level + 1;
          $ok = $self->ok( 0, $name );
          $self->diag("    '$regex' doesn't look much like a regex to me.");
          return $ok;
      }
  
      {
          my $test;
          my $context = $self->_caller_context;
  
          {
              ## no critic (BuiltinFunctions::ProhibitStringyEval)
  
              local( $@, $!, $SIG{__DIE__} );    # isolate eval
  
              # No point in issuing an uninit warning, they'll see it in the diagnostics
              no warnings 'uninitialized';
  
              $test = eval $context . q{$test = $thing =~ /$usable_regex/ ? 1 : 0};
          }
  
          $test = !$test if $cmp eq '!~';
  
          local $Level = $Level + 1;
          $ok = $self->ok( $test, $name );
      }
  
      unless($ok) {
          $thing = defined $thing ? "'$thing'" : 'undef';
          my $match = $cmp eq '=~' ? "doesn't match" : "matches";
  
          local $Level = $Level + 1;
          $self->diag( sprintf <<'DIAGNOSTIC', $thing, $match, $regex );
                    %s
      %13s '%s'
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  
  sub is_fh {
      my $self     = shift;
      my $maybe_fh = shift;
      return 0 unless defined $maybe_fh;
  
      return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
      return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob
  
      return eval { $maybe_fh->isa("IO::Handle") } ||
             eval { tied($maybe_fh)->can('TIEHANDLE') };
  }
  
  
  sub level {
      my( $self, $level ) = @_;
  
      if( defined $level ) {
          $Level = $level;
      }
      return $Level;
  }
  
  
  sub use_numbers {
      my( $self, $use_nums ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      unless ($format && $format->can('no_numbers') && $format->can('set_no_numbers')) {
          warn "The current formatter does not support 'use_numbers'" if $format;
          return release $ctx, 0;
      }
  
      $format->set_no_numbers(!$use_nums) if defined $use_nums;
  
      return release $ctx, $format->no_numbers ? 0 : 1;
  }
  
  BEGIN {
      for my $method (qw(no_header no_diag)) {
          my $set = "set_$method";
          my $code = sub {
              my( $self, $no ) = @_;
  
              my $ctx = $self->ctx;
              my $format = $ctx->hub->format;
              unless ($format && $format->can($set)) {
                  warn "The current formatter does not support '$method'" if $format;
                  $ctx->release;
                  return
              }
  
              $format->$set($no) if defined $no;
  
              return release $ctx, $format->$method ? 1 : 0;
          };
  
          no strict 'refs';    ## no critic
          *$method = $code;
      }
  }
  
  sub no_ending {
      my( $self, $no ) = @_;
  
      my $ctx = $self->ctx;
  
      $ctx->hub->set_no_ending($no) if defined $no;
  
      return release $ctx, $ctx->hub->no_ending;
  }
  
  sub diag {
      my $self = shift;
      return unless @_;
  
      my $text = join '' => map {defined($_) ? $_ : 'undef'} @_;
  
      if (Test2::API::test2_in_preload()) {
          chomp($text);
          $text =~ s/^/# /msg;
          print STDERR $text, "\n";
          return 0;
      }
  
      my $ctx = $self->ctx;
      $ctx->diag($text);
      $ctx->release;
      return 0;
  }
  
  
  sub note {
      my $self = shift;
      return unless @_;
  
      my $text = join '' => map {defined($_) ? $_ : 'undef'} @_;
  
      if (Test2::API::test2_in_preload()) {
          chomp($text);
          $text =~ s/^/# /msg;
          print STDOUT $text, "\n";
          return 0;
      }
  
      my $ctx = $self->ctx;
      $ctx->note($text);
      $ctx->release;
      return 0;
  }
  
  
  sub explain {
      my $self = shift;
  
      local ($@, $!);
      require Data::Dumper;
  
      return map {
          ref $_
            ? do {
              my $dumper = Data::Dumper->new( [$_] );
              $dumper->Indent(1)->Terse(1);
              $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
              $dumper->Dump;
            }
            : $_
      } @_;
  }
  
  
  sub output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
  
      $format->handles->[Test2::Formatter::TAP::OUT_STD()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test2::Formatter::TAP::OUT_STD()];
  }
  
  sub failure_output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
  
      $format->handles->[Test2::Formatter::TAP::OUT_ERR()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test2::Formatter::TAP::OUT_ERR()];
  }
  
  sub todo_output {
      my( $self, $fh ) = @_;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test::Builder::Formatter');
  
      $format->handles->[Test::Builder::Formatter::OUT_TODO()] = $self->_new_fh($fh)
          if defined $fh;
  
      return $format->handles->[Test::Builder::Formatter::OUT_TODO()];
  }
  
  sub _new_fh {
      my $self = shift;
      my($file_or_fh) = shift;
  
      my $fh;
      if( $self->is_fh($file_or_fh) ) {
          $fh = $file_or_fh;
      }
      elsif( ref $file_or_fh eq 'SCALAR' ) {
          # Scalar refs as filehandles was added in 5.8.
          if( $] >= 5.008 ) {
              open $fh, ">>", $file_or_fh
                or $self->croak("Can't open scalar ref $file_or_fh: $!");
          }
          # Emulate scalar ref filehandles with a tie.
          else {
              $fh = Test::Builder::IO::Scalar->new($file_or_fh)
                or $self->croak("Can't tie scalar ref $file_or_fh");
          }
      }
      else {
          open $fh, ">", $file_or_fh
            or $self->croak("Can't open test output log $file_or_fh: $!");
          _autoflush($fh);
      }
  
      return $fh;
  }
  
  sub _autoflush {
      my($fh) = shift;
      my $old_fh = select $fh;
      $| = 1;
      select $old_fh;
  
      return;
  }
  
  
  sub reset_outputs {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $format = $ctx->hub->format;
      $ctx->release;
      return unless $format && $format->isa('Test2::Formatter::TAP');
      $format->set_handles([@{$self->{Orig_Handles}}]) if $self->{Orig_Handles};
  
      return;
  }
  
  
  sub carp {
      my $self = shift;
      my $ctx = $self->ctx;
      $ctx->alert(join "", @_);
      $ctx->release;
  }
  
  sub croak {
      my $self = shift;
      my $ctx = $self->ctx;
      $ctx->throw(join "", @_);
      $ctx->release;
  }
  
  
  sub current_test {
      my( $self, $num ) = @_;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      if( defined $num ) {
          $hub->set_count($num);
  
          unless ($self->{no_log_results}) {
              # If the test counter is being pushed forward fill in the details.
              my $test_results = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
              if ($num > @$test_results) {
                  my $start = @$test_results ? @$test_results : 0;
                  for ($start .. $num - 1) {
                      $test_results->[$_] = {
                          'ok'      => 1,
                          actual_ok => undef,
                          reason    => 'incrementing test number',
                          type      => 'unknown',
                          name      => undef
                      };
                  }
              }
              # If backward, wipe history.  Its their funeral.
              elsif ($num < @$test_results) {
                  $#{$test_results} = $num - 1;
              }
          }
      }
      return release $ctx, $hub->count;
  }
  
  
  sub is_passing {
      my $self = shift;
  
      my $ctx = $self->ctx;
      my $hub = $ctx->hub;
  
      if( @_ ) {
          my ($bool) = @_;
          $hub->set_failed(0) if $bool;
          $hub->is_passing($bool);
      }
  
      return release $ctx, $hub->is_passing;
  }
  
  
  sub summary {
      my($self) = shift;
  
      return if $self->{no_log_results};
  
      my $ctx = $self->ctx;
      my $data = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
      $ctx->release;
      return map { $_ ? $_->{'ok'} : () } @$data;
  }
  
  
  sub details {
      my $self = shift;
  
      return if $self->{no_log_results};
  
      my $ctx = $self->ctx;
      my $data = $ctx->hub->meta(__PACKAGE__, {})->{Test_Results};
      $ctx->release;
      return @$data;
  }
  
  
  sub find_TODO {
      my( $self, $pack, $set, $new_value ) = @_;
  
      my $ctx = $self->ctx;
  
      $pack ||= $ctx->trace->package || $self->exported_to;
      $ctx->release;
  
      return unless $pack;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      my $old_value = ${ $pack . '::TODO' };
      $set and ${ $pack . '::TODO' } = $new_value;
      return $old_value;
  }
  
  sub todo {
      my( $self, $pack ) = @_;
  
      local $Level = $Level + 1;
      my $ctx = $self->ctx;
      $ctx->release;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {todo => []})->{todo};
      return $meta->[-1]->[1] if $meta && @$meta;
  
      $pack ||= $ctx->trace->package;
  
      return unless $pack;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      return ${ $pack . '::TODO' };
  }
  
  sub in_todo {
      my $self = shift;
  
      local $Level = $Level + 1;
      my $ctx = $self->ctx;
      $ctx->release;
  
      my $meta = $ctx->hub->meta(__PACKAGE__, {todo => []})->{todo};
      return 1 if $meta && @$meta;
  
      my $pack = $ctx->trace->package || return 0;
  
      no strict 'refs';    ## no critic
      no warnings 'once';
      my $todo = ${ $pack . '::TODO' };
  
      return 0 unless defined $todo;
      return 0 if "$todo" eq '';
      return 1;
  }
  
  sub todo_start {
      my $self = shift;
      my $message = @_ ? shift : '';
  
      my $ctx = $self->ctx;
  
      my $hub = $ctx->hub;
      my $filter = $hub->pre_filter(sub {
          my ($active_hub, $e) = @_;
  
          # Turn a diag into a todo diag
          return Test::Builder::TodoDiag->new(%$e) if ref($e) eq 'Test2::Event::Diag';
  
          # Set todo on ok's
          if ($hub == $active_hub && $e->isa('Test2::Event::Ok')) {
              $e->set_todo($message);
              $e->set_effective_pass(1);
  
              if (my $result = $e->get_meta(__PACKAGE__)) {
                  $result->{reason} ||= $message;
                  $result->{type}   ||= 'todo';
                  $result->{ok}       = 1;
              }
          }
  
          return $e;
      }, inherit => 1);
  
      push @{$ctx->hub->meta(__PACKAGE__, {todo => []})->{todo}} => [$filter, $message];
  
      $ctx->release;
  
      return;
  }
  
  sub todo_end {
      my $self = shift;
  
      my $ctx = $self->ctx;
  
      my $set = pop @{$ctx->hub->meta(__PACKAGE__, {todo => []})->{todo}};
  
      $ctx->throw('todo_end() called without todo_start()') unless $set;
  
      $ctx->hub->pre_unfilter($set->[0]);
  
      $ctx->release;
  
      return;
  }
  
  
  sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      my( $self ) = @_;
  
      my $ctx = $self->ctx;
  
      my $trace = $ctx->trace;
      $ctx->release;
      return wantarray ? $trace->call : $trace->package;
  }
  
  
  sub _try {
      my( $self, $code, %opts ) = @_;
  
      my $error;
      my $return;
      {
          local $!;               # eval can mess up $!
          local $@;               # don't set $@ in the test
          local $SIG{__DIE__};    # don't trip an outside DIE handler.
          $return = eval { $code->() };
          $error = $@;
      }
  
      die $error if $error and $opts{die_on_fail};
  
      return wantarray ? ( $return, $error ) : $return;
  }
  
  sub _ending {
      my $self = shift;
      my ($ctx, $real_exit_code, $new) = @_;
  
      unless ($ctx) {
          my $octx = $self->ctx;
          $ctx = $octx->snapshot;
          $octx->release;
      }
  
      return if $ctx->hub->no_ending;
      return if $ctx->hub->meta(__PACKAGE__, {})->{Ending}++;
  
      # Don't bother with an ending if this is a forked copy.  Only the parent
      # should do the ending.
      return unless $self->{Original_Pid} == $$;
  
      my $hub = $ctx->hub;
      return if $hub->bailed_out;
  
      my $plan  = $hub->plan;
      my $count = $hub->count;
      my $failed = $hub->failed;
      my $passed = $hub->is_passing;
      return unless $plan || $count || $failed;
  
      # Ran tests but never declared a plan or hit done_testing
      if( !$hub->plan and $hub->count ) {
          $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
  
          if($real_exit_code) {
              $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
              $$new ||= $real_exit_code;
              return;
          }
  
          # But if the tests ran, handle exit code.
          if($failed > 0) {
              my $exit_code = $failed <= 254 ? $failed : 254;
              $$new ||= $exit_code;
              return;
          }
  
          $$new ||= 254;
          return;
      }
  
      if ($real_exit_code && !$count) {
          $self->diag("Looks like your test exited with $real_exit_code before it could output anything.");
          $$new ||= $real_exit_code;
          return;
      }
  
      return if $plan && "$plan" eq 'SKIP';
  
      if (!$count) {
          $self->diag('No tests run!');
          $$new ||= 255;
          return;
      }
  
      if ($real_exit_code) {
          $self->diag(<<"FAIL");
  Looks like your test exited with $real_exit_code just after $count.
  FAIL
          $$new ||= $real_exit_code;
          return;
      }
  
      if ($plan eq 'NO PLAN') {
          $ctx->plan( $count );
          $plan = $hub->plan;
      }
  
      # Figure out if we passed or failed and print helpful messages.
      my $num_extra = $count - $plan;
  
      if ($num_extra != 0) {
          my $s = $plan == 1 ? '' : 's';
          $self->diag(<<"FAIL");
  Looks like you planned $plan test$s but ran $count.
  FAIL
      }
  
      if ($failed) {
          my $s = $failed == 1 ? '' : 's';
  
          my $qualifier = $num_extra == 0 ? '' : ' run';
  
          $self->diag(<<"FAIL");
  Looks like you failed $failed test$s of $count$qualifier.
  FAIL
      }
  
      if (!$passed && !$failed && $count && !$num_extra) {
          $ctx->diag(<<"FAIL");
  All assertions passed, but errors were encountered.
  FAIL
      }
  
      my $exit_code = 0;
      if ($failed) {
          $exit_code = $failed <= 254 ? $failed : 254;
      }
      elsif ($num_extra != 0) {
          $exit_code = 255;
      }
      elsif (!$passed) {
          $exit_code = 255;
      }
  
      $$new ||= $exit_code;
      return;
  }
  
  # Some things used this even though it was private... I am looking at you
  # Test::Builder::Prefix...
  sub _print_comment {
      my( $self, $fh, @msgs ) = @_;
  
      return if $self->no_diag;
      return unless @msgs;
  
      # Prevent printing headers when compiling (i.e. -c)
      return if $^C;
  
      # Smash args together like print does.
      # Convert undef to 'undef' so its readable.
      my $msg = join '', map { defined($_) ? $_ : 'undef' } @msgs;
  
      # Escape the beginning, _print will take care of the rest.
      $msg =~ s/^/# /;
  
      local( $\, $", $, ) = ( undef, ' ', '' );
      print $fh $msg;
  
      return 0;
  }
  
  # This is used by Test::SharedFork to turn on IPC after the fact. Not
  # documenting because I do not want it used. The method name is borrowed from
  # Test::Builder 2
  # Once Test2 stuff goes stable this method will be removed and Test::SharedFork
  # will be made smarter.
  sub coordinate_forks {
      my $self = shift;
  
      {
          local ($@, $!);
          require Test2::IPC;
      }
      Test2::IPC->import;
      Test2::API::test2_ipc_enable_polling();
      Test2::API::test2_load();
      my $ipc = Test2::IPC::apply_ipc($self->{Stack});
      $ipc->set_no_fatal(1);
      Test2::API::test2_no_wait(1);
      Test2::API::test2_ipc_enable_shm();
  }
  
  sub no_log_results { $_[0]->{no_log_results} = 1 }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Builder - Backend for building test libraries
  
  =head1 SYNOPSIS
  
    package My::Test::Module;
    use base 'Test::Builder::Module';
  
    my $CLASS = __PACKAGE__;
  
    sub ok {
        my($test, $name) = @_;
        my $tb = $CLASS->builder;
  
        $tb->ok($test, $name);
    }
  
  
  =head1 DESCRIPTION
  
  L<Test::Simple> and L<Test::More> have proven to be popular testing modules,
  but they're not always flexible enough.  Test::Builder provides a
  building block upon which to write your own test libraries I<which can
  work together>.
  
  =head2 Construction
  
  =over 4
  
  =item B<new>
  
    my $Test = Test::Builder->new;
  
  Returns a Test::Builder object representing the current state of the
  test.
  
  Since you only run one test per program C<new> always returns the same
  Test::Builder object.  No matter how many times you call C<new()>, you're
  getting the same object.  This is called a singleton.  This is done so that
  multiple modules share such global information as the test counter and
  where test output is going.
  
  If you want a completely new Test::Builder object different from the
  singleton, use C<create>.
  
  =item B<create>
  
    my $Test = Test::Builder->create;
  
  Ok, so there can be more than one Test::Builder object and this is how
  you get it.  You might use this instead of C<new()> if you're testing
  a Test::Builder based module, but otherwise you probably want C<new>.
  
  B<NOTE>: the implementation is not complete.  C<level>, for example, is still
  shared by B<all> Test::Builder objects, even ones created using this method.
  Also, the method name may change in the future.
  
  =item B<subtest>
  
      $builder->subtest($name, \&subtests, @args);
  
  See documentation of C<subtest> in Test::More.
  
  C<subtest> also, and optionally, accepts arguments which will be passed to the
  subtests reference.
  
  =item B<name>
  
   diag $builder->name;
  
  Returns the name of the current builder.  Top level builders default to C<$0>
  (the name of the executable).  Child builders are named via the C<child>
  method.  If no name is supplied, will be named "Child of $parent->name".
  
  =item B<reset>
  
    $Test->reset;
  
  Reinitializes the Test::Builder singleton to its original state.
  Mostly useful for tests run in persistent environments where the same
  test might be run multiple times in the same process.
  
  =back
  
  =head2 Setting up tests
  
  These methods are for setting up tests and declaring how many there
  are.  You usually only want to call one of these methods.
  
  =over 4
  
  =item B<plan>
  
    $Test->plan('no_plan');
    $Test->plan( skip_all => $reason );
    $Test->plan( tests => $num_tests );
  
  A convenient way to set up your tests.  Call this and Test::Builder
  will print the appropriate headers and take the appropriate actions.
  
  If you call C<plan()>, don't call any of the other methods below.
  
  =item B<expected_tests>
  
      my $max = $Test->expected_tests;
      $Test->expected_tests($max);
  
  Gets/sets the number of tests we expect this test to run and prints out
  the appropriate headers.
  
  
  =item B<no_plan>
  
    $Test->no_plan;
  
  Declares that this test will run an indeterminate number of tests.
  
  
  =item B<done_testing>
  
    $Test->done_testing();
    $Test->done_testing($num_tests);
  
  Declares that you are done testing, no more tests will be run after this point.
  
  If a plan has not yet been output, it will do so.
  
  $num_tests is the number of tests you planned to run.  If a numbered
  plan was already declared, and if this contradicts, a failing test
  will be run to reflect the planning mistake.  If C<no_plan> was declared,
  this will override.
  
  If C<done_testing()> is called twice, the second call will issue a
  failing test.
  
  If C<$num_tests> is omitted, the number of tests run will be used, like
  no_plan.
  
  C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
  safer. You'd use it like so:
  
      $Test->ok($a == $b);
      $Test->done_testing();
  
  Or to plan a variable number of tests:
  
      for my $test (@tests) {
          $Test->ok($test);
      }
      $Test->done_testing(scalar @tests);
  
  
  =item B<has_plan>
  
    $plan = $Test->has_plan
  
  Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
  has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
  of expected tests).
  
  =item B<skip_all>
  
    $Test->skip_all;
    $Test->skip_all($reason);
  
  Skips all the tests, using the given C<$reason>.  Exits immediately with 0.
  
  =item B<exported_to>
  
    my $pack = $Test->exported_to;
    $Test->exported_to($pack);
  
  Tells Test::Builder what package you exported your functions to.
  
  This method isn't terribly useful since modules which share the same
  Test::Builder object might get exported to different packages and only
  the last one will be honored.
  
  =back
  
  =head2 Running tests
  
  These actually run the tests, analogous to the functions in Test::More.
  
  They all return true if the test passed, false if the test failed.
  
  C<$name> is always optional.
  
  =over 4
  
  =item B<ok>
  
    $Test->ok($test, $name);
  
  Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
  like Test::Simple's C<ok()>.
  
  =item B<is_eq>
  
    $Test->is_eq($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
  string version.
  
  C<undef> only ever matches another C<undef>.
  
  =item B<is_num>
  
    $Test->is_num($got, $expected, $name);
  
  Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
  numeric version.
  
  C<undef> only ever matches another C<undef>.
  
  =item B<isnt_eq>
  
    $Test->isnt_eq($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the string version.
  
  =item B<isnt_num>
  
    $Test->isnt_num($got, $dont_expect, $name);
  
  Like L<Test::More>'s C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
  the numeric version.
  
  =item B<like>
  
    $Test->like($thing, qr/$regex/, $name);
    $Test->like($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<like()>.  Checks if $thing matches the given C<$regex>.
  
  =item B<unlike>
  
    $Test->unlike($thing, qr/$regex/, $name);
    $Test->unlike($thing, '/$regex/', $name);
  
  Like L<Test::More>'s C<unlike()>.  Checks if $thing B<does not match> the
  given C<$regex>.
  
  =item B<cmp_ok>
  
    $Test->cmp_ok($thing, $type, $that, $name);
  
  Works just like L<Test::More>'s C<cmp_ok()>.
  
      $Test->cmp_ok($big_num, '!=', $other_big_num);
  
  =back
  
  =head2 Other Testing Methods
  
  These are methods which are used in the course of writing a test but are not themselves tests.
  
  =over 4
  
  =item B<BAIL_OUT>
  
      $Test->BAIL_OUT($reason);
  
  Indicates to the L<Test::Harness> that things are going so badly all
  testing should terminate.  This includes running any additional test
  scripts.
  
  It will exit with 255.
  
  =for deprecated
  BAIL_OUT() used to be BAILOUT()
  
  =item B<skip>
  
      $Test->skip;
      $Test->skip($why);
  
  Skips the current test, reporting C<$why>.
  
  =item B<todo_skip>
  
    $Test->todo_skip;
    $Test->todo_skip($why);
  
  Like C<skip()>, only it will declare the test as failing and TODO.  Similar
  to
  
      print "not ok $tnum # TODO $why\n";
  
  =begin _unimplemented
  
  =item B<skip_rest>
  
    $Test->skip_rest;
    $Test->skip_rest($reason);
  
  Like C<skip()>, only it skips all the rest of the tests you plan to run
  and terminates the test.
  
  If you're running under C<no_plan>, it skips once and terminates the
  test.
  
  =end _unimplemented
  
  =back
  
  
  =head2 Test building utility methods
  
  These methods are useful when writing your own test methods.
  
  =over 4
  
  =item B<maybe_regex>
  
    $Test->maybe_regex(qr/$regex/);
    $Test->maybe_regex('/$regex/');
  
  This method used to be useful back when Test::Builder worked on Perls
  before 5.6 which didn't have qr//.  Now its pretty useless.
  
  Convenience method for building testing functions that take regular
  expressions as arguments.
  
  Takes a quoted regular expression produced by C<qr//>, or a string
  representing a regular expression.
  
  Returns a Perl value which may be used instead of the corresponding
  regular expression, or C<undef> if its argument is not recognized.
  
  For example, a version of C<like()>, sans the useful diagnostic messages,
  could be written as:
  
    sub laconic_like {
        my ($self, $thing, $regex, $name) = @_;
        my $usable_regex = $self->maybe_regex($regex);
        die "expecting regex, found '$regex'\n"
            unless $usable_regex;
        $self->ok($thing =~ m/$usable_regex/, $name);
    }
  
  
  =item B<is_fh>
  
      my $is_fh = $Test->is_fh($thing);
  
  Determines if the given C<$thing> can be used as a filehandle.
  
  =cut
  
  
  =back
  
  
  =head2 Test style
  
  
  =over 4
  
  =item B<level>
  
      $Test->level($how_high);
  
  How far up the call stack should C<$Test> look when reporting where the
  test failed.
  
  Defaults to 1.
  
  Setting C<$Test::Builder::Level> overrides.  This is typically useful
  localized:
  
      sub my_ok {
          my $test = shift;
  
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          $TB->ok($test);
      }
  
  To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.
  
  =item B<use_numbers>
  
      $Test->use_numbers($on_or_off);
  
  Whether or not the test should output numbers.  That is, this if true:
  
    ok 1
    ok 2
    ok 3
  
  or this if false
  
    ok
    ok
    ok
  
  Most useful when you can't depend on the test output order, such as
  when threads or forking is involved.
  
  Defaults to on.
  
  =item B<no_diag>
  
      $Test->no_diag($no_diag);
  
  If set true no diagnostics will be printed.  This includes calls to
  C<diag()>.
  
  =item B<no_ending>
  
      $Test->no_ending($no_ending);
  
  Normally, Test::Builder does some extra diagnostics when the test
  ends.  It also changes the exit code as described below.
  
  If this is true, none of that will be done.
  
  =item B<no_header>
  
      $Test->no_header($no_header);
  
  If set to true, no "1..N" header will be printed.
  
  =back
  
  =head2 Output
  
  Controlling where the test output goes.
  
  It's ok for your test to change where STDOUT and STDERR point to,
  Test::Builder's default output settings will not be affected.
  
  =over 4
  
  =item B<diag>
  
      $Test->diag(@msgs);
  
  Prints out the given C<@msgs>.  Like C<print>, arguments are simply
  appended together.
  
  Normally, it uses the C<failure_output()> handle, but if this is for a
  TODO test, the C<todo_output()> handle is used.
  
  Output will be indented and marked with a # so as not to interfere
  with test output.  A newline will be put on the end if there isn't one
  already.
  
  We encourage using this rather than calling print directly.
  
  Returns false.  Why?  Because C<diag()> is often used in conjunction with
  a failing test (C<ok() || diag()>) it "passes through" the failure.
  
      return ok(...) || diag(...);
  
  =for blame transfer
  Mark Fowler <mark@twoshortplanks.com>
  
  =item B<note>
  
      $Test->note(@msgs);
  
  Like C<diag()>, but it prints to the C<output()> handle so it will not
  normally be seen by the user except in verbose mode.
  
  =item B<explain>
  
      my @dump = $Test->explain(@msgs);
  
  Will dump the contents of any references in a human readable format.
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      is_deeply($have, $want) || note explain $have;
  
  =item B<output>
  
  =item B<failure_output>
  
  =item B<todo_output>
  
      my $filehandle = $Test->output;
      $Test->output($filehandle);
      $Test->output($filename);
      $Test->output(\$scalar);
  
  These methods control where Test::Builder will print its output.
  They take either an open C<$filehandle>, a C<$filename> to open and write to
  or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.
  
  B<output> is where normal "ok/not ok" test output goes.
  
  Defaults to STDOUT.
  
  B<failure_output> is where diagnostic output on test failures and
  C<diag()> goes.  It is normally not read by Test::Harness and instead is
  displayed to the user.
  
  Defaults to STDERR.
  
  C<todo_output> is used instead of C<failure_output()> for the
  diagnostics of a failing TODO test.  These will not be seen by the
  user.
  
  Defaults to STDOUT.
  
  =item reset_outputs
  
    $tb->reset_outputs;
  
  Resets all the output filehandles back to their defaults.
  
  =item carp
  
    $tb->carp(@message);
  
  Warns with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  =item croak
  
    $tb->croak(@message);
  
  Dies with C<@message> but the message will appear to come from the
  point where the original test function was called (C<< $tb->caller >>).
  
  
  =back
  
  
  =head2 Test Status and Info
  
  =over 4
  
  =item B<no_log_results>
  
  This will turn off result long-term storage. Calling this method will make
  C<details> and C<summary> useless. You may want to use this if you are running
  enough tests to fill up all available memory.
  
      Test::Builder->new->no_log_results();
  
  There is no way to turn it back on.
  
  =item B<current_test>
  
      my $curr_test = $Test->current_test;
      $Test->current_test($num);
  
  Gets/sets the current test number we're on.  You usually shouldn't
  have to set this.
  
  If set forward, the details of the missing tests are filled in as 'unknown'.
  if set backward, the details of the intervening tests are deleted.  You
  can erase history if you really want to.
  
  
  =item B<is_passing>
  
     my $ok = $builder->is_passing;
  
  Indicates if the test suite is currently passing.
  
  More formally, it will be false if anything has happened which makes
  it impossible for the test suite to pass.  True otherwise.
  
  For example, if no tests have run C<is_passing()> will be true because
  even though a suite with no tests is a failure you can add a passing
  test to it and start passing.
  
  Don't think about it too much.
  
  
  =item B<summary>
  
      my @tests = $Test->summary;
  
  A simple summary of the tests so far.  True for pass, false for fail.
  This is a logical pass/fail, so todos are passes.
  
  Of course, test #1 is $tests[0], etc...
  
  
  =item B<details>
  
      my @tests = $Test->details;
  
  Like C<summary()>, but with a lot more detail.
  
      $tests[$test_num - 1] =
              { 'ok'       => is the test considered a pass?
                actual_ok  => did it literally say 'ok'?
                name       => name of the test (if any)
                type       => type of test (if any, see below).
                reason     => reason for the above (if any)
              };
  
  'ok' is true if Test::Harness will consider the test to be a pass.
  
  'actual_ok' is a reflection of whether or not the test literally
  printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
  tests.
  
  'name' is the name of the test.
  
  'type' indicates if it was a special test.  Normal tests have a type
  of ''.  Type can be one of the following:
  
      skip        see skip()
      todo        see todo()
      todo_skip   see todo_skip()
      unknown     see below
  
  Sometimes the Test::Builder test counter is incremented without it
  printing any test output, for example, when C<current_test()> is changed.
  In these cases, Test::Builder doesn't know the result of the test, so
  its type is 'unknown'.  These details for these tests are filled in.
  They are considered ok, but the name and actual_ok is left C<undef>.
  
  For example "not ok 23 - hole count # TODO insufficient donuts" would
  result in this structure:
  
      $tests[22] =    # 23 - 1, since arrays start from 0.
        { ok        => 1,   # logically, the test passed since its todo
          actual_ok => 0,   # in absolute terms, it failed
          name      => 'hole count',
          type      => 'todo',
          reason    => 'insufficient donuts'
        };
  
  
  =item B<todo>
  
      my $todo_reason = $Test->todo;
      my $todo_reason = $Test->todo($pack);
  
  If the current tests are considered "TODO" it will return the reason,
  if any.  This reason can come from a C<$TODO> variable or the last call
  to C<todo_start()>.
  
  Since a TODO test does not need a reason, this function can return an
  empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
  to determine if you are currently inside a TODO block.
  
  C<todo()> is about finding the right package to look for C<$TODO> in.  It's
  pretty good at guessing the right package to look at.  It first looks for
  the caller based on C<$Level + 1>, since C<todo()> is usually called inside
  a test function.  As a last resort it will use C<exported_to()>.
  
  Sometimes there is some confusion about where C<todo()> should be looking
  for the C<$TODO> variable.  If you want to be sure, tell it explicitly
  what $pack to use.
  
  =item B<find_TODO>
  
      my $todo_reason = $Test->find_TODO();
      my $todo_reason = $Test->find_TODO($pack);
  
  Like C<todo()> but only returns the value of C<$TODO> ignoring
  C<todo_start()>.
  
  Can also be used to set C<$TODO> to a new value while returning the
  old value:
  
      my $old_reason = $Test->find_TODO($pack, 1, $new_reason);
  
  =item B<in_todo>
  
      my $in_todo = $Test->in_todo;
  
  Returns true if the test is currently inside a TODO block.
  
  =item B<todo_start>
  
      $Test->todo_start();
      $Test->todo_start($message);
  
  This method allows you declare all subsequent tests as TODO tests, up until
  the C<todo_end> method has been called.
  
  The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
  whether or not we're in a TODO test.  However, often we find that this is not
  possible to determine (such as when we want to use C<$TODO> but
  the tests are being executed in other packages which can't be inferred
  beforehand).
  
  Note that you can use this to nest "todo" tests
  
   $Test->todo_start('working on this');
   # lots of code
   $Test->todo_start('working on that');
   # more code
   $Test->todo_end;
   $Test->todo_end;
  
  This is generally not recommended, but large testing systems often have weird
  internal needs.
  
  We've tried to make this also work with the TODO: syntax, but it's not
  guaranteed and its use is also discouraged:
  
   TODO: {
       local $TODO = 'We have work to do!';
       $Test->todo_start('working on this');
       # lots of code
       $Test->todo_start('working on that');
       # more code
       $Test->todo_end;
       $Test->todo_end;
   }
  
  Pick one style or another of "TODO" to be on the safe side.
  
  
  =item C<todo_end>
  
   $Test->todo_end;
  
  Stops running tests as "TODO" tests.  This method is fatal if called without a
  preceding C<todo_start> method call.
  
  =item B<caller>
  
      my $package = $Test->caller;
      my($pack, $file, $line) = $Test->caller;
      my($pack, $file, $line) = $Test->caller($height);
  
  Like the normal C<caller()>, except it reports according to your C<level()>.
  
  C<$height> will be added to the C<level()>.
  
  If C<caller()> winds up off the top of the stack it report the highest context.
  
  =back
  
  =head1 EXIT CODES
  
  If all your tests passed, Test::Builder will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Builder
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  =head1 THREADS
  
  In perl 5.8.1 and later, Test::Builder is thread-safe.  The test number is
  shared by all threads.  This means if one thread sets the test number using
  C<current_test()> they will all be effected.
  
  While versions earlier than 5.8.1 had threads they contain too many
  bugs to support.
  
  Test::Builder is only thread-aware if threads.pm is loaded I<before>
  Test::Builder.
  
  You can directly disable thread support with one of the following:
  
      $ENV{T2_NO_IPC} = 1
  
  or
  
      no Test2::IPC;
  
  or
  
      Test2::API::test2_ipc_disable()
  
  =head1 MEMORY
  
  An informative hash, accessible via C<details()>, is stored for each
  test you perform.  So memory usage will scale linearly with each test
  run. Although this is not a problem for most test suites, it can
  become an issue if you do large (hundred thousands to million)
  combinatorics tests in the same run.
  
  In such cases, you are advised to either split the test file into smaller
  ones, or use a reverse approach, doing "normal" (code) compares and
  triggering C<fail()> should anything go unexpected.
  
  Future versions of Test::Builder will have a way to turn history off.
  
  
  =head1 EXAMPLES
  
  CPAN can provide the best examples.  L<Test::Simple>, L<Test::More>,
  L<Test::Exception> and L<Test::Differences> all use Test::Builder.
  
  =head1 SEE ALSO
  
  L<Test::Simple>, L<Test::More>, L<Test::Harness>
  
  =head1 AUTHORS
  
  Original code by chromatic, maintained by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2002-2008 by chromatic E<lt>chromatic@wgz.orgE<gt> and
                         Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
TEST_BUILDER

$fatpacked{"Test/Builder/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_FORMATTER';
  package Test::Builder::Formatter;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Formatter::TAP; our @ISA = qw(Test2::Formatter::TAP) }
  
  use Test2::Util::HashBase qw/no_header no_diag/;
  
  BEGIN {
      *OUT_STD = Test2::Formatter::TAP->can('OUT_STD');
      *OUT_ERR = Test2::Formatter::TAP->can('OUT_ERR');
  
      my $todo = OUT_ERR() + 1;
      *OUT_TODO = sub() { $todo };
  }
  
  sub init {
      my $self = shift;
      $self->SUPER::init(@_);
      $self->{+HANDLES}->[OUT_TODO] = $self->{+HANDLES}->[OUT_STD];
  }
  
  sub plan_tap {
      my ($self, $f) = @_;
  
      return if $self->{+NO_HEADER};
      return $self->SUPER::plan_tap($f);
  }
  
  sub debug_tap {
      my ($self, $f, $num) = @_;
      return if $self->{+NO_DIAG};
      my @out = $self->SUPER::debug_tap($f, $num);
      $self->redirect(\@out) if @out && $f->{about}->{package} eq 'Test::Builder::TodoDiag';
      return @out;
  }
  
  sub info_tap {
      my ($self, $f) = @_;
      return if $self->{+NO_DIAG};
      my @out = $self->SUPER::info_tap($f);
      $self->redirect(\@out) if @out && $f->{about}->{package} eq 'Test::Builder::TodoDiag';
      return @out;
  }
  
  sub redirect {
      my ($self, $out) = @_;
      $_->[0] = OUT_TODO for @$out;
  }
  
  sub no_subtest_space { 1 }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Builder::Formatter - Test::Builder subclass of Test2::Formatter::TAP
  
  =head1 DESCRIPTION
  
  This is what takes events and turns them into TAP.
  
  =head1 SYNOPSIS
  
      use Test::Builder; # Loads Test::Builder::Formatter for you
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST_BUILDER_FORMATTER

$fatpacked{"Test/Builder/IO/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_IO_SCALAR';
  package Test::Builder::IO::Scalar;
  
  
  =head1 NAME
  
  Test::Builder::IO::Scalar - A copy of IO::Scalar for Test::Builder
  
  =head1 DESCRIPTION
  
  This is a copy of L<IO::Scalar> which ships with L<Test::Builder> to
  support scalar references as filehandles on Perl 5.6.  Newer
  versions of Perl simply use C<open()>'s built in support.
  
  L<Test::Builder> can not have dependencies on other modules without
  careful consideration, so its simply been copied into the distribution.
  
  =head1 COPYRIGHT and LICENSE
  
  This file came from the "IO-stringy" Perl5 toolkit.
  
  Copyright (c) 1996 by Eryq.  All rights reserved.
  Copyright (c) 1999,2001 by ZeeGee Software Inc.  All rights reserved.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =cut
  
  # This is copied code, I don't care.
  ##no critic
  
  use Carp;
  use strict;
  use vars qw($VERSION @ISA);
  use IO::Handle;
  
  use 5.005;
  
  ### The package version, both in 1.23 style *and* usable by MakeMaker:
  $VERSION = "2.114";
  
  ### Inheritance:
  @ISA = qw(IO::Handle);
  
  #==============================
  
  =head2 Construction
  
  =over 4
  
  =cut
  
  #------------------------------
  
  =item new [ARGS...]
  
  I<Class method.>
  Return a new, unattached scalar handle.
  If any arguments are given, they're sent to open().
  
  =cut
  
  sub new {
      my $proto = shift;
      my $class = ref($proto) || $proto;
      my $self = bless \do { local *FH }, $class;
      tie *$self, $class, $self;
      $self->open(@_);   ### open on anonymous by default
      $self;
  }
  sub DESTROY {
      shift->close;
  }
  
  #------------------------------
  
  =item open [SCALARREF]
  
  I<Instance method.>
  Open the scalar handle on a new scalar, pointed to by SCALARREF.
  If no SCALARREF is given, a "private" scalar is created to hold
  the file data.
  
  Returns the self object on success, undefined on error.
  
  =cut
  
  sub open {
      my ($self, $sref) = @_;
  
      ### Sanity:
      defined($sref) or do {my $s = ''; $sref = \$s};
      (ref($sref) eq "SCALAR") or croak "open() needs a ref to a scalar";
  
      ### Setup:
      *$self->{Pos} = 0;          ### seek position
      *$self->{SR}  = $sref;      ### scalar reference
      $self;
  }
  
  #------------------------------
  
  =item opened
  
  I<Instance method.>
  Is the scalar handle opened on something?
  
  =cut
  
  sub opened {
      *{shift()}->{SR};
  }
  
  #------------------------------
  
  =item close
  
  I<Instance method.>
  Disassociate the scalar handle from its underlying scalar.
  Done automatically on destroy.
  
  =cut
  
  sub close {
      my $self = shift;
      %{*$self} = ();
      1;
  }
  
  =back
  
  =cut
  
  
  
  #==============================
  
  =head2 Input and output
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item flush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub flush { "0 but true" }
  
  #------------------------------
  
  =item getc
  
  I<Instance method.>
  Return the next character, or undef if none remain.
  
  =cut
  
  sub getc {
      my $self = shift;
  
      ### Return undef right away if at EOF; else, move pos forward:
      return undef if $self->eof;
      substr(${*$self->{SR}}, *$self->{Pos}++, 1);
  }
  
  #------------------------------
  
  =item getline
  
  I<Instance method.>
  Return the next line, or undef on end of string.
  Can safely be called in an array context.
  Currently, lines are delimited by "\n".
  
  =cut
  
  sub getline {
      my $self = shift;
  
      ### Return undef right away if at EOF:
      return undef if $self->eof;
  
      ### Get next line:
      my $sr = *$self->{SR};
      my $i  = *$self->{Pos};	        ### Start matching at this point.
  
      ### Minimal impact implementation!
      ### We do the fast fast thing (no regexps) if using the
      ### classic input record separator.
  
      ### Case 1: $/ is undef: slurp all...
      if    (!defined($/)) {
  	*$self->{Pos} = length $$sr;
          return substr($$sr, $i);
      }
  
      ### Case 2: $/ is "\n": zoom zoom zoom...
      elsif ($/ eq "\012") {
  
          ### Seek ahead for "\n"... yes, this really is faster than regexps.
          my $len = length($$sr);
          for (; $i < $len; ++$i) {
             last if ord (substr ($$sr, $i, 1)) == 10;
          }
  
          ### Extract the line:
          my $line;
          if ($i < $len) {                ### We found a "\n":
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos} + 1);
              *$self->{Pos} = $i+1;            ### Remember where we finished up.
          }
          else {                          ### No "\n"; slurp the remainder:
              $line = substr ($$sr, *$self->{Pos}, $i - *$self->{Pos});
              *$self->{Pos} = $len;
          }
          return $line;
      }
  
      ### Case 3: $/ is ref to int. Do fixed-size records.
      ###        (Thanks to Dominique Quatravaux.)
      elsif (ref($/)) {
          my $len = length($$sr);
  		my $i = ${$/} + 0;
  		my $line = substr ($$sr, *$self->{Pos}, $i);
  		*$self->{Pos} += $i;
          *$self->{Pos} = $len if (*$self->{Pos} > $len);
  		return $line;
      }
  
      ### Case 4: $/ is either "" (paragraphs) or something weird...
      ###         This is Graham's general-purpose stuff, which might be
      ###         a tad slower than Case 2 for typical data, because
      ###         of the regexps.
      else {
          pos($$sr) = $i;
  
  	### If in paragraph mode, skip leading lines (and update i!):
          length($/) or
  	    (($$sr =~ m/\G\n*/g) and ($i = pos($$sr)));
  
          ### If we see the separator in the buffer ahead...
          if (length($/)
  	    ?  $$sr =~ m,\Q$/\E,g          ###   (ordinary sep) TBD: precomp!
              :  $$sr =~ m,\n\n,g            ###   (a paragraph)
              ) {
              *$self->{Pos} = pos $$sr;
              return substr($$sr, $i, *$self->{Pos}-$i);
          }
          ### Else if no separator remains, just slurp the rest:
          else {
              *$self->{Pos} = length $$sr;
              return substr($$sr, $i);
          }
      }
  }
  
  #------------------------------
  
  =item getlines
  
  I<Instance method.>
  Get all remaining lines.
  It will croak() if accidentally called in a scalar context.
  
  =cut
  
  sub getlines {
      my $self = shift;
      wantarray or croak("can't call getlines in scalar context!");
      my ($line, @lines);
      push @lines, $line while (defined($line = $self->getline));
      @lines;
  }
  
  #------------------------------
  
  =item print ARGS...
  
  I<Instance method.>
  Print ARGS to the underlying scalar.
  
  B<Warning:> this continues to always cause a seek to the end
  of the string, but if you perform seek()s and tell()s, it is
  still safer to explicitly seek-to-end before subsequent print()s.
  
  =cut
  
  sub print {
      my $self = shift;
      *$self->{Pos} = length(${*$self->{SR}} .= join('', @_) . (defined($\) ? $\ : ""));
      1;
  }
  sub _unsafe_print {
      my $self = shift;
      my $append = join('', @_) . $\;
      ${*$self->{SR}} .= $append;
      *$self->{Pos}   += length($append);
      1;
  }
  sub _old_print {
      my $self = shift;
      ${*$self->{SR}} .= join('', @_) . $\;
      *$self->{Pos} = length(${*$self->{SR}});
      1;
  }
  
  
  #------------------------------
  
  =item read BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub read {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $read = substr(${*$self->{SR}}, *$self->{Pos}, $n);
      $n = length($read);
      *$self->{Pos} += $n;
      ($off ? substr($_[1], $off) : $_[1]) = $read;
      return $n;
  }
  
  #------------------------------
  
  =item write BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub write {
      my $self = $_[0];
      my $n    = $_[2];
      my $off  = $_[3] || 0;
  
      my $data = substr($_[1], $off, $n);
      $n = length($data);
      $self->print($data);
      return $n;
  }
  
  #------------------------------
  
  =item sysread BUF, LEN, [OFFSET]
  
  I<Instance method.>
  Read some bytes from the scalar.
  Returns the number of bytes actually read, 0 on end-of-file, undef on error.
  
  =cut
  
  sub sysread {
    my $self = shift;
    $self->read(@_);
  }
  
  #------------------------------
  
  =item syswrite BUF, NBYTES, [OFFSET]
  
  I<Instance method.>
  Write some bytes to the scalar.
  
  =cut
  
  sub syswrite {
    my $self = shift;
    $self->write(@_);
  }
  
  =back
  
  =cut
  
  
  #==============================
  
  =head2 Seeking/telling and other attributes
  
  =over 4
  
  =cut
  
  
  #------------------------------
  
  =item autoflush
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub autoflush {}
  
  #------------------------------
  
  =item binmode
  
  I<Instance method.>
  No-op, provided for OO compatibility.
  
  =cut
  
  sub binmode {}
  
  #------------------------------
  
  =item clearerr
  
  I<Instance method.>  Clear the error and EOF flags.  A no-op.
  
  =cut
  
  sub clearerr { 1 }
  
  #------------------------------
  
  =item eof
  
  I<Instance method.>  Are we at end of file?
  
  =cut
  
  sub eof {
      my $self = shift;
      (*$self->{Pos} >= length(${*$self->{SR}}));
  }
  
  #------------------------------
  
  =item seek OFFSET, WHENCE
  
  I<Instance method.>  Seek to a given position in the stream.
  
  =cut
  
  sub seek {
      my ($self, $pos, $whence) = @_;
      my $eofpos = length(${*$self->{SR}});
  
      ### Seek:
      if    ($whence == 0) { *$self->{Pos} = $pos }             ### SEEK_SET
      elsif ($whence == 1) { *$self->{Pos} += $pos }            ### SEEK_CUR
      elsif ($whence == 2) { *$self->{Pos} = $eofpos + $pos}    ### SEEK_END
      else                 { croak "bad seek whence ($whence)" }
  
      ### Fixup:
      if (*$self->{Pos} < 0)       { *$self->{Pos} = 0 }
      if (*$self->{Pos} > $eofpos) { *$self->{Pos} = $eofpos }
      return 1;
  }
  
  #------------------------------
  
  =item sysseek OFFSET, WHENCE
  
  I<Instance method.> Identical to C<seek OFFSET, WHENCE>, I<q.v.>
  
  =cut
  
  sub sysseek {
      my $self = shift;
      $self->seek (@_);
  }
  
  #------------------------------
  
  =item tell
  
  I<Instance method.>
  Return the current position in the stream, as a numeric offset.
  
  =cut
  
  sub tell { *{shift()}->{Pos} }
  
  #------------------------------
  
  =item  use_RS [YESNO]
  
  I<Instance method.>
  B<Deprecated and ignored.>
  Obey the current setting of $/, like IO::Handle does?
  Default is false in 1.x, but cold-welded true in 2.x and later.
  
  =cut
  
  sub use_RS {
      my ($self, $yesno) = @_;
      carp "use_RS is deprecated and ignored; \$/ is always consulted\n";
   }
  
  #------------------------------
  
  =item setpos POS
  
  I<Instance method.>
  Set the current position, using the opaque value returned by C<getpos()>.
  
  =cut
  
  sub setpos { shift->seek($_[0],0) }
  
  #------------------------------
  
  =item getpos
  
  I<Instance method.>
  Return the current position in the string, as an opaque object.
  
  =cut
  
  *getpos = \&tell;
  
  
  #------------------------------
  
  =item sref
  
  I<Instance method.>
  Return a reference to the underlying scalar.
  
  =cut
  
  sub sref { *{shift()}->{SR} }
  
  
  #------------------------------
  # Tied handle methods...
  #------------------------------
  
  # Conventional tiehandle interface:
  sub TIEHANDLE {
      ((defined($_[1]) && UNIVERSAL::isa($_[1], __PACKAGE__))
       ? $_[1]
       : shift->new(@_));
  }
  sub GETC      { shift->getc(@_) }
  sub PRINT     { shift->print(@_) }
  sub PRINTF    { shift->print(sprintf(shift, @_)) }
  sub READ      { shift->read(@_) }
  sub READLINE  { wantarray ? shift->getlines(@_) : shift->getline(@_) }
  sub WRITE     { shift->write(@_); }
  sub CLOSE     { shift->close(@_); }
  sub SEEK      { shift->seek(@_); }
  sub TELL      { shift->tell(@_); }
  sub EOF       { shift->eof(@_); }
  sub FILENO    { -1 }
  
  #------------------------------------------------------------
  
  1;
  
  __END__
  
  
  
  =back
  
  =cut
  
  
  =head1 WARNINGS
  
  Perl's TIEHANDLE spec was incomplete prior to 5.005_57;
  it was missing support for C<seek()>, C<tell()>, and C<eof()>.
  Attempting to use these functions with an IO::Scalar will not work
  prior to 5.005_57. IO::Scalar will not have the relevant methods
  invoked; and even worse, this kind of bug can lie dormant for a while.
  If you turn warnings on (via C<$^W> or C<perl -w>),
  and you see something like this...
  
      attempt to seek on unopened filehandle
  
  ...then you are probably trying to use one of these functions
  on an IO::Scalar with an old Perl.  The remedy is to simply
  use the OO version; e.g.:
  
      $SH->seek(0,0);    ### GOOD: will work on any 5.005
      seek($SH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
  
  
  =head1 VERSION
  
  $Id: Scalar.pm,v 1.6 2005/02/10 21:21:53 dfs Exp $
  
  
  =head1 AUTHORS
  
  =head2 Primary Maintainer
  
  David F. Skoll (F<dfs@roaringpenguin.com>).
  
  =head2 Principal author
  
  Eryq (F<eryq@zeegee.com>).
  President, ZeeGee Software Inc (F<http://www.zeegee.com>).
  
  
  =head2 Other contributors
  
  The full set of contributors always includes the folks mentioned
  in L<IO::Stringy/"CHANGE LOG">.  But just the same, special
  thanks to the following individuals for their invaluable contributions
  (if I've forgotten or misspelled your name, please email me!):
  
  I<Andy Glew,>
  for contributing C<getc()>.
  
  I<Brandon Browning,>
  for suggesting C<opened()>.
  
  I<David Richter,>
  for finding and fixing the bug in C<PRINTF()>.
  
  I<Eric L. Brine,>
  for his offset-using read() and write() implementations.
  
  I<Richard Jones,>
  for his patches to massively improve the performance of C<getline()>
  and add C<sysread> and C<syswrite>.
  
  I<B. K. Oxley (binkley),>
  for stringification and inheritance improvements,
  and sundry good ideas.
  
  I<Doug Wilson,>
  for the IO::Handle inheritance and automatic tie-ing.
  
  
  =head1 SEE ALSO
  
  L<IO::String>, which is quite similar but which was designed
  more-recently and with an IO::Handle-like interface in mind,
  so you could mix OO- and native-filehandle usage without using tied().
  
  I<Note:> as of version 2.x, these classes all work like
  their IO::Handle counterparts, so we have comparable
  functionality to IO::String.
  
  =cut
  
TEST_BUILDER_IO_SCALAR

$fatpacked{"Test/Builder/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_MODULE';
  package Test::Builder::Module;
  
  use strict;
  
  use Test::Builder;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = '1.302136';
  
  
  =head1 NAME
  
  Test::Builder::Module - Base class for test modules
  
  =head1 SYNOPSIS
  
    # Emulates Test::Simple
    package Your::Module;
  
    my $CLASS = __PACKAGE__;
  
    use parent 'Test::Builder::Module';
    @EXPORT = qw(ok);
  
    sub ok ($;$) {
        my $tb = $CLASS->builder;
        return $tb->ok(@_);
    }
    
    1;
  
  
  =head1 DESCRIPTION
  
  This is a superclass for L<Test::Builder>-based modules.  It provides a
  handful of common functionality and a method of getting at the underlying
  L<Test::Builder> object.
  
  
  =head2 Importing
  
  Test::Builder::Module is a subclass of L<Exporter> which means your
  module is also a subclass of Exporter.  @EXPORT, @EXPORT_OK, etc...
  all act normally.
  
  A few methods are provided to do the C<< use Your::Module tests => 23 >> part
  for you.
  
  =head3 import
  
  Test::Builder::Module provides an C<import()> method which acts in the
  same basic way as L<Test::More>'s, setting the plan and controlling
  exporting of functions and variables.  This allows your module to set
  the plan independent of L<Test::More>.
  
  All arguments passed to C<import()> are passed onto 
  C<< Your::Module->builder->plan() >> with the exception of 
  C<< import =>[qw(things to import)] >>.
  
      use Your::Module import => [qw(this that)], tests => 23;
  
  says to import the functions C<this()> and C<that()> as well as set the plan
  to be 23 tests.
  
  C<import()> also sets the C<exported_to()> attribute of your builder to be
  the caller of the C<import()> function.
  
  Additional behaviors can be added to your C<import()> method by overriding
  C<import_extra()>.
  
  =cut
  
  sub import {
      my($class) = shift;
  
      Test2::API::test2_load() unless Test2::API::test2_in_preload();
  
      # Don't run all this when loading ourself.
      return 1 if $class eq 'Test::Builder::Module';
  
      my $test = $class->builder;
  
      my $caller = caller;
  
      $test->exported_to($caller);
  
      $class->import_extra( \@_ );
      my(@imports) = $class->_strip_imports( \@_ );
  
      $test->plan(@_);
  
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      $class->Exporter::import(@imports);
  }
  
  sub _strip_imports {
      my $class = shift;
      my $list  = shift;
  
      my @imports = ();
      my @other   = ();
      my $idx     = 0;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'import' ) {
              push @imports, @{ $list->[ $idx + 1 ] };
              $idx++;
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      return @imports;
  }
  
  =head3 import_extra
  
      Your::Module->import_extra(\@import_args);
  
  C<import_extra()> is called by C<import()>.  It provides an opportunity for you
  to add behaviors to your module based on its import list.
  
  Any extra arguments which shouldn't be passed on to C<plan()> should be
  stripped off by this method.
  
  See L<Test::More> for an example of its use.
  
  B<NOTE> This mechanism is I<VERY ALPHA AND LIKELY TO CHANGE> as it
  feels like a bit of an ugly hack in its current form.
  
  =cut
  
  sub import_extra { }
  
  =head2 Builder
  
  Test::Builder::Module provides some methods of getting at the underlying
  Test::Builder object.
  
  =head3 builder
  
    my $builder = Your::Class->builder;
  
  This method returns the L<Test::Builder> object associated with Your::Class.
  It is not a constructor so you can call it as often as you like.
  
  This is the preferred way to get the L<Test::Builder> object.  You should
  I<not> get it via C<< Test::Builder->new >> as was previously
  recommended.
  
  The object returned by C<builder()> may change at runtime so you should
  call C<builder()> inside each function rather than store it in a global.
  
    sub ok {
        my $builder = Your::Class->builder;
  
        return $builder->ok(@_);
    }
  
  
  =cut
  
  sub builder {
      return Test::Builder->new;
  }
  
  1;
TEST_BUILDER_MODULE

$fatpacked{"Test/Builder/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER';
  package Test::Builder::Tester;
  
  use strict;
  our $VERSION = '1.302136';
  
  use Test::Builder;
  use Symbol;
  use Carp;
  
  =head1 NAME
  
  Test::Builder::Tester - test testsuites that have been built with
  Test::Builder
  
  =head1 SYNOPSIS
  
      use Test::Builder::Tester tests => 1;
      use Test::More;
  
      test_out("not ok 1 - foo");
      test_fail(+1);
      fail("foo");
      test_test("fail works");
  
  =head1 DESCRIPTION
  
  A module that helps you test testing modules that are built with
  L<Test::Builder>.
  
  The testing system is designed to be used by performing a three step
  process for each test you wish to test.  This process starts with using
  C<test_out> and C<test_err> in advance to declare what the testsuite you
  are testing will output with L<Test::Builder> to stdout and stderr.
  
  You then can run the test(s) from your test suite that call
  L<Test::Builder>.  At this point the output of L<Test::Builder> is
  safely captured by L<Test::Builder::Tester> rather than being
  interpreted as real test output.
  
  The final stage is to call C<test_test> that will simply compare what you
  predeclared to what L<Test::Builder> actually outputted, and report the
  results back with a "ok" or "not ok" (with debugging) to the normal
  output.
  
  =cut
  
  ####
  # set up testing
  ####
  
  my $t = Test::Builder->new;
  
  ###
  # make us an exporter
  ###
  
  use Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(test_out test_err test_fail test_diag test_test line_num);
  
  sub import {
      my $class = shift;
      my(@plan) = @_;
  
      my $caller = caller;
  
      $t->exported_to($caller);
      $t->plan(@plan);
  
      my @imports = ();
      foreach my $idx ( 0 .. $#plan ) {
          if( $plan[$idx] eq 'import' ) {
              @imports = @{ $plan[ $idx + 1 ] };
              last;
          }
      }
  
      __PACKAGE__->export_to_level( 1, __PACKAGE__, @imports );
  }
  
  ###
  # set up file handles
  ###
  
  # create some private file handles
  my $output_handle = gensym;
  my $error_handle  = gensym;
  
  # and tie them to this package
  my $out = tie *$output_handle, "Test::Builder::Tester::Tie", "STDOUT";
  my $err = tie *$error_handle,  "Test::Builder::Tester::Tie", "STDERR";
  
  ####
  # exported functions
  ####
  
  # for remembering that we're testing and where we're testing at
  my $testing = 0;
  my $testing_num;
  my $original_is_passing;
  
  # remembering where the file handles were originally connected
  my $original_output_handle;
  my $original_failure_handle;
  my $original_todo_handle;
  my $original_formatter;
  
  my $original_harness_env;
  
  # function that starts testing and redirects the filehandles for now
  sub _start_testing {
      # Hack for things that conditioned on Test-Stream being loaded
      $INC{'Test/Stream.pm'} ||= 'fake' if $INC{'Test/Moose/More.pm'};
      # even if we're running under Test::Harness pretend we're not
      # for now.  This needed so Test::Builder doesn't add extra spaces
      $original_harness_env = $ENV{HARNESS_ACTIVE} || 0;
      $ENV{HARNESS_ACTIVE} = 0;
  
      my $hub = $t->{Hub} || ($t->{Stack} ? $t->{Stack}->top : Test2::API::test2_stack->top);
      $original_formatter = $hub->format;
      unless ($original_formatter && $original_formatter->isa('Test::Builder::Formatter')) {
          my $fmt = Test::Builder::Formatter->new;
          $hub->format($fmt);
      }
  
      # remember what the handles were set to
      $original_output_handle  = $t->output();
      $original_failure_handle = $t->failure_output();
      $original_todo_handle    = $t->todo_output();
  
      # switch out to our own handles
      $t->output($output_handle);
      $t->failure_output($error_handle);
      $t->todo_output($output_handle);
  
      # clear the expected list
      $out->reset();
      $err->reset();
  
      # remember that we're testing
      $testing     = 1;
      $testing_num = $t->current_test;
      $t->current_test(0);
      $original_is_passing  = $t->is_passing;
      $t->is_passing(1);
  
      # look, we shouldn't do the ending stuff
      $t->no_ending(1);
  }
  
  =head2 Functions
  
  These are the six methods that are exported as default.
  
  =over 4
  
  =item test_out
  
  =item test_err
  
  Procedures for predeclaring the output that your test suite is
  expected to produce until C<test_test> is called.  These procedures
  automatically assume that each line terminates with "\n".  So
  
     test_out("ok 1","ok 2");
  
  is the same as
  
     test_out("ok 1\nok 2");
  
  which is even the same as
  
     test_out("ok 1");
     test_out("ok 2");
  
  Once C<test_out> or C<test_err> (or C<test_fail> or C<test_diag>) have
  been called, all further output from L<Test::Builder> will be
  captured by L<Test::Builder::Tester>.  This means that you will not
  be able perform further tests to the normal output in the normal way
  until you call C<test_test> (well, unless you manually meddle with the
  output filehandles)
  
  =cut
  
  sub test_out {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $out->expect(@_);
  }
  
  sub test_err {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      $err->expect(@_);
  }
  
  =item test_fail
  
  Because the standard failure message that L<Test::Builder> produces
  whenever a test fails will be a common occurrence in your test error
  output, and because it has changed between Test::Builder versions, rather
  than forcing you to call C<test_err> with the string all the time like
  so
  
      test_err("# Failed test ($0 at line ".line_num(+1).")");
  
  C<test_fail> exists as a convenience function that can be called
  instead.  It takes one argument, the offset from the current line that
  the line that causes the fail is on.
  
      test_fail(+1);
  
  This means that the example in the synopsis could be rewritten
  more simply as:
  
     test_out("not ok 1 - foo");
     test_fail(+1);
     fail("foo");
     test_test("fail works");
  
  =cut
  
  sub test_fail {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # work out what line we should be on
      my( $package, $filename, $line ) = caller;
      $line = $line + ( shift() || 0 );    # prevent warnings
  
      # expect that on stderr
      $err->expect("#     Failed test ($filename at line $line)");
  }
  
  =item test_diag
  
  As most of the remaining expected output to the error stream will be
  created by L<Test::Builder>'s C<diag> function, L<Test::Builder::Tester>
  provides a convenience function C<test_diag> that you can use instead of
  C<test_err>.
  
  The C<test_diag> function prepends comment hashes and spacing to the
  start and newlines to the end of the expected output passed to it and
  adds it to the list of expected error output.  So, instead of writing
  
     test_err("# Couldn't open file");
  
  you can write
  
     test_diag("Couldn't open file");
  
  Remember that L<Test::Builder>'s diag function will not add newlines to
  the end of output and test_diag will. So to check
  
     Test::Builder->new->diag("foo\n","bar\n");
  
  You would do
  
    test_diag("foo","bar")
  
  without the newlines.
  
  =cut
  
  sub test_diag {
      # do we need to do any setup?
      _start_testing() unless $testing;
  
      # expect the same thing, but prepended with "#     "
      local $_;
      $err->expect( map { "# $_" } @_ );
  }
  
  =item test_test
  
  Actually performs the output check testing the tests, comparing the
  data (with C<eq>) that we have captured from L<Test::Builder> against
  what was declared with C<test_out> and C<test_err>.
  
  This takes name/value pairs that effect how the test is run.
  
  =over
  
  =item title (synonym 'name', 'label')
  
  The name of the test that will be displayed after the C<ok> or C<not
  ok>.
  
  =item skip_out
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the output stream does not match that
  declared with C<test_out>.
  
  =item skip_err
  
  Setting this to a true value will cause the test to ignore if the
  output sent by the test to the error stream does not match that
  declared with C<test_err>.
  
  =back
  
  As a convenience, if only one argument is passed then this argument
  is assumed to be the name of the test (as in the above examples.)
  
  Once C<test_test> has been run test output will be redirected back to
  the original filehandles that L<Test::Builder> was connected to
  (probably STDOUT and STDERR,) meaning any further tests you run
  will function normally and cause success/errors for L<Test::Harness>.
  
  =cut
  
  sub test_test {
      # END the hack
      delete $INC{'Test/Stream.pm'} if $INC{'Test/Stream.pm'} && $INC{'Test/Stream.pm'} eq 'fake';
      # decode the arguments as described in the pod
      my $mess;
      my %args;
      if( @_ == 1 ) {
          $mess = shift
      }
      else {
          %args = @_;
          $mess = $args{name} if exists( $args{name} );
          $mess = $args{title} if exists( $args{title} );
          $mess = $args{label} if exists( $args{label} );
      }
  
      # er, are we testing?
      croak "Not testing.  You must declare output with a test function first."
        unless $testing;
  
  
      my $hub = $t->{Hub} || Test2::API::test2_stack->top;
      $hub->format($original_formatter);
  
      # okay, reconnect the test suite back to the saved handles
      $t->output($original_output_handle);
      $t->failure_output($original_failure_handle);
      $t->todo_output($original_todo_handle);
  
      # restore the test no, etc, back to the original point
      $t->current_test($testing_num);
      $testing = 0;
      $t->is_passing($original_is_passing);
  
      # re-enable the original setting of the harness
      $ENV{HARNESS_ACTIVE} = $original_harness_env;
  
      # check the output we've stashed
      unless( $t->ok( ( $args{skip_out} || $out->check ) &&
                      ( $args{skip_err} || $err->check ), $mess ) 
      )
      {
          # print out the diagnostic information about why this
          # test failed
  
          local $_;
  
          $t->diag( map { "$_\n" } $out->complaint )
            unless $args{skip_out} || $out->check;
  
          $t->diag( map { "$_\n" } $err->complaint )
            unless $args{skip_err} || $err->check;
      }
  }
  
  =item line_num
  
  A utility function that returns the line number that the function was
  called on.  You can pass it an offset which will be added to the
  result.  This is very useful for working out the correct text of
  diagnostic functions that contain line numbers.
  
  Essentially this is the same as the C<__LINE__> macro, but the
  C<line_num(+3)> idiom is arguably nicer.
  
  =cut
  
  sub line_num {
      my( $package, $filename, $line ) = caller;
      return $line + ( shift() || 0 );    # prevent warnings
  }
  
  =back
  
  In addition to the six exported functions there exists one
  function that can only be accessed with a fully qualified function
  call.
  
  =over 4
  
  =item color
  
  When C<test_test> is called and the output that your tests generate
  does not match that which you declared, C<test_test> will print out
  debug information showing the two conflicting versions.  As this
  output itself is debug information it can be confusing which part of
  the output is from C<test_test> and which was the original output from
  your original tests.  Also, it may be hard to spot things like
  extraneous whitespace at the end of lines that may cause your test to
  fail even though the output looks similar.
  
  To assist you C<test_test> can colour the background of the debug
  information to disambiguate the different types of output. The debug
  output will have its background coloured green and red.  The green
  part represents the text which is the same between the executed and
  actual output, the red shows which part differs.
  
  The C<color> function determines if colouring should occur or not.
  Passing it a true or false value will enable or disable colouring
  respectively, and the function called with no argument will return the
  current setting.
  
  To enable colouring from the command line, you can use the
  L<Text::Builder::Tester::Color> module like so:
  
     perl -Mlib=Text::Builder::Tester::Color test.t
  
  Or by including the L<Test::Builder::Tester::Color> module directly in
  the PERL5LIB.
  
  =cut
  
  my $color;
  
  sub color {
      $color = shift if @_;
      $color;
  }
  
  =back
  
  =head1 BUGS
  
  Test::Builder::Tester does not handle plans well. It has never done anything
  special with plans. This means that plans from outside Test::Builder::Tester
  will effect Test::Builder::Tester, worse plans when using Test::Builder::Tester
  will effect overall testing. At this point there are no plans to fix this bug
  as people have come to depend on it, and Test::Builder::Tester is now
  discouraged in favor of C<Test2::API::intercept()>. See
  L<https://github.com/Test-More/test-more/issues/667>
  
  Calls C<< Test::Builder->no_ending >> turning off the ending tests.
  This is needed as otherwise it will trip out because we've run more
  tests than we strictly should have and it'll register any failures we
  had that we were testing for as real failures.
  
  The color function doesn't work unless L<Term::ANSIColor> is
  compatible with your terminal. Additionally, L<Win32::Console::ANSI>
  must be installed on windows platforms for color output.
  
  Bugs (and requests for new features) can be reported to the author
  though GitHub:
  L<https://github.com/Test-More/test-more/issues>
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002, 2004.
  
  Some code taken from L<Test::More> and L<Test::Catch>, written by
  Michael G Schwern E<lt>schwern@pobox.comE<gt>.  Hence, those parts
  Copyright Micheal G Schwern 2001.  Used and distributed with
  permission.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 NOTES
  
  Thanks to Richard Clamp E<lt>richardc@unixbeard.netE<gt> for letting
  me use his testing system to try this module out on.
  
  =head1 SEE ALSO
  
  L<Test::Builder>, L<Test::Builder::Tester::Color>, L<Test::More>.
  
  =cut
  
  1;
  
  ####################################################################
  # Helper class that is used to remember expected and received data
  
  package Test::Builder::Tester::Tie;
  
  ##
  # add line(s) to be expected
  
  sub expect {
      my $self = shift;
  
      my @checks = @_;
      foreach my $check (@checks) {
          $check = $self->_account_for_subtest($check);
          $check = $self->_translate_Failed_check($check);
          push @{ $self->{wanted} }, ref $check ? $check : "$check\n";
      }
  }
  
  sub _account_for_subtest {
      my( $self, $check ) = @_;
  
      my $hub = $t->{Stack}->top;
      my $nesting = $hub->isa('Test2::Hub::Subtest') ? $hub->nested : 0;
      return ref($check) ? $check : ('    ' x $nesting) . $check;
  }
  
  sub _translate_Failed_check {
      my( $self, $check ) = @_;
  
      if( $check =~ /\A(.*)#     (Failed .*test) \((.*?) at line (\d+)\)\Z(?!\n)/ ) {
          $check = "/\Q$1\E#\\s+\Q$2\E.*?\\n?.*?\Qat $3\E line \Q$4\E.*\\n?/";
      }
  
      return $check;
  }
  
  ##
  # return true iff the expected data matches the got data
  
  sub check {
      my $self = shift;
  
      # turn off warnings as these might be undef
      local $^W = 0;
  
      my @checks = @{ $self->{wanted} };
      my $got    = $self->{got};
      foreach my $check (@checks) {
          $check = "\Q$check\E" unless( $check =~ s,^/(.*)/$,$1, or ref $check );
          return 0 unless $got =~ s/^$check//;
      }
  
      return length $got == 0;
  }
  
  ##
  # a complaint message about the inputs not matching (to be
  # used for debugging messages)
  
  sub complaint {
      my $self   = shift;
      my $type   = $self->type;
      my $got    = $self->got;
      my $wanted = join '', @{ $self->wanted };
  
      # are we running in colour mode?
      if(Test::Builder::Tester::color) {
          # get color
          eval { require Term::ANSIColor };
          unless($@) {
              eval { require Win32::Console::ANSI } if 'MSWin32' eq $^O;  # support color on windows platforms
  
              # colours
  
              my $green = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_green");
              my $red   = Term::ANSIColor::color("black") . Term::ANSIColor::color("on_red");
              my $reset = Term::ANSIColor::color("reset");
  
              # work out where the two strings start to differ
              my $char = 0;
              $char++ while substr( $got, $char, 1 ) eq substr( $wanted, $char, 1 );
  
              # get the start string and the two end strings
              my $start = $green . substr( $wanted, 0, $char );
              my $gotend    = $red . substr( $got,    $char ) . $reset;
              my $wantedend = $red . substr( $wanted, $char ) . $reset;
  
              # make the start turn green on and off
              $start =~ s/\n/$reset\n$green/g;
  
              # make the ends turn red on and off
              $gotend    =~ s/\n/$reset\n$red/g;
              $wantedend =~ s/\n/$reset\n$red/g;
  
              # rebuild the strings
              $got    = $start . $gotend;
              $wanted = $start . $wantedend;
          }
      }
  
      my @got = split "\n", $got;
      my @wanted = split "\n", $wanted;
  
      $got = "";
      $wanted = "";
  
      while (@got || @wanted) {
          my $g = shift @got    || "";
          my $w = shift @wanted || "";
          if ($g ne $w) {
              if($g =~ s/(\s+)$/    |> /g) {
                  $g .= ($_ eq ' ' ? '_' : '\t') for split '', $1;
              }
              if($w =~ s/(\s+)$/    |> /g) {
                  $w .= ($_ eq ' ' ? '_' : '\t') for split '', $1;
              }
              $g = "> $g";
              $w = "> $w";
          }
          else {
              $g = "  $g";
              $w = "  $w";
          }
          $got = $got ? "$got\n$g" : $g;
          $wanted = $wanted ? "$wanted\n$w" : $w;
      }
  
      return "$type is:\n" . "$got\nnot:\n$wanted\nas expected";
  }
  
  ##
  # forget all expected and got data
  
  sub reset {
      my $self = shift;
      %$self = (
          type   => $self->{type},
          got    => '',
          wanted => [],
      );
  }
  
  sub got {
      my $self = shift;
      return $self->{got};
  }
  
  sub wanted {
      my $self = shift;
      return $self->{wanted};
  }
  
  sub type {
      my $self = shift;
      return $self->{type};
  }
  
  ###
  # tie interface
  ###
  
  sub PRINT {
      my $self = shift;
      $self->{got} .= join '', @_;
  }
  
  sub TIEHANDLE {
      my( $class, $type ) = @_;
  
      my $self = bless { type => $type }, $class;
  
      $self->reset;
  
      return $self;
  }
  
  sub READ     { }
  sub READLINE { }
  sub GETC     { }
  sub FILENO   { }
  
  1;
TEST_BUILDER_TESTER

$fatpacked{"Test/Builder/Tester/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER_COLOR';
  package Test::Builder::Tester::Color;
  
  use strict;
  our $VERSION = '1.302136';
  
  require Test::Builder::Tester;
  
  
  =head1 NAME
  
  Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester
  
  =head1 SYNOPSIS
  
     When running a test script
  
       perl -MTest::Builder::Tester::Color test.t
  
  =head1 DESCRIPTION
  
  Importing this module causes the subroutine color in Test::Builder::Tester
  to be called with a true value causing colour highlighting to be turned
  on in debug output.
  
  The sole purpose of this module is to enable colour highlighting
  from the command line.
  
  =cut
  
  sub import {
      Test::Builder::Tester::color(1);
  }
  
  =head1 AUTHOR
  
  Copyright Mark Fowler E<lt>mark@twoshortplanks.comE<gt> 2002.
  
  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  =head1 BUGS
  
  This module will have no effect unless Term::ANSIColor is installed.
  
  =head1 SEE ALSO
  
  L<Test::Builder::Tester>, L<Term::ANSIColor>
  
  =cut
  
  1;
TEST_BUILDER_TESTER_COLOR

$fatpacked{"Test/Builder/TodoDiag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TODODIAG';
  package Test::Builder::TodoDiag;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Event::Diag; our @ISA = qw(Test2::Event::Diag) }
  
  sub diagnostics { 0 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->SUPER::facet_data();
      $out->{info}->[0]->{debug} = 0;
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::Builder::TodoDiag - Test::Builder subclass of Test2::Event::Diag
  
  =head1 DESCRIPTION
  
  This is used to encapsulate diag messages created inside TODO.
  
  =head1 SYNOPSIS
  
  You do not need to use this directly.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST_BUILDER_TODODIAG

$fatpacked{"Test/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MORE';
  package Test::More;
  
  use 5.006;
  use strict;
  use warnings;
  
  #---- perlcritic exemptions. ----#
  
  # We use a lot of subroutine prototypes
  ## no critic (Subroutines::ProhibitSubroutinePrototypes)
  
  # Can't use Carp because it might cause C<use_ok()> to accidentally succeed
  # even though the module being used forgot to use Carp.  Yes, this
  # actually happened.
  sub _carp {
      my( $file, $line ) = ( caller(1) )[ 1, 2 ];
      return warn @_, " at $file line $line\n";
  }
  
  our $VERSION = '1.302136';
  
  use Test::Builder::Module;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok use_ok require_ok
    is isnt like unlike is_deeply
    cmp_ok
    skip todo todo_skip
    pass fail
    eq_array eq_hash eq_set
    $TODO
    plan
    done_testing
    can_ok isa_ok new_ok
    diag note explain
    subtest
    BAIL_OUT
  );
  
  =head1 NAME
  
  Test::More - yet another framework for writing test scripts
  
  =head1 SYNOPSIS
  
    use Test::More tests => 23;
    # or
    use Test::More skip_all => $reason;
    # or
    use Test::More;   # see done_testing()
  
    require_ok( 'Some::Module' );
  
    # Various ways to say "ok"
    ok($got eq $expected, $test_name);
  
    is  ($got, $expected, $test_name);
    isnt($got, $expected, $test_name);
  
    # Rather than print STDERR "# here's what went wrong\n"
    diag("here's what went wrong");
  
    like  ($got, qr/expected/, $test_name);
    unlike($got, qr/expected/, $test_name);
  
    cmp_ok($got, '==', $expected, $test_name);
  
    is_deeply($got_complex_structure, $expected_complex_structure, $test_name);
  
    SKIP: {
        skip $why, $how_many unless $have_some_feature;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    TODO: {
        local $TODO = $why;
  
        ok( foo(),       $test_name );
        is( foo(42), 23, $test_name );
    };
  
    can_ok($module, @methods);
    isa_ok($object, $class);
  
    pass($test_name);
    fail($test_name);
  
    BAIL_OUT($why);
  
    # UNIMPLEMENTED!!!
    my @status = Test::More::status;
  
  
  =head1 DESCRIPTION
  
  B<STOP!> If you're just getting started writing tests, have a look at
  L<Test::Simple> first.  This is a drop in replacement for Test::Simple
  which you can switch to once you get the hang of basic testing.
  
  The purpose of this module is to provide a wide range of testing
  utilities.  Various ways to say "ok" with better diagnostics,
  facilities to skip tests, test future features and compare complicated
  data structures.  While you can do almost anything with a simple
  C<ok()> function, it doesn't provide good diagnostic output.
  
  
  =head2 I love it when a plan comes together
  
  Before anything else, you need a testing plan.  This basically declares
  how many tests your script is going to run to protect against premature
  failure.
  
  The preferred way to do this is to declare a plan when you C<use Test::More>.
  
    use Test::More tests => 23;
  
  There are cases when you will not know beforehand how many tests your
  script is going to run.  In this case, you can declare your tests at
  the end.
  
    use Test::More;
  
    ... run your tests ...
  
    done_testing( $number_of_tests_run );
  
  B<NOTE> C<done_testing()> should never be called in an C<END { ... }> block.
  
  Sometimes you really don't know how many tests were run, or it's too
  difficult to calculate.  In which case you can leave off
  $number_of_tests_run.
  
  In some cases, you'll want to completely skip an entire testing script.
  
    use Test::More skip_all => $skip_reason;
  
  Your script will declare a skip with the reason why you skipped and
  exit immediately with a zero (success).  See L<Test::Harness> for
  details.
  
  If you want to control what functions Test::More will export, you
  have to use the 'import' option.  For example, to import everything
  but 'fail', you'd do:
  
    use Test::More tests => 23, import => ['!fail'];
  
  Alternatively, you can use the C<plan()> function.  Useful for when you
  have to calculate the number of tests.
  
    use Test::More;
    plan tests => keys %Stuff * 3;
  
  or for deciding between running the tests at all:
  
    use Test::More;
    if( $^O eq 'MacOS' ) {
        plan skip_all => 'Test irrelevant on MacOS';
    }
    else {
        plan tests => 42;
    }
  
  =cut
  
  sub plan {
      my $tb = Test::More->builder;
  
      return $tb->plan(@_);
  }
  
  # This implements "use Test::More 'no_diag'" but the behavior is
  # deprecated.
  sub import_extra {
      my $class = shift;
      my $list  = shift;
  
      my @other = ();
      my $idx   = 0;
      my $import;
      while( $idx <= $#{$list} ) {
          my $item = $list->[$idx];
  
          if( defined $item and $item eq 'no_diag' ) {
              $class->builder->no_diag(1);
          }
          elsif( defined $item and $item eq 'import' ) {
              if ($import) {
                  push @$import, @{$list->[ ++$idx ]};
              }
              else {
                  $import = $list->[ ++$idx ];
                  push @other, $item, $import;
              }
          }
          else {
              push @other, $item;
          }
  
          $idx++;
      }
  
      @$list = @other;
  
      if ($class eq __PACKAGE__ && (!$import || grep $_ eq '$TODO', @$import)) {
          my $to = $class->builder->exported_to;
          no strict 'refs';
          *{"$to\::TODO"} = \our $TODO;
          if ($import) {
              @$import = grep $_ ne '$TODO', @$import;
          }
          else {
              push @$list, import => [grep $_ ne '$TODO', @EXPORT];
          }
      }
  
      return;
  }
  
  =over 4
  
  =item B<done_testing>
  
      done_testing();
      done_testing($number_of_tests);
  
  If you don't know how many tests you're going to run, you can issue
  the plan when you're done running tests.
  
  $number_of_tests is the same as C<plan()>, it's the number of tests you
  expected to run.  You can omit this, in which case the number of tests
  you ran doesn't matter, just the fact that your tests ran to
  conclusion.
  
  This is safer than and replaces the "no_plan" plan.
  
  B<Note:> You must never put C<done_testing()> inside an C<END { ... }> block.
  The plan is there to ensure your test does not exit before testing has
  completed. If you use an END block you completely bypass this protection.
  
  =back
  
  =cut
  
  sub done_testing {
      my $tb = Test::More->builder;
      $tb->done_testing(@_);
  }
  
  =head2 Test names
  
  By convention, each test is assigned a number in order.  This is
  largely done automatically for you.  However, it's often very useful to
  assign a name to each test.  Which would you rather see:
  
    ok 4
    not ok 5
    ok 6
  
  or
  
    ok 4 - basic multi-variable
    not ok 5 - simple exponential
    ok 6 - force == mass * acceleration
  
  The later gives you some idea of what failed.  It also makes it easier
  to find the test in your script, simply search for "simple
  exponential".
  
  All test functions take a name argument.  It's optional, but highly
  suggested that you use it.
  
  =head2 I'm ok, you're not ok.
  
  The basic purpose of this module is to print out either "ok #" or "not
  ok #" depending on if a given test succeeded or failed.  Everything
  else is just gravy.
  
  All of the following print "ok" or "not ok" depending on if the test
  succeeded or failed.  They all also return true or false,
  respectively.
  
  =over 4
  
  =item B<ok>
  
    ok($got eq $expected, $test_name);
  
  This simply evaluates any expression (C<$got eq $expected> is just a
  simple example) and uses that to determine if the test succeeded or
  failed.  A true expression passes, a false one fails.  Very simple.
  
  For example:
  
      ok( $exp{9} == 81,                   'simple exponential' );
      ok( Film->can('db_Main'),            'set_db()' );
      ok( $p->tests == 4,                  'saw tests' );
      ok( !grep(!defined $_, @items),      'all items defined' );
  
  (Mnemonic:  "This is ok.")
  
  $test_name is a very short description of the test that will be printed
  out.  It makes it very easy to find a test in your script when it fails
  and gives others an idea of your intentions.  $test_name is optional,
  but we B<very> strongly encourage its use.
  
  Should an C<ok()> fail, it will produce some diagnostics:
  
      not ok 18 - sufficient mucus
      #   Failed test 'sufficient mucus'
      #   in foo.t at line 42.
  
  This is the same as L<Test::Simple>'s C<ok()> routine.
  
  =cut
  
  sub ok ($;$) {
      my( $test, $name ) = @_;
      my $tb = Test::More->builder;
  
      return $tb->ok( $test, $name );
  }
  
  =item B<is>
  
  =item B<isnt>
  
    is  ( $got, $expected, $test_name );
    isnt( $got, $expected, $test_name );
  
  Similar to C<ok()>, C<is()> and C<isnt()> compare their two arguments
  with C<eq> and C<ne> respectively and use the result of that to
  determine if the test succeeded or failed.  So these:
  
      # Is the ultimate answer 42?
      is( ultimate_answer(), 42,          "Meaning of Life" );
  
      # $foo isn't empty
      isnt( $foo, '',     "Got some foo" );
  
  are similar to these:
  
      ok( ultimate_answer() eq 42,        "Meaning of Life" );
      ok( $foo ne '',     "Got some foo" );
  
  C<undef> will only ever match C<undef>.  So you can test a value
  against C<undef> like this:
  
      is($not_defined, undef, "undefined as expected");
  
  (Mnemonic:  "This is that."  "This isn't that.")
  
  So why use these?  They produce better diagnostics on failure.  C<ok()>
  cannot know what you are testing for (beyond the name), but C<is()> and
  C<isnt()> know what the test was and why it failed.  For example this
  test:
  
      my $foo = 'waffle';  my $bar = 'yarblokos';
      is( $foo, $bar,   'Is foo the same as bar?' );
  
  Will produce something like this:
  
      not ok 17 - Is foo the same as bar?
      #   Failed test 'Is foo the same as bar?'
      #   in foo.t at line 139.
      #          got: 'waffle'
      #     expected: 'yarblokos'
  
  So you can figure out what went wrong without rerunning the test.
  
  You are encouraged to use C<is()> and C<isnt()> over C<ok()> where possible,
  however do not be tempted to use them to find out if something is
  true or false!
  
    # XXX BAD!
    is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );
  
  This does not check if C<exists $brooklyn{tree}> is true, it checks if
  it returns 1.  Very different.  Similar caveats exist for false and 0.
  In these cases, use C<ok()>.
  
    ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );
  
  A simple call to C<isnt()> usually does not provide a strong test but there
  are cases when you cannot say much more about a value than that it is
  different from some other value:
  
    new_ok $obj, "Foo";
  
    my $clone = $obj->clone;
    isa_ok $obj, "Foo", "Foo->clone";
  
    isnt $obj, $clone, "clone() produces a different object";
  
  For those grammatical pedants out there, there's an C<isn't()>
  function which is an alias of C<isnt()>.
  
  =cut
  
  sub is ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->is_eq(@_);
  }
  
  sub isnt ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->isnt_eq(@_);
  }
  
  *isn't = \&isnt;
  # ' to unconfuse syntax higlighters
  
  =item B<like>
  
    like( $got, qr/expected/, $test_name );
  
  Similar to C<ok()>, C<like()> matches $got against the regex C<qr/expected/>.
  
  So this:
  
      like($got, qr/expected/, 'this is like that');
  
  is similar to:
  
      ok( $got =~ m/expected/, 'this is like that');
  
  (Mnemonic "This is like that".)
  
  The second argument is a regular expression.  It may be given as a
  regex reference (i.e. C<qr//>) or (for better compatibility with older
  perls) as a string that looks like a regex (alternative delimiters are
  currently not supported):
  
      like( $got, '/expected/', 'this is like that' );
  
  Regex options may be placed on the end (C<'/expected/i'>).
  
  Its advantages over C<ok()> are similar to that of C<is()> and C<isnt()>.  Better
  diagnostics on failure.
  
  =cut
  
  sub like ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->like(@_);
  }
  
  =item B<unlike>
  
    unlike( $got, qr/expected/, $test_name );
  
  Works exactly as C<like()>, only it checks if $got B<does not> match the
  given pattern.
  
  =cut
  
  sub unlike ($$;$) {
      my $tb = Test::More->builder;
  
      return $tb->unlike(@_);
  }
  
  =item B<cmp_ok>
  
    cmp_ok( $got, $op, $expected, $test_name );
  
  Halfway between C<ok()> and C<is()> lies C<cmp_ok()>.  This allows you
  to compare two arguments using any binary perl operator.  The test
  passes if the comparison is true and fails otherwise.
  
      # ok( $got eq $expected );
      cmp_ok( $got, 'eq', $expected, 'this eq that' );
  
      # ok( $got == $expected );
      cmp_ok( $got, '==', $expected, 'this == that' );
  
      # ok( $got && $expected );
      cmp_ok( $got, '&&', $expected, 'this && that' );
      ...etc...
  
  Its advantage over C<ok()> is when the test fails you'll know what $got
  and $expected were:
  
      not ok 1
      #   Failed test in foo.t at line 12.
      #     '23'
      #         &&
      #     undef
  
  It's also useful in those cases where you are comparing numbers and
  C<is()>'s use of C<eq> will interfere:
  
      cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );
  
  It's especially useful when comparing greater-than or smaller-than 
  relation between values:
  
      cmp_ok( $some_value, '<=', $upper_limit );
  
  
  =cut
  
  sub cmp_ok($$$;$) {
      my $tb = Test::More->builder;
  
      return $tb->cmp_ok(@_);
  }
  
  =item B<can_ok>
  
    can_ok($module, @methods);
    can_ok($object, @methods);
  
  Checks to make sure the $module or $object can do these @methods
  (works with functions, too).
  
      can_ok('Foo', qw(this that whatever));
  
  is almost exactly like saying:
  
      ok( Foo->can('this') && 
          Foo->can('that') && 
          Foo->can('whatever') 
        );
  
  only without all the typing and with a better interface.  Handy for
  quickly testing an interface.
  
  No matter how many @methods you check, a single C<can_ok()> call counts
  as one test.  If you desire otherwise, use:
  
      foreach my $meth (@methods) {
          can_ok('Foo', $meth);
      }
  
  =cut
  
  sub can_ok ($@) {
      my( $proto, @methods ) = @_;
      my $class = ref $proto || $proto;
      my $tb = Test::More->builder;
  
      unless($class) {
          my $ok = $tb->ok( 0, "->can(...)" );
          $tb->diag('    can_ok() called with empty class or reference');
          return $ok;
      }
  
      unless(@methods) {
          my $ok = $tb->ok( 0, "$class->can(...)" );
          $tb->diag('    can_ok() called with no methods');
          return $ok;
      }
  
      my @nok = ();
      foreach my $method (@methods) {
          $tb->_try( sub { $proto->can($method) } ) or push @nok, $method;
      }
  
      my $name = (@methods == 1) ? "$class->can('$methods[0]')" :
                                   "$class->can(...)"           ;
  
      my $ok = $tb->ok( !@nok, $name );
  
      $tb->diag( map "    $class->can('$_') failed\n", @nok );
  
      return $ok;
  }
  
  =item B<isa_ok>
  
    isa_ok($object,   $class, $object_name);
    isa_ok($subclass, $class, $object_name);
    isa_ok($ref,      $type,  $ref_name);
  
  Checks to see if the given C<< $object->isa($class) >>.  Also checks to make
  sure the object was defined in the first place.  Handy for this sort
  of thing:
  
      my $obj = Some::Module->new;
      isa_ok( $obj, 'Some::Module' );
  
  where you'd otherwise have to write
  
      my $obj = Some::Module->new;
      ok( defined $obj && $obj->isa('Some::Module') );
  
  to safeguard against your test script blowing up.
  
  You can also test a class, to make sure that it has the right ancestor:
  
      isa_ok( 'Vole', 'Rodent' );
  
  It works on references, too:
  
      isa_ok( $array_ref, 'ARRAY' );
  
  The diagnostics of this test normally just refer to 'the object'.  If
  you'd like them to be more specific, you can supply an $object_name
  (for example 'Test customer').
  
  =cut
  
  sub isa_ok ($$;$) {
      my( $thing, $class, $thing_name ) = @_;
      my $tb = Test::More->builder;
  
      my $whatami;
      if( !defined $thing ) {
          $whatami = 'undef';
      }
      elsif( ref $thing ) {
          $whatami = 'reference';
  
          local($@,$!);
          require Scalar::Util;
          if( Scalar::Util::blessed($thing) ) {
              $whatami = 'object';
          }
      }
      else {
          $whatami = 'class';
      }
  
      # We can't use UNIVERSAL::isa because we want to honor isa() overrides
      my( $rslt, $error ) = $tb->_try( sub { $thing->isa($class) } );
  
      if($error) {
          die <<WHOA unless $error =~ /^Can't (locate|call) method "isa"/;
  WHOA! I tried to call ->isa on your $whatami and got some weird error.
  Here's the error.
  $error
  WHOA
      }
  
      # Special case for isa_ok( [], "ARRAY" ) and like
      if( $whatami eq 'reference' ) {
          $rslt = UNIVERSAL::isa($thing, $class);
      }
  
      my($diag, $name);
      if( defined $thing_name ) {
          $name = "'$thing_name' isa '$class'";
          $diag = defined $thing ? "'$thing_name' isn't a '$class'" : "'$thing_name' isn't defined";
      }
      elsif( $whatami eq 'object' ) {
          my $my_class = ref $thing;
          $thing_name = qq[An object of class '$my_class'];
          $name = "$thing_name isa '$class'";
          $diag = "The object of class '$my_class' isn't a '$class'";
      }
      elsif( $whatami eq 'reference' ) {
          my $type = ref $thing;
          $thing_name = qq[A reference of type '$type'];
          $name = "$thing_name isa '$class'";
          $diag = "The reference of type '$type' isn't a '$class'";
      }
      elsif( $whatami eq 'undef' ) {
          $thing_name = 'undef';
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't defined";
      }
      elsif( $whatami eq 'class' ) {
          $thing_name = qq[The class (or class-like) '$thing'];
          $name = "$thing_name isa '$class'";
          $diag = "$thing_name isn't a '$class'";
      }
      else {
          die;
      }
  
      my $ok;
      if($rslt) {
          $ok = $tb->ok( 1, $name );
      }
      else {
          $ok = $tb->ok( 0, $name );
          $tb->diag("    $diag\n");
      }
  
      return $ok;
  }
  
  =item B<new_ok>
  
    my $obj = new_ok( $class );
    my $obj = new_ok( $class => \@args );
    my $obj = new_ok( $class => \@args, $object_name );
  
  A convenience function which combines creating an object and calling
  C<isa_ok()> on that object.
  
  It is basically equivalent to:
  
      my $obj = $class->new(@args);
      isa_ok $obj, $class, $object_name;
  
  If @args is not given, an empty list will be used.
  
  This function only works on C<new()> and it assumes C<new()> will return
  just a single object which isa C<$class>.
  
  =cut
  
  sub new_ok {
      my $tb = Test::More->builder;
      $tb->croak("new_ok() must be given at least a class") unless @_;
  
      my( $class, $args, $object_name ) = @_;
  
      $args ||= [];
  
      my $obj;
      my( $success, $error ) = $tb->_try( sub { $obj = $class->new(@$args); 1 } );
      if($success) {
          local $Test::Builder::Level = $Test::Builder::Level + 1;
          isa_ok $obj, $class, $object_name;
      }
      else {
          $class = 'undef' if !defined $class;
          $tb->ok( 0, "$class->new() died" );
          $tb->diag("    Error was:  $error");
      }
  
      return $obj;
  }
  
  =item B<subtest>
  
      subtest $name => \&code, @args;
  
  C<subtest()> runs the &code as its own little test with its own plan and
  its own result.  The main test counts this as a single test using the
  result of the whole subtest to determine if its ok or not ok.
  
  For example...
  
    use Test::More tests => 3;
   
    pass("First test");
  
    subtest 'An example subtest' => sub {
        plan tests => 2;
  
        pass("This is a subtest");
        pass("So is this");
    };
  
    pass("Third test");
  
  This would produce.
  
    1..3
    ok 1 - First test
        # Subtest: An example subtest
        1..2
        ok 1 - This is a subtest
        ok 2 - So is this
    ok 2 - An example subtest
    ok 3 - Third test
  
  A subtest may call C<skip_all>.  No tests will be run, but the subtest is
  considered a skip.
  
    subtest 'skippy' => sub {
        plan skip_all => 'cuz I said so';
        pass('this test will never be run');
    };
  
  Returns true if the subtest passed, false otherwise.
  
  Due to how subtests work, you may omit a plan if you desire.  This adds an
  implicit C<done_testing()> to the end of your subtest.  The following two
  subtests are equivalent:
  
    subtest 'subtest with implicit done_testing()', sub {
        ok 1, 'subtests with an implicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
    };
  
    subtest 'subtest with explicit done_testing()', sub {
        ok 1, 'subtests with an explicit done testing should work';
        ok 1, '... and support more than one test';
        ok 1, '... no matter how many tests are run';
        done_testing();
    };
  
  Extra arguments given to C<subtest> are passed to the callback. For example:
  
      sub my_subtest {
          my $range = shift;
          ...
      }
  
      for my $range (1, 10, 100, 1000) {
          subtest "testing range $range", \&my_subtest, $range;
      }
  
  =cut
  
  sub subtest {
      my $tb = Test::More->builder;
      return $tb->subtest(@_);
  }
  
  =item B<pass>
  
  =item B<fail>
  
    pass($test_name);
    fail($test_name);
  
  Sometimes you just want to say that the tests have passed.  Usually
  the case is you've got some complicated condition that is difficult to
  wedge into an C<ok()>.  In this case, you can simply use C<pass()> (to
  declare the test ok) or fail (for not ok).  They are synonyms for
  C<ok(1)> and C<ok(0)>.
  
  Use these very, very, very sparingly.
  
  =cut
  
  sub pass (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 1, @_ );
  }
  
  sub fail (;$) {
      my $tb = Test::More->builder;
  
      return $tb->ok( 0, @_ );
  }
  
  =back
  
  
  =head2 Module tests
  
  Sometimes you want to test if a module, or a list of modules, can
  successfully load.  For example, you'll often want a first test which
  simply loads all the modules in the distribution to make sure they
  work before going on to do more complicated testing.
  
  For such purposes we have C<use_ok> and C<require_ok>.
  
  =over 4
  
  =item B<require_ok>
  
     require_ok($module);
     require_ok($file);
  
  Tries to C<require> the given $module or $file.  If it loads
  successfully, the test will pass.  Otherwise it fails and displays the
  load error.
  
  C<require_ok> will guess whether the input is a module name or a
  filename.
  
  No exception will be thrown if the load fails.
  
      # require Some::Module
      require_ok "Some::Module";
  
      # require "Some/File.pl";
      require_ok "Some/File.pl";
  
      # stop testing if any of your modules will not load
      for my $module (@module) {
          require_ok $module or BAIL_OUT "Can't load $module";
      }
  
  =cut
  
  sub require_ok ($) {
      my($module) = shift;
      my $tb = Test::More->builder;
  
      my $pack = caller;
  
      # Try to determine if we've been given a module name or file.
      # Module names must be barewords, files not.
      $module = qq['$module'] unless _is_module_name($module);
  
      my $code = <<REQUIRE;
  package $pack;
  require $module;
  1;
  REQUIRE
  
      my( $eval_result, $eval_error ) = _eval($code);
      my $ok = $tb->ok( $eval_result, "require $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $tb->diag(<<DIAGNOSTIC);
      Tried to require '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _is_module_name {
      my $module = shift;
  
      # Module names start with a letter.
      # End with an alphanumeric.
      # The rest is an alphanumeric or ::
      $module =~ s/\b::\b//g;
  
      return $module =~ /^[a-zA-Z]\w*$/ ? 1 : 0;
  }
  
  
  =item B<use_ok>
  
     BEGIN { use_ok($module); }
     BEGIN { use_ok($module, @imports); }
  
  Like C<require_ok>, but it will C<use> the $module in question and
  only loads modules, not files.
  
  If you just want to test a module can be loaded, use C<require_ok>.
  
  If you just want to load a module in a test, we recommend simply using
  C<use> directly.  It will cause the test to stop.
  
  It's recommended that you run C<use_ok()> inside a BEGIN block so its
  functions are exported at compile-time and prototypes are properly
  honored.
  
  If @imports are given, they are passed through to the use.  So this:
  
     BEGIN { use_ok('Some::Module', qw(foo bar)) }
  
  is like doing this:
  
     use Some::Module qw(foo bar);
  
  Version numbers can be checked like so:
  
     # Just like "use Some::Module 1.02"
     BEGIN { use_ok('Some::Module', 1.02) }
  
  Don't try to do this:
  
     BEGIN {
         use_ok('Some::Module');
  
         ...some code that depends on the use...
         ...happening at compile time...
     }
  
  because the notion of "compile-time" is relative.  Instead, you want:
  
    BEGIN { use_ok('Some::Module') }
    BEGIN { ...some code that depends on the use... }
  
  If you want the equivalent of C<use Foo ()>, use a module but not
  import anything, use C<require_ok>.
  
    BEGIN { require_ok "Foo" }
  
  =cut
  
  sub use_ok ($;@) {
      my( $module, @imports ) = @_;
      @imports = () unless @imports;
      my $tb = Test::More->builder;
  
      my %caller;
      @caller{qw/pack file line sub args want eval req strict warn/} = caller(0);
  
      my ($pack, $filename, $line, $warn) = @caller{qw/pack file line warn/};
      $filename =~ y/\n\r/_/; # so it doesn't run off the "#line $line $f" line
  
      my $code;
      if( @imports == 1 and $imports[0] =~ /^\d+(?:\.\d+)?$/ ) {
          # probably a version check.  Perl needs to see the bare number
          # for it to work with non-Exporter based modules.
          $code = <<USE;
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module $imports[0];
  1;
  USE
      }
      else {
          $code = <<USE;
  package $pack;
  BEGIN { \${^WARNING_BITS} = \$args[-1] if defined \$args[-1] }
  #line $line $filename
  use $module \@{\$args[0]};
  1;
  USE
      }
  
      my ($eval_result, $eval_error) = _eval($code, \@imports, $warn);
      my $ok = $tb->ok( $eval_result, "use $module;" );
  
      unless($ok) {
          chomp $eval_error;
          $@ =~ s{^BEGIN failed--compilation aborted at .*$}
                  {BEGIN failed--compilation aborted at $filename line $line.}m;
          $tb->diag(<<DIAGNOSTIC);
      Tried to use '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  
      }
  
      return $ok;
  }
  
  sub _eval {
      my( $code, @args ) = @_;
  
      # Work around oddities surrounding resetting of $@ by immediately
      # storing it.
      my( $sigdie, $eval_result, $eval_error );
      {
          local( $@, $!, $SIG{__DIE__} );    # isolate eval
          $eval_result = eval $code;              ## no critic (BuiltinFunctions::ProhibitStringyEval)
          $eval_error  = $@;
          $sigdie      = $SIG{__DIE__} || undef;
      }
      # make sure that $code got a chance to set $SIG{__DIE__}
      $SIG{__DIE__} = $sigdie if defined $sigdie;
  
      return( $eval_result, $eval_error );
  }
  
  
  =back
  
  
  =head2 Complex data structures
  
  Not everything is a simple eq check or regex.  There are times you
  need to see if two data structures are equivalent.  For these
  instances Test::More provides a handful of useful functions.
  
  B<NOTE> I'm not quite sure what will happen with filehandles.
  
  =over 4
  
  =item B<is_deeply>
  
    is_deeply( $got, $expected, $test_name );
  
  Similar to C<is()>, except that if $got and $expected are references, it
  does a deep comparison walking each data structure to see if they are
  equivalent.  If the two structures are different, it will display the
  place where they start differing.
  
  C<is_deeply()> compares the dereferenced values of references, the
  references themselves (except for their type) are ignored.  This means
  aspects such as blessing and ties are not considered "different".
  
  C<is_deeply()> currently has very limited handling of function reference
  and globs.  It merely checks if they have the same referent.  This may
  improve in the future.
  
  L<Test::Differences> and L<Test::Deep> provide more in-depth functionality
  along these lines.
  
  B<NOTE> is_deeply() has limitations when it comes to comparing strings and
  refs:
  
      my $path = path('.');
      my $hash = {};
      is_deeply( $path, "$path" ); # ok
      is_deeply( $hash, "$hash" ); # fail
  
  This happens because is_deeply will unoverload all arguments unconditionally.
  It is probably best not to use is_deeply with overloading. For legacy reasons
  this is not likely to ever be fixed. If you would like a much better tool for
  this you should see L<Test2::Suite> Specifically L<Test2::Tools::Compare> has
  an C<is()> function that works like C<is_deeply> with many improvements.
  
  =cut
  
  our( @Data_Stack, %Refs_Seen );
  my $DNE = bless [], 'Does::Not::Exist';
  
  sub _dne {
      return ref $_[0] eq ref $DNE;
  }
  
  ## no critic (Subroutines::RequireArgUnpacking)
  sub is_deeply {
      my $tb = Test::More->builder;
  
      unless( @_ == 2 or @_ == 3 ) {
          my $msg = <<'WARNING';
  is_deeply() takes two or three args, you gave %d.
  This usually means you passed an array or hash instead 
  of a reference to it
  WARNING
          chop $msg;    # clip off newline so carp() will put in line/file
  
          _carp sprintf $msg, scalar @_;
  
          return $tb->ok(0);
      }
  
      my( $got, $expected, $name ) = @_;
  
      $tb->_unoverload_str( \$expected, \$got );
  
      my $ok;
      if( !ref $got and !ref $expected ) {    # neither is a reference
          $ok = $tb->is_eq( $got, $expected, $name );
      }
      elsif( !ref $got xor !ref $expected ) {    # one's a reference, one isn't
          $ok = $tb->ok( 0, $name );
          $tb->diag( _format_stack({ vals => [ $got, $expected ] }) );
      }
      else {                                     # both references
          local @Data_Stack = ();
          if( _deep_check( $got, $expected ) ) {
              $ok = $tb->ok( 1, $name );
          }
          else {
              $ok = $tb->ok( 0, $name );
              $tb->diag( _format_stack(@Data_Stack) );
          }
      }
  
      return $ok;
  }
  
  sub _format_stack {
      my(@Stack) = @_;
  
      my $var       = '$FOO';
      my $did_arrow = 0;
      foreach my $entry (@Stack) {
          my $type = $entry->{type} || '';
          my $idx = $entry->{'idx'};
          if( $type eq 'HASH' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "{$idx}";
          }
          elsif( $type eq 'ARRAY' ) {
              $var .= "->" unless $did_arrow++;
              $var .= "[$idx]";
          }
          elsif( $type eq 'REF' ) {
              $var = "\${$var}";
          }
      }
  
      my @vals = @{ $Stack[-1]{vals} }[ 0, 1 ];
      my @vars = ();
      ( $vars[0] = $var ) =~ s/\$FOO/     \$got/;
      ( $vars[1] = $var ) =~ s/\$FOO/\$expected/;
  
      my $out = "Structures begin differing at:\n";
      foreach my $idx ( 0 .. $#vals ) {
          my $val = $vals[$idx];
          $vals[$idx]
            = !defined $val ? 'undef'
            : _dne($val)    ? "Does not exist"
            : ref $val      ? "$val"
            :                 "'$val'";
      }
  
      $out .= "$vars[0] = $vals[0]\n";
      $out .= "$vars[1] = $vals[1]\n";
  
      $out =~ s/^/    /msg;
      return $out;
  }
  
  sub _type {
      my $thing = shift;
  
      return '' if !ref $thing;
  
      for my $type (qw(Regexp ARRAY HASH REF SCALAR GLOB CODE VSTRING)) {
          return $type if UNIVERSAL::isa( $thing, $type );
      }
  
      return '';
  }
  
  =back
  
  
  =head2 Diagnostics
  
  If you pick the right test function, you'll usually get a good idea of
  what went wrong when it failed.  But sometimes it doesn't work out
  that way.  So here we have ways for you to write your own diagnostic
  messages which are safer than just C<print STDERR>.
  
  =over 4
  
  =item B<diag>
  
    diag(@diagnostic_message);
  
  Prints a diagnostic message which is guaranteed not to interfere with
  test output.  Like C<print> @diagnostic_message is simply concatenated
  together.
  
  Returns false, so as to preserve failure.
  
  Handy for this sort of thing:
  
      ok( grep(/foo/, @users), "There's a foo user" ) or
          diag("Since there's no foo, check that /etc/bar is set up right");
  
  which would produce:
  
      not ok 42 - There's a foo user
      #   Failed test 'There's a foo user'
      #   in foo.t at line 52.
      # Since there's no foo, check that /etc/bar is set up right.
  
  You might remember C<ok() or diag()> with the mnemonic C<open() or
  die()>.
  
  B<NOTE> The exact formatting of the diagnostic output is still
  changing, but it is guaranteed that whatever you throw at it won't
  interfere with the test.
  
  =item B<note>
  
    note(@diagnostic_message);
  
  Like C<diag()>, except the message will not be seen when the test is run
  in a harness.  It will only be visible in the verbose TAP stream.
  
  Handy for putting in notes which might be useful for debugging, but
  don't indicate a problem.
  
      note("Tempfile is $tempfile");
  
  =cut
  
  sub diag {
      return Test::More->builder->diag(@_);
  }
  
  sub note {
      return Test::More->builder->note(@_);
  }
  
  =item B<explain>
  
    my @dump = explain @diagnostic_message;
  
  Will dump the contents of any references in a human readable format.
  Usually you want to pass this into C<note> or C<diag>.
  
  Handy for things like...
  
      is_deeply($have, $want) || diag explain $have;
  
  or
  
      note explain \%args;
      Some::Class->method(%args);
  
  =cut
  
  sub explain {
      return Test::More->builder->explain(@_);
  }
  
  =back
  
  
  =head2 Conditional tests
  
  Sometimes running a test under certain conditions will cause the
  test script to die.  A certain function or method isn't implemented
  (such as C<fork()> on MacOS), some resource isn't available (like a 
  net connection) or a module isn't available.  In these cases it's
  necessary to skip tests, or declare that they are supposed to fail
  but will work in the future (a todo test).
  
  For more details on the mechanics of skip and todo tests see
  L<Test::Harness>.
  
  The way Test::More handles this is with a named block.  Basically, a
  block of tests which can be skipped over or made todo.  It's best if I
  just show you...
  
  =over 4
  
  =item B<SKIP: BLOCK>
  
    SKIP: {
        skip $why, $how_many if $condition;
  
        ...normal testing code goes here...
    }
  
  This declares a block of tests that might be skipped, $how_many tests
  there are, $why and under what $condition to skip them.  An example is
  the easiest way to illustrate:
  
      SKIP: {
          eval { require HTML::Lint };
  
          skip "HTML::Lint not installed", 2 if $@;
  
          my $lint = new HTML::Lint;
          isa_ok( $lint, "HTML::Lint" );
  
          $lint->parse( $html );
          is( $lint->errors, 0, "No errors found in HTML" );
      }
  
  If the user does not have HTML::Lint installed, the whole block of
  code I<won't be run at all>.  Test::More will output special ok's
  which Test::Harness interprets as skipped, but passing, tests.
  
  It's important that $how_many accurately reflects the number of tests
  in the SKIP block so the # of tests run will match up with your plan.
  If your plan is C<no_plan> $how_many is optional and will default to 1.
  
  It's perfectly safe to nest SKIP blocks.  Each SKIP block must have
  the label C<SKIP>, or Test::More can't work its magic.
  
  You don't skip tests which are failing because there's a bug in your
  program, or for which you don't yet have code written.  For that you
  use TODO.  Read on.
  
  =cut
  
  ## no critic (Subroutines::RequireFinalReturn)
  sub skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      # If the plan is set, and is static, then skip needs a count. If the plan
      # is 'no_plan' we are fine. As well if plan is undefined then we are
      # waiting for done_testing.
      unless (defined $how_many) {
          my $plan = $tb->has_plan;
          _carp "skip() needs to know \$how_many tests are in the block"
              if $plan && $plan =~ m/^\d+$/;
          $how_many = 1;
      }
  
      if( defined $how_many and $how_many =~ /\D/ ) {
          _carp
            "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->skip($why);
      }
  
      no warnings 'exiting';
      last SKIP;
  }
  
  =item B<TODO: BLOCK>
  
      TODO: {
          local $TODO = $why if $condition;
  
          ...normal testing code goes here...
      }
  
  Declares a block of tests you expect to fail and $why.  Perhaps it's
  because you haven't fixed a bug or haven't finished a new feature:
  
      TODO: {
          local $TODO = "URI::Geller not finished";
  
          my $card = "Eight of clubs";
          is( URI::Geller->your_card, $card, 'Is THIS your card?' );
  
          my $spoon;
          URI::Geller->bend_spoon;
          is( $spoon, 'bent',    "Spoon bending, that's original" );
      }
  
  With a todo block, the tests inside are expected to fail.  Test::More
  will run the tests normally, but print out special flags indicating
  they are "todo".  L<Test::Harness> will interpret failures as being ok.
  Should anything succeed, it will report it as an unexpected success.
  You then know the thing you had todo is done and can remove the
  TODO flag.
  
  The nice part about todo tests, as opposed to simply commenting out a
  block of tests, is it's like having a programmatic todo list.  You know
  how much work is left to be done, you're aware of what bugs there are,
  and you'll know immediately when they're fixed.
  
  Once a todo test starts succeeding, simply move it outside the block.
  When the block is empty, delete it.
  
  
  =item B<todo_skip>
  
      TODO: {
          todo_skip $why, $how_many if $condition;
  
          ...normal testing code...
      }
  
  With todo tests, it's best to have the tests actually run.  That way
  you'll know when they start passing.  Sometimes this isn't possible.
  Often a failing test will cause the whole program to die or hang, even
  inside an C<eval BLOCK> with and using C<alarm>.  In these extreme
  cases you have no choice but to skip over the broken tests entirely.
  
  The syntax and behavior is similar to a C<SKIP: BLOCK> except the
  tests will be marked as failing but todo.  L<Test::Harness> will
  interpret them as passing.
  
  =cut
  
  sub todo_skip {
      my( $why, $how_many ) = @_;
      my $tb = Test::More->builder;
  
      unless( defined $how_many ) {
          # $how_many can only be avoided when no_plan is in use.
          _carp "todo_skip() needs to know \$how_many tests are in the block"
            unless $tb->has_plan eq 'no_plan';
          $how_many = 1;
      }
  
      for( 1 .. $how_many ) {
          $tb->todo_skip($why);
      }
  
      no warnings 'exiting';
      last TODO;
  }
  
  =item When do I use SKIP vs. TODO?
  
  B<If it's something the user might not be able to do>, use SKIP.
  This includes optional modules that aren't installed, running under
  an OS that doesn't have some feature (like C<fork()> or symlinks), or maybe
  you need an Internet connection and one isn't available.
  
  B<If it's something the programmer hasn't done yet>, use TODO.  This
  is for any code you haven't written yet, or bugs you have yet to fix,
  but want to put tests in your testing script (always a good idea).
  
  
  =back
  
  
  =head2 Test control
  
  =over 4
  
  =item B<BAIL_OUT>
  
      BAIL_OUT($reason);
  
  Indicates to the harness that things are going so badly all testing
  should terminate.  This includes the running of any additional test scripts.
  
  This is typically used when testing cannot continue such as a critical
  module failing to compile or a necessary external utility not being
  available such as a database connection failing.
  
  The test will exit with 255.
  
  For even better control look at L<Test::Most>.
  
  =cut
  
  sub BAIL_OUT {
      my $reason = shift;
      my $tb     = Test::More->builder;
  
      $tb->BAIL_OUT($reason);
  }
  
  =back
  
  
  =head2 Discouraged comparison functions
  
  The use of the following functions is discouraged as they are not
  actually testing functions and produce no diagnostics to help figure
  out what went wrong.  They were written before C<is_deeply()> existed
  because I couldn't figure out how to display a useful diff of two
  arbitrary data structures.
  
  These functions are usually used inside an C<ok()>.
  
      ok( eq_array(\@got, \@expected) );
  
  C<is_deeply()> can do that better and with diagnostics.  
  
      is_deeply( \@got, \@expected );
  
  They may be deprecated in future versions.
  
  =over 4
  
  =item B<eq_array>
  
    my $is_eq = eq_array(\@got, \@expected);
  
  Checks if two arrays are equivalent.  This is a deep check, so
  multi-level structures are handled correctly.
  
  =cut
  
  #'#
  sub eq_array {
      local @Data_Stack = ();
      _deep_check(@_);
  }
  
  sub _eq_array {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'ARRAY', $a1, $a2 ) {
          warn "eq_array passed a non-array ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
      for( 0 .. $max ) {
          my $e1 = $_ > $#$a1 ? $DNE : $a1->[$_];
          my $e2 = $_ > $#$a2 ? $DNE : $a2->[$_];
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'ARRAY', idx => $_, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  sub _equal_nonrefs {
      my( $e1, $e2 ) = @_;
  
      return if ref $e1 or ref $e2;
  
      if ( defined $e1 ) {
          return 1 if defined $e2 and $e1 eq $e2;
      }
      else {
          return 1 if !defined $e2;
      }
  
      return;
  }
  
  sub _deep_check {
      my( $e1, $e2 ) = @_;
      my $tb = Test::More->builder;
  
      my $ok = 0;
  
      # Effectively turn %Refs_Seen into a stack.  This avoids picking up
      # the same referenced used twice (such as [\$a, \$a]) to be considered
      # circular.
      local %Refs_Seen = %Refs_Seen;
  
      {
          $tb->_unoverload_str( \$e1, \$e2 );
  
          # Either they're both references or both not.
          my $same_ref = !( !ref $e1 xor !ref $e2 );
          my $not_ref = ( !ref $e1 and !ref $e2 );
  
          if( defined $e1 xor defined $e2 ) {
              $ok = 0;
          }
          elsif( !defined $e1 and !defined $e2 ) {
              # Shortcut if they're both undefined.
              $ok = 1;
          }
          elsif( _dne($e1) xor _dne($e2) ) {
              $ok = 0;
          }
          elsif( $same_ref and( $e1 eq $e2 ) ) {
              $ok = 1;
          }
          elsif($not_ref) {
              push @Data_Stack, { type => '', vals => [ $e1, $e2 ] };
              $ok = 0;
          }
          else {
              if( $Refs_Seen{$e1} ) {
                  return $Refs_Seen{$e1} eq $e2;
              }
              else {
                  $Refs_Seen{$e1} = "$e2";
              }
  
              my $type = _type($e1);
              $type = 'DIFFERENT' unless _type($e2) eq $type;
  
              if( $type eq 'DIFFERENT' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              elsif( $type eq 'ARRAY' ) {
                  $ok = _eq_array( $e1, $e2 );
              }
              elsif( $type eq 'HASH' ) {
                  $ok = _eq_hash( $e1, $e2 );
              }
              elsif( $type eq 'REF' ) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif( $type eq 'SCALAR' ) {
                  push @Data_Stack, { type => 'REF', vals => [ $e1, $e2 ] };
                  $ok = _deep_check( $$e1, $$e2 );
                  pop @Data_Stack if $ok;
              }
              elsif($type) {
                  push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
                  $ok = 0;
              }
              else {
                  _whoa( 1, "No type in _deep_check" );
              }
          }
      }
  
      return $ok;
  }
  
  sub _whoa {
      my( $check, $desc ) = @_;
      if($check) {
          die <<"WHOA";
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
      }
  }
  
  =item B<eq_hash>
  
    my $is_eq = eq_hash(\%got, \%expected);
  
  Determines if the two hashes contain the same keys and values.  This
  is a deep check.
  
  =cut
  
  sub eq_hash {
      local @Data_Stack = ();
      return _deep_check(@_);
  }
  
  sub _eq_hash {
      my( $a1, $a2 ) = @_;
  
      if( grep _type($_) ne 'HASH', $a1, $a2 ) {
          warn "eq_hash passed a non-hash ref";
          return 0;
      }
  
      return 1 if $a1 eq $a2;
  
      my $ok = 1;
      my $bigger = keys %$a1 > keys %$a2 ? $a1 : $a2;
      foreach my $k ( keys %$bigger ) {
          my $e1 = exists $a1->{$k} ? $a1->{$k} : $DNE;
          my $e2 = exists $a2->{$k} ? $a2->{$k} : $DNE;
  
          next if _equal_nonrefs($e1, $e2);
  
          push @Data_Stack, { type => 'HASH', idx => $k, vals => [ $e1, $e2 ] };
          $ok = _deep_check( $e1, $e2 );
          pop @Data_Stack if $ok;
  
          last unless $ok;
      }
  
      return $ok;
  }
  
  =item B<eq_set>
  
    my $is_eq = eq_set(\@got, \@expected);
  
  Similar to C<eq_array()>, except the order of the elements is B<not>
  important.  This is a deep check, but the irrelevancy of order only
  applies to the top level.
  
      ok( eq_set(\@got, \@expected) );
  
  Is better written:
  
      is_deeply( [sort @got], [sort @expected] );
  
  B<NOTE> By historical accident, this is not a true set comparison.
  While the order of elements does not matter, duplicate elements do.
  
  B<NOTE> C<eq_set()> does not know how to deal with references at the top
  level.  The following is an example of a comparison which might not work:
  
      eq_set([\1, \2], [\2, \1]);
  
  L<Test::Deep> contains much better set comparison functions.
  
  =cut
  
  sub eq_set {
      my( $a1, $a2 ) = @_;
      return 0 unless @$a1 == @$a2;
  
      no warnings 'uninitialized';
  
      # It really doesn't matter how we sort them, as long as both arrays are
      # sorted with the same algorithm.
      #
      # Ensure that references are not accidentally treated the same as a
      # string containing the reference.
      #
      # Have to inline the sort routine due to a threading/sort bug.
      # See [rt.cpan.org 6782]
      #
      # I don't know how references would be sorted so we just don't sort
      # them.  This means eq_set doesn't really work with refs.
      return eq_array(
          [ grep( ref, @$a1 ), sort( grep( !ref, @$a1 ) ) ],
          [ grep( ref, @$a2 ), sort( grep( !ref, @$a2 ) ) ],
      );
  }
  
  =back
  
  
  =head2 Extending and Embedding Test::More
  
  Sometimes the Test::More interface isn't quite enough.  Fortunately,
  Test::More is built on top of L<Test::Builder> which provides a single,
  unified backend for any test library to use.  This means two test
  libraries which both use <Test::Builder> B<can> be used together in the
  same program>.
  
  If you simply want to do a little tweaking of how the tests behave,
  you can access the underlying L<Test::Builder> object like so:
  
  =over 4
  
  =item B<builder>
  
      my $test_builder = Test::More->builder;
  
  Returns the L<Test::Builder> object underlying Test::More for you to play
  with.
  
  
  =back
  
  
  =head1 EXIT CODES
  
  If all your tests passed, L<Test::Builder> will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run L<Test::Builder>
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  B<NOTE>  This behavior may go away in future versions.
  
  
  =head1 COMPATIBILITY
  
  Test::More works with Perls as old as 5.8.1.
  
  Thread support is not very reliable before 5.10.1, but that's
  because threads are not very reliable before 5.10.1.
  
  Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use C<done_testing()> but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More > 0.88.
  
  Key feature milestones include:
  
  =over 4
  
  =item subtests
  
  Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call C<done_testing()> until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.
  
  =item C<done_testing()>
  
  This was released in Test::More 0.88 and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =item C<cmp_ok()>
  
  Although C<cmp_ok()> was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.
  
  =item C<new_ok()> C<note()> and C<explain()>
  
  These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92. 
  
  =back
  
  There is a full version history in the Changes file, and the Test::More versions included as core can be found using L<Module::CoreList>:
  
      $ corelist -a Test::More
  
  
  =head1 CAVEATS and NOTES
  
  =over 4
  
  =item utf8 / "Wide character in print"
  
  If you use utf8 or other non-ASCII characters with Test::More you
  might get a "Wide character in print" warning.  Using
  C<< binmode STDOUT, ":utf8" >> will not fix it.
  L<Test::Builder> (which powers
  Test::More) duplicates STDOUT and STDERR.  So any changes to them,
  including changing their output disciplines, will not be seem by
  Test::More.
  
  One work around is to apply encodings to STDOUT and STDERR as early
  as possible and before Test::More (or any other Test module) loads.
  
      use open ':std', ':encoding(utf8)';
      use Test::More;
  
  A more direct work around is to change the filehandles used by
  L<Test::Builder>.
  
      my $builder = Test::More->builder;
      binmode $builder->output,         ":encoding(utf8)";
      binmode $builder->failure_output, ":encoding(utf8)";
      binmode $builder->todo_output,    ":encoding(utf8)";
  
  
  =item Overloaded objects
  
  String overloaded objects are compared B<as strings> (or in C<cmp_ok()>'s
  case, strings or numbers as appropriate to the comparison op).  This
  prevents Test::More from piercing an object's interface allowing
  better blackbox testing.  So if a function starts returning overloaded
  objects instead of bare strings your tests won't notice the
  difference.  This is good.
  
  However, it does mean that functions like C<is_deeply()> cannot be used to
  test the internals of string overloaded objects.  In this case I would
  suggest L<Test::Deep> which contains more flexible testing functions for
  complex data structures.
  
  
  =item Threads
  
  Test::More will only be aware of threads if C<use threads> has been done
  I<before> Test::More is loaded.  This is ok:
  
      use threads;
      use Test::More;
  
  This may cause problems:
  
      use Test::More
      use threads;
  
  5.8.1 and above are supported.  Anything below that has too many bugs.
  
  =back
  
  
  =head1 HISTORY
  
  This is a case of convergent evolution with Joshua Pritikin's L<Test>
  module.  I was largely unaware of its existence when I'd first
  written my own C<ok()> routines.  This module exists because I can't
  figure out how to easily wedge test names into Test's interface (along
  with a few other problems).
  
  The goal here is to have a testing utility that's simple to learn,
  quick to use and difficult to trip yourself up with while still
  providing more flexibility than the existing Test.pm.  As such, the
  names of the most common routines are kept tiny, special cases and
  magic side-effects are kept to a minimum.  WYSIWYG.
  
  
  =head1 SEE ALSO
  
  =head2
  
  =head2 ALTERNATIVES
  
  L<Test::Simple> if all this confuses you and you just want to write
  some tests.  You can upgrade to Test::More later (it's forward
  compatible).
  
  L<Test::Legacy> tests written with Test.pm, the original testing
  module, do not play well with other testing libraries.  Test::Legacy
  emulates the Test.pm interface and does play well with others.
  
  =head2 TESTING FRAMEWORKS
  
  L<Fennec> The Fennec framework is a testers toolbox. It uses L<Test::Builder>
  under the hood. It brings enhancements for forking, defining state, and
  mocking. Fennec enhances several modules to work better together than they
  would if you loaded them individually on your own.
  
  L<Fennec::Declare> Provides enhanced (L<Devel::Declare>) syntax for Fennec.
  
  =head2 ADDITIONAL LIBRARIES
  
  L<Test::Differences> for more ways to test complex data structures.
  And it plays well with Test::More.
  
  L<Test::Class> is like xUnit but more perlish.
  
  L<Test::Deep> gives you more powerful complex data structure testing.
  
  L<Test::Inline> shows the idea of embedded testing.
  
  L<Mock::Quick> The ultimate mocking library. Easily spawn objects defined on
  the fly. Can also override, block, or reimplement packages as needed.
  
  L<Test::FixtureBuilder> Quickly define fixture data for unit tests.
  
  =head2 OTHER COMPONENTS
  
  L<Test::Harness> is the test runner and output interpreter for Perl.
  It's the thing that powers C<make test> and where the C<prove> utility
  comes from.
  
  =head2 BUNDLES
  
  L<Test::Most> Most commonly needed test functions and features.
  
  =head1 AUTHORS
  
  Michael G Schwern E<lt>schwern@pobox.comE<gt> with much inspiration
  from Joshua Pritikin's Test module and lots of help from Barrie
  Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and
  the perl-qa gang.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  
  =head1 BUGS
  
  See F<https://github.com/Test-More/test-more/issues> to report and view bugs.
  
  
  =head1 SOURCE
  
  The source code repository for Test::More can be found at
  F<http://github.com/Test-More/test-more/>.
  
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
TEST_MORE

$fatpacked{"Test/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SIMPLE';
  package Test::Simple;
  
  use 5.006;
  
  use strict;
  
  our $VERSION = '1.302136';
  
  use Test::Builder::Module;
  our @ISA    = qw(Test::Builder::Module);
  our @EXPORT = qw(ok);
  
  my $CLASS = __PACKAGE__;
  
  =head1 NAME
  
  Test::Simple - Basic utilities for writing tests.
  
  =head1 SYNOPSIS
  
    use Test::Simple tests => 1;
  
    ok( $foo eq $bar, 'foo is bar' );
  
  
  =head1 DESCRIPTION
  
  ** If you are unfamiliar with testing B<read L<Test::Tutorial> first!> **
  
  This is an extremely simple, extremely basic module for writing tests
  suitable for CPAN modules and other pursuits.  If you wish to do more
  complicated testing, use the Test::More module (a drop-in replacement
  for this one).
  
  The basic unit of Perl testing is the ok.  For each thing you want to
  test your program will print out an "ok" or "not ok" to indicate pass
  or fail.  You do this with the C<ok()> function (see below).
  
  The only other constraint is you must pre-declare how many tests you
  plan to run.  This is in case something goes horribly wrong during the
  test and your test program aborts, or skips a test or whatever.  You
  do this like so:
  
      use Test::Simple tests => 23;
  
  You must have a plan.
  
  
  =over 4
  
  =item B<ok>
  
    ok( $foo eq $bar, $name );
    ok( $foo eq $bar );
  
  C<ok()> is given an expression (in this case C<$foo eq $bar>).  If it's
  true, the test passed.  If it's false, it didn't.  That's about it.
  
  C<ok()> prints out either "ok" or "not ok" along with a test number (it
  keeps track of that for you).
  
    # This produces "ok 1 - Hell not yet frozen over" (or not ok)
    ok( get_temperature($hell) > 0, 'Hell not yet frozen over' );
  
  If you provide a $name, that will be printed along with the "ok/not
  ok" to make it easier to find your test when if fails (just search for
  the name).  It also makes it easier for the next guy to understand
  what your test is for.  It's highly recommended you use test names.
  
  All tests are run in scalar context.  So this:
  
      ok( @stuff, 'I have some stuff' );
  
  will do what you mean (fail if stuff is empty)
  
  =cut
  
  sub ok ($;$) {    ## no critic (Subroutines::ProhibitSubroutinePrototypes)
      return $CLASS->builder->ok(@_);
  }
  
  =back
  
  Test::Simple will start by printing number of tests run in the form
  "1..M" (so "1..5" means you're going to run 5 tests).  This strange
  format lets L<Test::Harness> know how many tests you plan on running in
  case something goes horribly wrong.
  
  If all your tests passed, Test::Simple will exit with zero (which is
  normal).  If anything failed it will exit with how many failed.  If
  you run less (or more) tests than you planned, the missing (or extras)
  will be considered failures.  If no tests were ever run Test::Simple
  will throw a warning and exit with 255.  If the test died, even after
  having successfully completed all its tests, it will still be
  considered a failure and will exit with 255.
  
  So the exit codes are...
  
      0                   all tests successful
      255                 test died or all passed but wrong # of tests run
      any other number    how many failed (including missing or extras)
  
  If you fail more than 254 tests, it will be reported as 254.
  
  This module is by no means trying to be a complete testing system.
  It's just to get you started.  Once you're off the ground its
  recommended you look at L<Test::More>.
  
  
  =head1 EXAMPLE
  
  Here's an example of a simple .t file for the fictional Film module.
  
      use Test::Simple tests => 5;
  
      use Film;  # What you're testing.
  
      my $btaste = Film->new({ Title    => 'Bad Taste',
                               Director => 'Peter Jackson',
                               Rating   => 'R',
                               NumExplodingSheep => 1
                             });
      ok( defined($btaste) && ref $btaste eq 'Film',     'new() works' );
  
      ok( $btaste->Title      eq 'Bad Taste',     'Title() get'    );
      ok( $btaste->Director   eq 'Peter Jackson', 'Director() get' );
      ok( $btaste->Rating     eq 'R',             'Rating() get'   );
      ok( $btaste->NumExplodingSheep == 1,        'NumExplodingSheep() get' );
  
  It will produce output like this:
  
      1..5
      ok 1 - new() works
      ok 2 - Title() get
      ok 3 - Director() get
      not ok 4 - Rating() get
      #   Failed test 'Rating() get'
      #   in t/film.t at line 14.
      ok 5 - NumExplodingSheep() get
      # Looks like you failed 1 tests of 5
  
  Indicating the Film::Rating() method is broken.
  
  
  =head1 CAVEATS
  
  Test::Simple will only report a maximum of 254 failures in its exit
  code.  If this is a problem, you probably have a huge test script.
  Split it into multiple files.  (Otherwise blame the Unix folks for
  using an unsigned short integer as the exit status).
  
  Because VMS's exit codes are much, much different than the rest of the
  universe, and perl does horrible mangling to them that gets in my way,
  it works like this on VMS.
  
      0     SS$_NORMAL        all tests successful
      4     SS$_ABORT         something went wrong
  
  Unfortunately, I can't differentiate any further.
  
  
  =head1 NOTES
  
  Test::Simple is B<explicitly> tested all the way back to perl 5.6.0.
  
  Test::Simple is thread-safe in perl 5.8.1 and up.
  
  =head1 HISTORY
  
  This module was conceived while talking with Tony Bowden in his
  kitchen one night about the problems I was having writing some really
  complicated feature into the new Testing module.  He observed that the
  main problem is not dealing with these edge cases but that people hate
  to write tests B<at all>.  What was needed was a dead simple module
  that took all the hard work out of testing and was really, really easy
  to learn.  Paul Johnson simultaneously had this idea (unfortunately,
  he wasn't in Tony's kitchen).  This is it.
  
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  More testing functions!  Once you outgrow Test::Simple, look at
  L<Test::More>.  Test::Simple is 100% forward compatible with L<Test::More>
  (i.e. you can just use L<Test::More> instead of Test::Simple in your
  programs and things will still work).
  
  =back
  
  Look in L<Test::More>'s SEE ALSO for more testing modules.
  
  
  =head1 AUTHORS
  
  Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern
  E<lt>schwern@pobox.comE<gt>, wardrobe by Calvin Klein.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2001-2008 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
  
  1;
TEST_SIMPLE

$fatpacked{"Test/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER';
  use strict;
  
  package Test::Tester;
  
  BEGIN
  {
  	if (*Test::Builder::new{CODE})
  	{
  		warn "You should load Test::Tester before Test::Builder (or anything that loads Test::Builder)"
  	}
  }
  
  use Test::Builder;
  use Test::Tester::CaptureRunner;
  use Test::Tester::Delegate;
  
  require Exporter;
  
  use vars qw( @ISA @EXPORT );
  
  our $VERSION = '1.302136';
  
  @EXPORT = qw( run_tests check_tests check_test cmp_results show_space );
  @ISA = qw( Exporter );
  
  my $Test = Test::Builder->new;
  my $Capture = Test::Tester::Capture->new;
  my $Delegator = Test::Tester::Delegate->new;
  $Delegator->{Object} = $Test;
  
  my $runner = Test::Tester::CaptureRunner->new;
  
  my $want_space = $ENV{TESTTESTERSPACE};
  
  sub show_space
  {
  	$want_space = 1;
  }
  
  my $colour = '';
  my $reset = '';
  
  if (my $want_colour = $ENV{TESTTESTERCOLOUR} || $ENV{TESTTESTERCOLOR})
  {
  	if (eval { require Term::ANSIColor; 1 })
  	{
  		eval { require Win32::Console::ANSI } if 'MSWin32' eq $^O;  # support color on windows platforms
  		my ($f, $b) = split(",", $want_colour);
  		$colour = Term::ANSIColor::color($f).Term::ANSIColor::color("on_$b");
  		$reset = Term::ANSIColor::color("reset");
  	}
  
  }
  
  sub new_new
  {
  	return $Delegator;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  sub fh
  {
  	# experiment with capturing output, I don't like it
  	$runner = Test::Tester::FHRunner->new;
  
  	return $Test;
  }
  
  sub find_run_tests
  {
  	my $d = 1;
  	my $found = 0;
  	while ((not $found) and (my ($sub) = (caller($d))[3]) )
  	{
  #		print "$d: $sub\n";
  		$found = ($sub eq "Test::Tester::run_tests");
  		$d++;
  	}
  
  #	die "Didn't find 'run_tests' in caller stack" unless $found;
  	return $d;
  }
  
  sub run_tests
  {
  	local($Delegator->{Object}) = $Capture;
  
  	$runner->run_tests(@_);
  
  	return ($runner->get_premature, $runner->get_results);
  }
  
  sub check_test
  {
  	my $test = shift;
  	my $expect = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	@_ = ($test, [$expect], $name);
  	goto &check_tests;
  }
  
  sub check_tests
  {
  	my $test = shift;
  	my $expects = shift;
  	my $name = shift;
  	$name = "" unless defined($name);
  
  	my ($prem, @results) = eval { run_tests($test, $name) };
  
  	$Test->ok(! $@, "Test '$name' completed") || $Test->diag($@);
  	$Test->ok(! length($prem), "Test '$name' no premature diagnostication") ||
  		$Test->diag("Before any testing anything, your tests said\n$prem");
  
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	cmp_results(\@results, $expects, $name);
  	return ($prem, @results);
  }
  
  sub cmp_field
  {
  	my ($result, $expect, $field, $desc) = @_;
  
  	if (defined $expect->{$field})
  	{
  		$Test->is_eq($result->{$field}, $expect->{$field},
  			"$desc compare $field");
  	}
  }
  
  sub cmp_result
  {
  	my ($result, $expect, $name) = @_;
  
  	my $sub_name = $result->{name};
  	$sub_name = "" unless defined($name);
  
  	my $desc = "subtest '$sub_name' of '$name'";
  
  	{
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  
  		cmp_field($result, $expect, "ok", $desc);
  
  		cmp_field($result, $expect, "actual_ok", $desc);
  
  		cmp_field($result, $expect, "type", $desc);
  
  		cmp_field($result, $expect, "reason", $desc);
  
  		cmp_field($result, $expect, "name", $desc);
  	}
  
  	# if we got no depth then default to 1
  	my $depth = 1;
  	if (exists $expect->{depth})
  	{
  		$depth = $expect->{depth};
  	}
  
  	# if depth was explicitly undef then don't test it
  	if (defined $depth)
  	{
  		$Test->is_eq($result->{depth}, $depth, "checking depth") ||
  			$Test->diag('You need to change $Test::Builder::Level');
  	}
  
  	if (defined(my $exp = $expect->{diag}))
  	{
  
          my $got = '';
          if (ref $exp eq 'Regexp') {
  
              if (not $Test->like($result->{diag}, $exp,
                  "subtest '$sub_name' of '$name' compare diag"))
              {
                  $got = $result->{diag};
              }
  
          } else {
  
              # if there actually is some diag then put a \n on the end if it's not
              # there already
              $exp .= "\n" if (length($exp) and $exp !~ /\n$/);
  
              if (not $Test->ok($result->{diag} eq $exp,
      			"subtest '$sub_name' of '$name' compare diag"))
              {
                  $got = $result->{diag};
              }
          }
  
          if ($got) {
      		my $glen = length($got);
      		my $elen = length($exp);
      		for ($got, $exp)
      		{
      			my @lines = split("\n", $_);
       			$_ = join("\n", map {
      				if ($want_space)
      				{
      					$_ = $colour.escape($_).$reset;
      				}
      				else
      				{
      					"'$colour$_$reset'"
      				}
      			} @lines);
      		}
  
          	$Test->diag(<<EOM);
  Got diag ($glen bytes):
  $got
  Expected diag ($elen bytes):
  $exp
  EOM
          }
  	}
  }
  
  sub escape
  {
  	my $str = shift;
  	my $res = '';
  	for my $char (split("", $str))
  	{
  		my $c = ord($char);
  		if(($c>32 and $c<125) or $c == 10)
  		{
  			$res .= $char;
  		}
  		else
  		{
  			$res .= sprintf('\x{%x}', $c)
  		}
  	}
  	return $res;
  }
  
  sub cmp_results
  {
  	my ($results, $expects, $name) = @_;
  
  	$Test->is_num(scalar @$results, scalar @$expects, "Test '$name' result count");
  
  	for (my $i = 0; $i < @$expects; $i++)
  	{
  		my $expect = $expects->[$i];
  		my $result = $results->[$i];
  
  		local $Test::Builder::Level = $Test::Builder::Level + 1;
  		cmp_result($result, $expect, $name);
  	}
  }
  
  ######## nicked from Test::More
  sub plan {
  	my(@plan) = @_;
  
  	my $caller = caller;
  
  	$Test->exported_to($caller);
  
  	my @imports = ();
  	foreach my $idx (0..$#plan) {
  		if( $plan[$idx] eq 'import' ) {
  			my($tag, $imports) = splice @plan, $idx, 2;
  			@imports = @$imports;
  			last;
  		}
  	}
  
  	$Test->plan(@plan);
  
  	__PACKAGE__->_export_to_level(1, __PACKAGE__, @imports);
  }
  
  sub import {
  	my($class) = shift;
  		{
  			no warnings 'redefine';
  			*Test::Builder::new = \&new_new;
  		}
  	goto &plan;
  }
  
  sub _export_to_level
  {
          my $pkg = shift;
  	my $level = shift;
  	(undef) = shift;	# redundant arg
  	my $callpkg = caller($level);
  	$pkg->export($callpkg, @_);
  }
  
  
  ############
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester - Ease testing test modules built with Test::Builder
  
  =head1 SYNOPSIS
  
    use Test::Tester tests => 6;
  
    use Test::MyStyle;
  
    check_test(
      sub {
        is_mystyle_eq("this", "that", "not eq");
      },
      {
        ok => 0, # expect this to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  or
  
    use Test::Tester tests => 6;
  
    use Test::MyStyle;
  
    check_test(
      sub {
        is_mystyle_qr("this", "that", "not matching");
      },
      {
        ok => 0, # expect this to fail
        name => "not matching",
        diag => qr/Expected: 'this'\s+Got: 'that'/,
      }
    );
  
  or
  
    use Test::Tester;
  
    use Test::More tests => 3;
    use Test::MyStyle;
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    # now use Test::More::like to check the diagnostic output
  
    like($results[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  =head1 DESCRIPTION
  
  If you have written a test module based on Test::Builder then Test::Tester
  allows you to test it with the minimum of effort.
  
  =head1 HOW TO USE (THE EASY WAY)
  
  From version 0.08 Test::Tester no longer requires you to included anything
  special in your test modules. All you need to do is
  
    use Test::Tester;
  
  in your test script B<before> any other Test::Builder based modules and away
  you go.
  
  Other modules based on Test::Builder can be used to help with the
  testing.  In fact you can even use functions from your module to test
  other functions from the same module (while this is possible it is
  probably not a good idea, if your module has bugs, then
  using it to test itself may give the wrong answers).
  
  The easiest way to test is to do something like
  
    check_test(
      sub { is_mystyle_eq("this", "that", "not eq") },
      {
        ok => 0, # we expect the test to fail
        name => "not eq",
        diag => "Expected: 'this'\nGot: 'that'",
      }
    );
  
  this will execute the is_mystyle_eq test, capturing it's results and
  checking that they are what was expected.
  
  You may need to examine the test results in a more flexible way, for
  example, the diagnostic output may be quite long or complex or it may involve
  something that you cannot predict in advance like a timestamp. In this case
  you can get direct access to the test results:
  
    my ($premature, @results) = run_tests(
      sub {
        is_database_alive("dbname");
      }
    );
  
    like($result[0]->{diag}, "/^Database ping took \\d+ seconds$"/, "diag");
  
  or
  
    check_test(
      sub { is_mystyle_qr("this", "that", "not matching") },
      {
        ok => 0, # we expect the test to fail
        name => "not matching",
        diag => qr/Expected: 'this'\s+Got: 'that'/,
      }
    );
  
  We cannot predict how long the database ping will take so we use
  Test::More's like() test to check that the diagnostic string is of the right
  form.
  
  =head1 HOW TO USE (THE HARD WAY)
  
  I<This is here for backwards compatibility only>
  
  Make your module use the Test::Tester::Capture object instead of the
  Test::Builder one. How to do this depends on your module but assuming that
  your module holds the Test::Builder object in $Test and that all your test
  routines access it through $Test then providing a function something like this
  
    sub set_builder
    {
      $Test = shift;
    }
  
  should allow your test scripts to do
  
    Test::YourModule::set_builder(Test::Tester->capture);
  
  and after that any tests inside your module will captured.
  
  =head1 TEST RESULTS
  
  The result of each test is captured in a hash. These hashes are the same as
  the hashes returned by Test::Builder->details but with a couple of extra
  fields.
  
  These fields are documented in L<Test::Builder> in the details() function
  
  =over 2
  
  =item ok
  
  Did the test pass?
  
  =item actual_ok
  
  Did the test really pass? That is, did the pass come from
  Test::Builder->ok() or did it pass because it was a TODO test?
  
  =item name
  
  The name supplied for the test.
  
  =item type
  
  What kind of test? Possibilities include, skip, todo etc. See
  L<Test::Builder> for more details.
  
  =item reason
  
  The reason for the skip, todo etc. See L<Test::Builder> for more details.
  
  =back
  
  These fields are exclusive to Test::Tester.
  
  =over 2
  
  =item diag
  
  Any diagnostics that were output for the test. This only includes
  diagnostics output B<after> the test result is declared.
  
  Note that Test::Builder ensures that any diagnostics end in a \n and
  it in earlier versions of Test::Tester it was essential that you have
  the final \n in your expected diagnostics. From version 0.10 onward,
  Test::Tester will add the \n if you forgot it. It will not add a \n if
  you are expecting no diagnostics. See below for help tracking down
  hard to find space and tab related problems.
  
  =item depth
  
  This allows you to check that your test module is setting the correct value
  for $Test::Builder::Level and thus giving the correct file and line number
  when a test fails. It is calculated by looking at caller() and
  $Test::Builder::Level. It should count how many subroutines there are before
  jumping into the function you are testing. So for example in
  
    run_tests( sub { my_test_function("a", "b") } );
  
  the depth should be 1 and in
  
    sub deeper { my_test_function("a", "b") }
  
    run_tests(sub { deeper() });
  
  depth should be 2, that is 1 for the sub {} and one for deeper(). This
  might seem a little complex but if your tests look like the simple
  examples in this doc then you don't need to worry as the depth will
  always be 1 and that's what Test::Tester expects by default.
  
  B<Note>: if you do not specify a value for depth in check_test() then it
  automatically compares it against 1, if you really want to skip the depth
  test then pass in undef.
  
  B<Note>: depth will not be correctly calculated for tests that run from a
  signal handler or an END block or anywhere else that hides the call stack.
  
  =back
  
  Some of Test::Tester's functions return arrays of these hashes, just
  like Test::Builder->details. That is, the hash for the first test will
  be array element 1 (not 0). Element 0 will not be a hash it will be a
  string which contains any diagnostic output that came before the first
  test. This should usually be empty, if it's not, it means something
  output diagnostics before any test results showed up.
  
  =head1 SPACES AND TABS
  
  Appearances can be deceptive, especially when it comes to emptiness. If you
  are scratching your head trying to work out why Test::Tester is saying that
  your diagnostics are wrong when they look perfectly right then the answer is
  probably whitespace. From version 0.10 on, Test::Tester surrounds the
  expected and got diag values with single quotes to make it easier to spot
  trailing whitespace. So in this example
  
    # Got diag (5 bytes):
    # 'abcd '
    # Expected diag (4 bytes):
    # 'abcd'
  
  it is quite clear that there is a space at the end of the first string.
  Another way to solve this problem is to use colour and inverse video on an
  ANSI terminal, see below COLOUR below if you want this.
  
  Unfortunately this is sometimes not enough, neither colour nor quotes will
  help you with problems involving tabs, other non-printing characters and
  certain kinds of problems inherent in Unicode. To deal with this, you can
  switch Test::Tester into a mode whereby all "tricky" characters are shown as
  \{xx}. Tricky characters are those with ASCII code less than 33 or higher
  than 126. This makes the output more difficult to read but much easier to
  find subtle differences between strings. To turn on this mode either call
  C<show_space()> in your test script or set the C<TESTTESTERSPACE> environment
  variable to be a true value. The example above would then look like
  
    # Got diag (5 bytes):
    # abcd\x{20}
    # Expected diag (4 bytes):
    # abcd
  
  =head1 COLOUR
  
  If you prefer to use colour as a means of finding tricky whitespace
  characters then you can set the C<TESTTESTCOLOUR> environment variable to a
  comma separated pair of colours, the first for the foreground, the second
  for the background. For example "white,red" will print white text on a red
  background. This requires the Term::ANSIColor module. You can specify any
  colour that would be acceptable to the Term::ANSIColor::color function.
  
  If you spell colour differently, that's no problem. The C<TESTTESTERCOLOR>
  variable also works (if both are set then the British spelling wins out).
  
  =head1 EXPORTED FUNCTIONS
  
  =head3 ($premature, @results) = run_tests(\&test_sub)
  
  \&test_sub is a reference to a subroutine.
  
  run_tests runs the subroutine in $test_sub and captures the results of any
  tests inside it. You can run more than 1 test inside this subroutine if you
  like.
  
  $premature is a string containing any diagnostic output from before
  the first test.
  
  @results is an array of test result hashes.
  
  =head3 cmp_result(\%result, \%expect, $name)
  
  \%result is a ref to a test result hash.
  
  \%expect is a ref to a hash of expected values for the test result.
  
  cmp_result compares the result with the expected values. If any differences
  are found it outputs diagnostics. You may leave out any field from the
  expected result and cmp_result will not do the comparison of that field.
  
  =head3 cmp_results(\@results, \@expects, $name)
  
  \@results is a ref to an array of test results.
  
  \@expects is a ref to an array of hash refs.
  
  cmp_results checks that the results match the expected results and if any
  differences are found it outputs diagnostics. It first checks that the
  number of elements in \@results and \@expects is the same. Then it goes
  through each result checking it against the expected result as in
  cmp_result() above.
  
  =head3 ($premature, @results) = check_tests(\&test_sub, \@expects, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \@expect is a ref to an array of hash refs which are expected test results.
  
  check_tests combines run_tests and cmp_tests into a single call. It also
  checks if the tests died at any stage.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 ($premature, @results) = check_test(\&test_sub, \%expect, $name)
  
  \&test_sub is a reference to a subroutine.
  
  \%expect is a ref to an hash of expected values for the test result.
  
  check_test is a wrapper around check_tests. It combines run_tests and
  cmp_tests into a single call, checking if the test died. It assumes
  that only a single test is run inside \&test_sub and include a test to
  make sure this is true.
  
  It returns the same values as run_tests, so you can further examine the test
  results if you need to.
  
  =head3 show_space()
  
  Turn on the escaping of characters as described in the SPACES AND TABS
  section.
  
  =head1 HOW IT WORKS
  
  Normally, a test module (let's call it Test:MyStyle) calls
  Test::Builder->new to get the Test::Builder object. Test::MyStyle calls
  methods on this object to record information about test results. When
  Test::Tester is loaded, it replaces Test::Builder's new() method with one
  which returns a Test::Tester::Delegate object. Most of the time this object
  behaves as the real Test::Builder object. Any methods that are called are
  delegated to the real Test::Builder object so everything works perfectly.
  However once we go into test mode, the method calls are no longer passed to
  the real Test::Builder object, instead they go to the Test::Tester::Capture
  object. This object seems exactly like the real Test::Builder object,
  except, instead of outputting test results and diagnostics, it just records
  all the information for later analysis.
  
  =head1 CAVEATS
  
  Support for calling Test::Builder->note is minimal. It's implemented
  as an empty stub, so modules that use it will not crash but the calls
  are not recorded for testing purposes like the others. Patches
  welcome.
  
  =head1 SEE ALSO
  
  L<Test::Builder> the source of testing goodness. L<Test::Builder::Tester>
  for an alternative approach to the problem tackled by Test::Tester -
  captures the strings output by Test::Builder. This means you cannot get
  separate access to the individual pieces of information and you must predict
  B<exactly> what your test will output.
  
  =head1 AUTHOR
  
  This module is copyright 2005 Fergal Daly <fergal@esatclear.ie>, some parts
  are based on other people's work.
  
  Plan handling lifted from Test::More. written by Michael G Schwern
  <schwern@pobox.com>.
  
  Test::Tester::Capture is a cut down and hacked up version of Test::Builder.
  Test::Builder was written by chromatic <chromatic@wgz.org> and Michael G
  Schwern <schwern@pobox.com>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER

$fatpacked{"Test/Tester/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURE';
  use strict;
  
  package Test::Tester::Capture;
  
  our $VERSION = '1.302136';
  
  
  use Test::Builder;
  
  use vars qw( @ISA );
  @ISA = qw( Test::Builder );
  
  # Make Test::Tester::Capture thread-safe for ithreads.
  BEGIN {
  	use Config;
  	if( $] >= 5.008 && $Config{useithreads} ) {
  		require threads::shared;
  		threads::shared->import;
  	}
  	else {
  		*share = sub { 0 };
  		*lock  = sub { 0 };
  	}
  }
  
  my $Curr_Test = 0;      share($Curr_Test);
  my @Test_Results = ();  share(@Test_Results);
  my $Prem_Diag = {diag => ""};	 share($Curr_Test);
  
  sub new
  {
    # Test::Tester::Capgture::new used to just return __PACKAGE__
    # because Test::Builder::new enforced it's singleton nature by
    # return __PACKAGE__. That has since changed, Test::Builder::new now
    # returns a blessed has and around version 0.78, Test::Builder::todo
    # started wanting to modify $self. To cope with this, we now return
    # a blessed hash. This is a short-term hack, the correct thing to do
    # is to detect which style of Test::Builder we're dealing with and
    # act appropriately.
  
    my $class = shift;
    return bless {}, $class;
  }
  
  sub ok {
  	my($self, $test, $name) = @_;
  
  	my $ctx = $self->ctx;
  
  	# $test might contain an object which we don't want to accidentally
  	# store, so we turn it into a boolean.
  	$test = $test ? 1 : 0;
  
  	lock $Curr_Test;
  	$Curr_Test++;
  
  	my($pack, $file, $line) = $self->caller;
  
  	my $todo = $self->todo();
  
  	my $result = {};
  	share($result);
  
  	unless( $test ) {
  		@$result{ 'ok', 'actual_ok' } = ( ( $todo ? 1 : 0 ), 0 );
  	}
  	else {
  		@$result{ 'ok', 'actual_ok' } = ( 1, $test );
  	}
  
  	if( defined $name ) {
  		$name =~ s|#|\\#|g;	 # # in a name can confuse Test::Harness.
  		$result->{name} = $name;
  	}
  	else {
  		$result->{name} = '';
  	}
  
  	if( $todo ) {
  		my $what_todo = $todo;
  		$result->{reason} = $what_todo;
  		$result->{type}   = 'todo';
  	}
  	else {
  		$result->{reason} = '';
  		$result->{type}   = '';
  	}
  
  	$Test_Results[$Curr_Test-1] = $result;
  
  	unless( $test ) {
  		my $msg = $todo ? "Failed (TODO)" : "Failed";
  		$result->{fail_diag} = ("	$msg test ($file at line $line)\n");
  	} 
  
  	$result->{diag} = "";
  	$result->{_level} = $Test::Builder::Level;
  	$result->{_depth} = Test::Tester::find_run_tests();
  
  	$ctx->release;
  
  	return $test ? 1 : 0;
  }
  
  sub skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	my $ctx = $self->ctx;
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 1,
  		name	  => '',
  		type	  => 'skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	$ctx->release;
  	return 1;
  }
  
  sub todo_skip {
  	my($self, $why) = @_;
  	$why ||= '';
  
  	my $ctx = $self->ctx;
  
  	lock($Curr_Test);
  	$Curr_Test++;
  
  	my %result;
  	share(%result);
  	%result = (
  		'ok'	  => 1,
  		actual_ok => 0,
  		name	  => '',
  		type	  => 'todo_skip',
  		reason	=> $why,
  		diag    => "",
  		_level   => $Test::Builder::Level,
  		_depth => Test::Tester::find_run_tests(),
  	);
  
  	$Test_Results[$Curr_Test-1] = \%result;
  
  	$ctx->release;
  	return 1;
  }
  
  sub diag {
  	my($self, @msgs) = @_;
  	return unless @msgs;
  
  	# Prevent printing headers when compiling (i.e. -c)
  	return if $^C;
  
  	my $ctx = $self->ctx;
  
  	# Escape each line with a #.
  	foreach (@msgs) {
  		$_ = 'undef' unless defined;
  	}
  
  	push @msgs, "\n" unless $msgs[-1] =~ /\n\Z/;
  
  	my $result = $Curr_Test ? $Test_Results[$Curr_Test - 1] : $Prem_Diag;
  
  	$result->{diag} .= join("", @msgs);
  
  	$ctx->release;
  	return 0;
  }
  
  sub details {
  	return @Test_Results;
  }
  
  
  # Stub. Feel free to send me a patch to implement this.
  sub note {
  }
  
  sub explain {
  	return Test::Builder::explain(@_);
  }
  
  sub premature
  {
  	return $Prem_Diag->{diag};
  }
  
  sub current_test
  {
  	if (@_ > 1)
  	{
  		die "Don't try to change the test number!";
  	}
  	else
  	{
  		return $Curr_Test;
  	}
  }
  
  sub reset
  {
  	$Curr_Test = 0;
  	@Test_Results = ();
  	$Prem_Diag = {diag => ""};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Test::Tester::Capture - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This is a subclass of Test::Builder that overrides many of the methods so
  that they don't output anything. It also keeps track of it's own set of test
  results so that you can use Test::Builder based modules to perform tests on
  other Test::Builder based modules.
  
  =head1 AUTHOR
  
  Most of the code here was lifted straight from Test::Builder and then had
  chunks removed by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER_CAPTURE

$fatpacked{"Test/Tester/CaptureRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURERUNNER';
  # $Header: /home/fergal/my/cvs/Test-Tester/lib/Test/Tester/CaptureRunner.pm,v 1.3 2003/03/05 01:07:55 fergal Exp $
  use strict;
  
  package Test::Tester::CaptureRunner;
  
  our $VERSION = '1.302136';
  
  
  use Test::Tester::Capture;
  require Exporter;
  
  sub new
  {
  	my $pkg = shift;
  	my $self = bless {}, $pkg;
  	return $self;
  }
  
  sub run_tests
  {
  	my $self = shift;
  
  	my $test = shift;
  
  	capture()->reset;
  
  	$self->{StartLevel} = $Test::Builder::Level;
  	&$test();
  }
  
  sub get_results
  {
  	my $self = shift;
  	my @results = capture()->details;
  
  	my $start = $self->{StartLevel};
  	foreach my $res (@results)
  	{
  		next if defined $res->{depth};
  		my $depth = $res->{_depth} - $res->{_level} - $start - 3;
  #		print "my $depth = $res->{_depth} - $res->{_level} - $start - 1\n";
  		$res->{depth} = $depth;
  	}
  
  	return @results;
  }
  
  sub get_premature
  {
  	return capture()->premature;
  }
  
  sub capture
  {
  	return Test::Tester::Capture->new;
  }
  
  __END__
  
  =head1 NAME
  
  Test::Tester::CaptureRunner - Help testing test modules built with Test::Builder
  
  =head1 DESCRIPTION
  
  This stuff if needed to allow me to play with other ways of monitoring the
  test results.
  
  =head1 AUTHOR
  
  Copyright 2003 by Fergal Daly <fergal@esatclear.ie>.
  
  =head1 LICENSE
  
  Under the same license as Perl itself
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
TEST_TESTER_CAPTURERUNNER

$fatpacked{"Test/Tester/Delegate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_DELEGATE';
  use strict;
  use warnings;
  
  package Test::Tester::Delegate;
  
  our $VERSION = '1.302136';
  
  use Scalar::Util();
  
  use vars '$AUTOLOAD';
  
  sub new
  {
  	my $pkg = shift;
  
  	my $obj = shift;
  	my $self = bless {}, $pkg;
  
  	return $self;
  }
  
  sub AUTOLOAD
  {
  	my ($sub) = $AUTOLOAD =~ /.*::(.*?)$/;
  
  	return if $sub eq "DESTROY";
  
  	my $obj = $_[0]->{Object};
  
  	my $ref = $obj->can($sub);
  	shift(@_);
  	unshift(@_, $obj);
  	goto &$ref;
  }
  
  sub can {
  	my $this = shift;
  	my ($sub) = @_;
  
  	return $this->{Object}->can($sub) if Scalar::Util::blessed($this);
  
  	return $this->SUPER::can(@_);
  }
  
  1;
TEST_TESTER_DELEGATE

$fatpacked{"Test/use/ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_USE_OK';
  package Test::use::ok;
  use 5.005;
  
  our $VERSION = '1.302136';
  
  
  __END__
  
  =head1 NAME
  
  Test::use::ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  According to the B<Test::More> documentation, it is recommended to run
  C<use_ok()> inside a C<BEGIN> block, so functions are exported at
  compile-time and prototypes are properly honored.
  
  That is, instead of writing this:
  
      use_ok( 'Some::Module' );
      use_ok( 'Other::Module' );
  
  One should write this:
  
      BEGIN { use_ok( 'Some::Module' ); }
      BEGIN { use_ok( 'Other::Module' ); }
  
  However, people often either forget to add C<BEGIN>, or mistakenly group
  C<use_ok> with other tests in a single C<BEGIN> block, which can create subtle
  differences in execution order.
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.  The explicit space after C<use>
  makes it clear that this is a single compile-time action.
  
  =head1 SEE ALSO
  
  L<Test::More>
  
  =head1 MAINTAINER
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =encoding utf8
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
TEST_USE_OK

$fatpacked{"Test2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2';
  package Test2;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2 - Framework for writing test tools that all work together.
  
  =head1 DESCRIPTION
  
  Test2 is a new testing framework produced by forking L<Test::Builder>,
  completely refactoring it, adding many new features and capabilities.
  
  =head2 WHAT IS NEW?
  
  =over 4
  
  =item Easier to test new testing tools.
  
  From the beginning Test2 was built with introspection capabilities. With
  Test::Builder it was difficult at best to capture test tool output for
  verification. Test2 Makes it easy with C<Test2::API::intercept()>.
  
  =item Better diagnostics capabilities.
  
  Test2 uses an L<Test2::API::Context> object to track filename, line number, and
  tool details. This object greatly simplifies tracking for where errors should
  be reported.
  
  =item Event driven.
  
  Test2 based tools produce events which get passed through a processing system
  before being output by a formatter. This event system allows for rich plugin
  and extension support.
  
  =item More complete API.
  
  Test::Builder only provided a handful of methods for generating lines of TAP.
  Test2 took inventory of everything people were doing with Test::Builder that
  required hacking it up. Test2 made public API functions for nearly all the
  desired functionality people didn't previously have.
  
  =item Support for output other than TAP.
  
  Test::Builder assumed everything would end up as TAP. Test2 makes no such
  assumption. Test2 provides ways for you to specify alternative and custom
  formatters.
  
  =item Subtest implementation is more sane.
  
  The Test::Builder implementation of subtests was certifiably insane. Test2 uses
  a stacked event hub system that greatly improves how subtests are implemented.
  
  =item Support for threading/forking.
  
  Test2 support for forking and threading can be turned on using L<Test2::IPC>.
  Once turned on threading and forking operate sanely and work as one would
  expect.
  
  =back
  
  =head1 GETTING STARTED
  
  If you are interested in writing tests using new tools then you should look at
  L<Test2::Suite>. L<Test2::Suite> is a separate cpan distribution that contains
  many tools implemented on Test2.
  
  If you are interested in writing new tools you should take a look at
  L<Test2::API> first.
  
  =head1 NAMESPACE LAYOUT
  
  This describes the namespace layout for the Test2 ecosystem. Not all the
  namespaces listed here are part of the Test2 distribution, some are implemented
  in L<Test2::Suite>.
  
  =head2 Test2::Tools::
  
  This namespace is for sets of tools. Modules in this namespace should export
  tools like C<ok()> and C<is()>. Most things written for Test2 should go here.
  Modules in this namespace B<MUST NOT> export subs from other tools. See the
  L</Test2::Bundle::> namespace if you want to do that.
  
  =head2 Test2::Plugin::
  
  This namespace is for plugins. Plugins are modules that change or enhance the
  behavior of Test2. An example of a plugin is a module that sets the encoding to
  utf8 globally. Another example is a module that causes a bail-out event after
  the first test failure.
  
  =head2 Test2::Bundle::
  
  This namespace is for bundles of tools and plugins. Loading one of these may
  load multiple tools and plugins. Modules in this namespace should not implement
  tools directly. In general modules in this namespace should load tools and
  plugins, then re-export things into the consumers namespace.
  
  =head2 Test2::Require::
  
  This namespace is for modules that cause a test to be skipped when conditions
  do not allow it to run. Examples would be modules that skip the test on older
  perls, or when non-essential modules have not been installed.
  
  =head2 Test2::Formatter::
  
  Formatters live under this namespace. L<Test2::Formatter::TAP> is the only
  formatter currently. It is acceptable for third party distributions to create
  new formatters under this namespace.
  
  =head2 Test2::Event::
  
  Events live under this namespace. It is considered acceptable for third party
  distributions to add new event types in this namespace.
  
  =head2 Test2::Hub::
  
  Hub subclasses (and some hub utility objects) live under this namespace. It is
  perfectly reasonable for third party distributions to add new hub subclasses in
  this namespace.
  
  =head2 Test2::IPC::
  
  The IPC subsystem lives in this namespace. There are not many good reasons to
  add anything to this namespace, with exception of IPC drivers.
  
  =head3 Test2::IPC::Driver::
  
  IPC drivers live in this namespace. It is fine to create new IPC drivers and to
  put them in this namespace.
  
  =head2 Test2::Util::
  
  This namespace is for general utilities used by testing tools. Please be
  considerate when adding new modules to this namespace.
  
  =head2 Test2::API::
  
  This is for Test2 API and related packages.
  
  =head2 Test2::
  
  The Test2:: namespace is intended for extensions and frameworks. Tools,
  Plugins, etc should not go directly into this namespace. However extensions
  that are used to build tools and plugins may go here.
  
  In short: If the module exports anything that should be run directly by a test
  script it should probably NOT go directly into C<Test2::XXX>.
  
  =head1 SEE ALSO
  
  L<Test2::API> - Primary API functions.
  
  L<Test2::API::Context> - Detailed documentation of the context object.
  
  L<Test2::IPC> - The IPC system used for threading/fork support.
  
  L<Test2::Formatter> - Formatters such as TAP live here.
  
  L<Test2::Event> - Events live in this namespace.
  
  L<Test2::Hub> - All events eventually funnel through a hub. Custom hubs are how
  C<intercept()> and C<run_subtest()> are implemented.
  
  =head1 CONTACTING US
  
  Many Test2 developers and users lurk on L<irc://irc.perl.org/#perl-qa> and
  L<irc://irc.perl.org/#toolchain>. We also have a slack team that can be joined
  by anyone with an C<@cpan.org> email address L<https://perl-test2.slack.com/>
  If you do not have an C<@cpan.org> email you can ask for a slack invite by
  emailing Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2

$fatpacked{"Test2/API.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API';
  package Test2::API;
  use strict;
  use warnings;
  
  use Test2::Util qw/USE_THREADS/;
  
  BEGIN {
      $ENV{TEST_ACTIVE} ||= 1;
      $ENV{TEST2_ACTIVE} = 1;
  }
  
  our $VERSION = '1.302136';
  
  
  my $INST;
  my $ENDING = 0;
  sub test2_set_is_end { ($ENDING) = @_ ? @_ : (1) }
  sub test2_get_is_end { $ENDING }
  
  use Test2::API::Instance(\$INST);
  
  # Set the exit status
  END {
      test2_set_is_end(); # See gh #16
      $INST->set_exit();
  }
  
  sub CLONE {
      my $init = test2_init_done();
      my $load = test2_load_done();
  
      return if $init && $load;
  
      require Carp;
      Carp::croak "Test2 must be fully loaded before you start a new thread!\n";
  }
  
  # See gh #16
  {
      no warnings;
      INIT { eval 'END { test2_set_is_end() }; 1' or die $@ }
  }
  
  BEGIN {
      no warnings 'once';
      if($] ge '5.014' || $ENV{T2_CHECK_DEPTH} || $Test2::API::DO_DEPTH_CHECK) {
          *DO_DEPTH_CHECK = sub() { 1 };
      }
      else {
          *DO_DEPTH_CHECK = sub() { 0 };
      }
  }
  
  use Test2::EventFacet::Trace();
  use Test2::Util::Trace(); # Legacy
  
  use Test2::Hub::Subtest();
  use Test2::Hub::Interceptor();
  use Test2::Hub::Interceptor::Terminator();
  
  use Test2::Event::Ok();
  use Test2::Event::Diag();
  use Test2::Event::Note();
  use Test2::Event::Plan();
  use Test2::Event::Bail();
  use Test2::Event::Exception();
  use Test2::Event::Waiting();
  use Test2::Event::Skip();
  use Test2::Event::Subtest();
  
  use Carp qw/carp croak confess/;
  use Scalar::Util qw/blessed weaken/;
  use Test2::Util qw/get_tid clone_io pkg_to_file gen_uid/;
  
  our @EXPORT_OK = qw{
      context release
      context_do
      no_context
      intercept intercept_deep
      run_subtest
  
      test2_init_done
      test2_load_done
      test2_load
      test2_start_preload
      test2_stop_preload
      test2_in_preload
  
      test2_set_is_end
      test2_get_is_end
  
      test2_pid
      test2_tid
      test2_stack
      test2_no_wait
      test2_ipc_wait_enable
      test2_ipc_wait_disable
      test2_ipc_wait_enabled
  
      test2_add_uuid_via
  
      test2_add_callback_testing_done
  
      test2_add_callback_context_aquire
      test2_add_callback_context_acquire
      test2_add_callback_context_init
      test2_add_callback_context_release
      test2_add_callback_exit
      test2_add_callback_post_load
      test2_add_callback_pre_subtest
      test2_list_context_aquire_callbacks
      test2_list_context_acquire_callbacks
      test2_list_context_init_callbacks
      test2_list_context_release_callbacks
      test2_list_exit_callbacks
      test2_list_post_load_callbacks
      test2_list_pre_subtest_callbacks
  
      test2_ipc
      test2_has_ipc
      test2_ipc_disable
      test2_ipc_disabled
      test2_ipc_drivers
      test2_ipc_add_driver
      test2_ipc_polling
      test2_ipc_disable_polling
      test2_ipc_enable_polling
      test2_ipc_get_pending
      test2_ipc_set_pending
      test2_ipc_get_timeout
      test2_ipc_set_timeout
      test2_ipc_enable_shm
  
      test2_formatter
      test2_formatters
      test2_formatter_add
      test2_formatter_set
  
      test2_stdout
      test2_stderr
      test2_reset_io
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  my $STACK       = $INST->stack;
  my $CONTEXTS    = $INST->contexts;
  my $INIT_CBS    = $INST->context_init_callbacks;
  my $ACQUIRE_CBS = $INST->context_acquire_callbacks;
  
  my $STDOUT = clone_io(\*STDOUT);
  my $STDERR = clone_io(\*STDERR);
  sub test2_stdout { $STDOUT ||= clone_io(\*STDOUT) }
  sub test2_stderr { $STDERR ||= clone_io(\*STDERR) }
  
  sub test2_post_preload_reset {
      test2_reset_io();
      $INST->post_preload_reset;
  }
  
  sub test2_reset_io {
      $STDOUT = clone_io(\*STDOUT);
      $STDERR = clone_io(\*STDERR);
  }
  
  sub test2_init_done { $INST->finalized }
  sub test2_load_done { $INST->loaded }
  
  sub test2_load          { $INST->load }
  sub test2_start_preload { $ENV{T2_IN_PRELOAD} = 1; $INST->start_preload }
  sub test2_stop_preload  { $ENV{T2_IN_PRELOAD} = 0; $INST->stop_preload }
  sub test2_in_preload    { $INST->preload }
  
  sub test2_pid              { $INST->pid }
  sub test2_tid              { $INST->tid }
  sub test2_stack            { $INST->stack }
  sub test2_ipc_wait_enable  { $INST->set_no_wait(0) }
  sub test2_ipc_wait_disable { $INST->set_no_wait(1) }
  sub test2_ipc_wait_enabled { !$INST->no_wait }
  
  sub test2_no_wait {
      $INST->set_no_wait(@_) if @_;
      $INST->no_wait;
  }
  
  sub test2_add_callback_testing_done {
      my $cb = shift;
  
      test2_add_callback_post_load(sub {
          my $stack = test2_stack();
          $stack->top; # Insure we have a hub
          my ($hub) = Test2::API::test2_stack->all;
  
          $hub->set_active(1);
  
          $hub->follow_up($cb);
      });
  
      return;
  }
  
  sub test2_add_callback_context_acquire   { $INST->add_context_acquire_callback(@_) }
  sub test2_add_callback_context_aquire    { $INST->add_context_acquire_callback(@_) }
  sub test2_add_callback_context_init      { $INST->add_context_init_callback(@_) }
  sub test2_add_callback_context_release   { $INST->add_context_release_callback(@_) }
  sub test2_add_callback_exit              { $INST->add_exit_callback(@_) }
  sub test2_add_callback_post_load         { $INST->add_post_load_callback(@_) }
  sub test2_add_callback_pre_subtest       { $INST->add_pre_subtest_callback(@_) }
  sub test2_list_context_aquire_callbacks  { @{$INST->context_acquire_callbacks} }
  sub test2_list_context_acquire_callbacks { @{$INST->context_acquire_callbacks} }
  sub test2_list_context_init_callbacks    { @{$INST->context_init_callbacks} }
  sub test2_list_context_release_callbacks { @{$INST->context_release_callbacks} }
  sub test2_list_exit_callbacks            { @{$INST->exit_callbacks} }
  sub test2_list_post_load_callbacks       { @{$INST->post_load_callbacks} }
  sub test2_list_pre_subtest_callbacks     { @{$INST->pre_subtest_callbacks} }
  
  sub test2_add_uuid_via {
      $INST->set_add_uuid_via(@_) if @_;
      $INST->add_uuid_via();
  }
  
  sub test2_ipc                 { $INST->ipc }
  sub test2_has_ipc             { $INST->has_ipc }
  sub test2_ipc_disable         { $INST->ipc_disable }
  sub test2_ipc_disabled        { $INST->ipc_disabled }
  sub test2_ipc_add_driver      { $INST->add_ipc_driver(@_) }
  sub test2_ipc_drivers         { @{$INST->ipc_drivers} }
  sub test2_ipc_polling         { $INST->ipc_polling }
  sub test2_ipc_enable_polling  { $INST->enable_ipc_polling }
  sub test2_ipc_disable_polling { $INST->disable_ipc_polling }
  sub test2_ipc_get_pending     { $INST->get_ipc_pending }
  sub test2_ipc_set_pending     { $INST->set_ipc_pending(@_) }
  sub test2_ipc_set_timeout     { $INST->set_ipc_timeout(@_) }
  sub test2_ipc_get_timeout     { $INST->ipc_timeout() }
  sub test2_ipc_enable_shm      { $INST->ipc_enable_shm }
  
  sub test2_formatter     {
      if ($ENV{T2_FORMATTER} && $ENV{T2_FORMATTER} =~ m/^(\+)?(.*)$/) {
          my $formatter = $1 ? $2 : "Test2::Formatter::$2";
          my $file = pkg_to_file($formatter);
          require $file;
          return $formatter;
      }
  
      return $INST->formatter;
  }
  
  sub test2_formatters    { @{$INST->formatters} }
  sub test2_formatter_add { $INST->add_formatter(@_) }
  sub test2_formatter_set {
      my ($formatter) = @_;
      croak "No formatter specified" unless $formatter;
      croak "Global Formatter already set" if $INST->formatter_set;
      $INST->set_formatter($formatter);
  }
  
  # Private, for use in Test2::API::Context
  sub _contexts_ref                  { $INST->contexts }
  sub _context_acquire_callbacks_ref { $INST->context_acquire_callbacks }
  sub _context_init_callbacks_ref    { $INST->context_init_callbacks }
  sub _context_release_callbacks_ref { $INST->context_release_callbacks }
  sub _add_uuid_via_ref              { \($INST->{Test2::API::Instance::ADD_UUID_VIA()}) }
  
  # Private, for use in Test2::IPC
  sub _set_ipc { $INST->set_ipc(@_) }
  
  sub context_do(&;@) {
      my $code = shift;
      my @args = @_;
  
      my $ctx = context(level => 1);
  
      my $want = wantarray;
  
      my @out;
      my $ok = eval {
          $want          ? @out    = $code->($ctx, @args) :
          defined($want) ? $out[0] = $code->($ctx, @args) :
                                     $code->($ctx, @args) ;
          1;
      };
      my $err = $@;
  
      $ctx->release;
  
      die $err unless $ok;
  
      return @out    if $want;
      return $out[0] if defined $want;
      return;
  }
  
  sub no_context(&;$) {
      my ($code, $hid) = @_;
      $hid ||= $STACK->top->hid;
  
      my $ctx = $CONTEXTS->{$hid};
      delete $CONTEXTS->{$hid};
      my $ok = eval { $code->(); 1 };
      my $err = $@;
  
      $CONTEXTS->{$hid} = $ctx;
      weaken($CONTEXTS->{$hid});
  
      die $err unless $ok;
  
      return;
  };
  
  my $UUID_VIA = _add_uuid_via_ref();
  sub context {
      # We need to grab these before anything else to ensure they are not
      # changed.
      my ($errno, $eval_error, $child_error, $extended_error) = (0 + $!, $@, $?, $^E);
  
      my %params = (level => 0, wrapped => 0, @_);
  
      # If something is getting a context then the sync system needs to be
      # considered loaded...
      $INST->load unless $INST->{loaded};
  
      croak "context() called, but return value is ignored"
          unless defined wantarray;
  
      my $stack   = $params{stack} || $STACK;
      my $hub     = $params{hub}   || (@$stack ? $stack->[-1] : $stack->top);
      my $hid     = $hub->{hid};
      my $current = $CONTEXTS->{$hid};
  
      $_->(\%params) for @$ACQUIRE_CBS;
      map $_->(\%params), @{$hub->{_context_acquire}} if $hub->{_context_acquire};
  
      # This is for https://github.com/Test-More/test-more/issues/16
      # and https://rt.perl.org/Public/Bug/Display.html?id=127774
      my $phase = ${^GLOBAL_PHASE} || 'NA';
      my $end_phase = $ENDING || $phase eq 'END' || $phase eq 'DESTRUCT';
  
      my $level = 1 + $params{level};
      my ($pkg, $file, $line, $sub) = $end_phase ? caller(0) : caller($level);
      unless ($pkg || $end_phase) {
          confess "Could not find context at depth $level" unless $params{fudge};
          ($pkg, $file, $line, $sub) = caller(--$level) while ($level >= 0 && !$pkg);
      }
  
      my $depth = $level;
      $depth++ while DO_DEPTH_CHECK && !$end_phase && (!$current || $depth <= $current->{_depth} + $params{wrapped}) && caller($depth + 1);
      $depth -= $params{wrapped};
      my $depth_ok = !DO_DEPTH_CHECK || $end_phase || !$current || $current->{_depth} < $depth;
  
      if ($current && $params{on_release} && $depth_ok) {
          $current->{_on_release} ||= [];
          push @{$current->{_on_release}} => $params{on_release};
      }
  
      # I know this is ugly....
      ($!, $@, $?, $^E) = ($errno, $eval_error, $child_error, $extended_error) and return bless(
          {
              %$current,
              _is_canon   => undef,
              errno       => $errno,
              eval_error  => $eval_error,
              child_error => $child_error,
              _is_spawn   => [$pkg, $file, $line, $sub],
          },
          'Test2::API::Context'
      ) if $current && $depth_ok;
  
      # Handle error condition of bad level
      if ($current) {
          unless (${$current->{_aborted}}) {
              _canon_error($current, [$pkg, $file, $line, $sub, $depth])
                  unless $current->{_is_canon};
  
              _depth_error($current, [$pkg, $file, $line, $sub, $depth])
                  unless $depth_ok;
          }
  
          $current->release if $current->{_is_canon};
  
          delete $CONTEXTS->{$hid};
      }
  
      # Directly bless the object here, calling new is a noticeable performance
      # hit with how often this needs to be called.
      my $trace = bless(
          {
              frame  => [$pkg, $file, $line, $sub],
              pid    => $$,
              tid    => get_tid(),
              cid    => gen_uid(),
              hid    => $hid,
              nested => $hub->{nested},
              buffered => $hub->{buffered},
  
              $$UUID_VIA ? (
                  huuid => $hub->{uuid},
                  uuid  => ${$UUID_VIA}->('context'),
              ) : (),
          },
          'Test2::EventFacet::Trace'
      );
  
      # Directly bless the object here, calling new is a noticeable performance
      # hit with how often this needs to be called.
      my $aborted = 0;
      $current = bless(
          {
              _aborted     => \$aborted,
              stack        => $stack,
              hub          => $hub,
              trace        => $trace,
              _is_canon    => 1,
              _depth       => $depth,
              errno        => $errno,
              eval_error   => $eval_error,
              child_error  => $child_error,
              $params{on_release} ? (_on_release => [$params{on_release}]) : (),
          },
          'Test2::API::Context'
      );
  
      $CONTEXTS->{$hid} = $current;
      weaken($CONTEXTS->{$hid});
  
      $_->($current) for @$INIT_CBS;
      map $_->($current), @{$hub->{_context_init}} if $hub->{_context_init};
  
      $params{on_init}->($current) if $params{on_init};
  
      ($!, $@, $?, $^E) = ($errno, $eval_error, $child_error, $extended_error);
  
      return $current;
  }
  
  sub _depth_error {
      _existing_error(@_, <<"    EOT");
  context() was called to retrieve an existing context, however the existing
  context was created in a stack frame at the same, or deeper level. This usually
  means that a tool failed to release the context when it was finished.
      EOT
  }
  
  sub _canon_error {
      _existing_error(@_, <<"    EOT");
  context() was called to retrieve an existing context, however the existing
  context has an invalid internal state (!_canon_count). This should not normally
  happen unless something is mucking about with internals...
      EOT
  }
  
  sub _existing_error {
      my ($ctx, $details, $msg) = @_;
      my ($pkg, $file, $line, $sub, $depth) = @$details;
  
      my $oldframe = $ctx->{trace}->frame;
      my $olddepth = $ctx->{_depth};
  
      # Older versions of Carp do not export longmess() function, so it needs to be called with package name
      my $mess = Carp::longmess();
  
      warn <<"    EOT";
  $msg
  Old context details:
     File: $oldframe->[1]
     Line: $oldframe->[2]
     Tool: $oldframe->[3]
    Depth: $olddepth
  
  New context details:
     File: $file
     Line: $line
     Tool: $sub
    Depth: $depth
  
  Trace: $mess
  
  Removing the old context and creating a new one...
      EOT
  }
  
  sub release($;$) {
      $_[0]->release;
      return $_[1];
  }
  
  sub intercept(&) {
      my $code = shift;
      my $ctx = context();
  
      my $events = _intercept($code, deep => 0);
  
      $ctx->release;
  
      return $events;
  }
  
  sub intercept_deep(&) {
      my $code = shift;
      my $ctx = context();
  
      my $events = _intercept($code, deep => 1);
  
      $ctx->release;
  
      return $events;
  }
  
  sub _intercept {
      my $code = shift;
      my %params = @_;
      my $ctx = context();
  
      my $ipc;
      if (my $global_ipc = test2_ipc()) {
          my $driver = blessed($global_ipc);
          $ipc = $driver->new;
      }
  
      my $hub = Test2::Hub::Interceptor->new(
          ipc => $ipc,
          no_ending => 1,
      );
  
      my @events;
      $hub->listen(sub { push @events => $_[1] }, inherit => $params{deep});
  
      $ctx->stack->top; # Make sure there is a top hub before we begin.
      $ctx->stack->push($hub);
  
      my ($ok, $err) = (1, undef);
      T2_SUBTEST_WRAPPER: {
          # Do not use 'try' cause it localizes __DIE__
          $ok = eval { $code->(hub => $hub, context => $ctx->snapshot); 1 };
          $err = $@;
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && $err->isa('Test2::Hub::Interceptor::Terminator'))) {
              $ok  = 1;
              $err = undef;
          }
      }
  
      $hub->cull;
      $ctx->stack->pop($hub);
  
      my $trace = $ctx->trace;
      $ctx->release;
  
      die $err unless $ok;
  
      $hub->finalize($trace, 1)
          if $ok
          && !$hub->no_ending
          && !$hub->ended;
  
      return \@events;
  }
  
  sub run_subtest {
      my ($name, $code, $params, @args) = @_;
  
      $_->($name,$code,@args)
          for Test2::API::test2_list_pre_subtest_callbacks();
  
      $params = {buffered => $params} unless ref $params;
      my $inherit_trace = delete $params->{inherit_trace};
  
      my $ctx = context();
  
      my $parent = $ctx->hub;
  
      # If a parent is buffered then the child must be as well.
      my $buffered = $params->{buffered} || $parent->{buffered};
  
      $ctx->note($name) unless $buffered;
  
      my $stack = $ctx->stack || $STACK;
      my $hub = $stack->new_hub(
          class => 'Test2::Hub::Subtest',
          %$params,
          buffered => $buffered,
      );
  
      my @events;
      $hub->listen(sub { push @events => $_[1] });
  
      if ($buffered) {
          if (my $format = $hub->format) {
              my $hide = $format->can('hide_buffered') ? $format->hide_buffered : 1;
              $hub->format(undef) if $hide;
          }
      }
  
      if ($inherit_trace) {
          my $orig = $code;
          $code = sub {
              my $base_trace = $ctx->trace;
              my $trace = $base_trace->snapshot(nested => 1 + $base_trace->nested);
              my $st_ctx = Test2::API::Context->new(
                  trace  => $trace,
                  hub    => $hub,
              );
              $st_ctx->do_in_context($orig, @args);
          };
      }
  
      my ($ok, $err, $finished);
      T2_SUBTEST_WRAPPER: {
          # Do not use 'try' cause it localizes __DIE__
          $ok = eval { $code->(@args); 1 };
          $err = $@;
  
          # They might have done 'BEGIN { skip_all => "whatever" }'
          if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/ || (blessed($err) && blessed($err) eq 'Test::Builder::Exception')) {
              $ok  = undef;
              $err = undef;
          }
          else {
              $finished = 1;
          }
      }
  
      if ($params->{no_fork}) {
          if ($$ != $ctx->trace->pid) {
              warn $ok ? "Forked inside subtest, but subtest never finished!\n" : $err;
              exit 255;
          }
  
          if (get_tid() != $ctx->trace->tid) {
              warn $ok ? "Started new thread inside subtest, but thread never finished!\n" : $err;
              exit 255;
          }
      }
      elsif (!$parent->is_local && !$parent->ipc) {
          warn $ok ? "A new process or thread was started inside subtest, but IPC is not enabled!\n" : $err;
          exit 255;
      }
  
      $stack->pop($hub);
  
      my $trace = $ctx->trace;
  
      my $bailed = $hub->bailed_out;
  
      if (!$finished) {
          if ($bailed && !$buffered) {
              $ctx->bail($bailed->reason);
          }
          elsif ($bailed && $buffered) {
              $ok = 1;
          }
          else {
              my $code = $hub->exit_code;
              $ok = !$code;
              $err = "Subtest ended with exit code $code" if $code;
          }
      }
  
      $hub->finalize($trace->snapshot(huuid => $hub->uuid, hid => $hub->hid, nested => $hub->nested, buffered => $buffered), 1)
          if $ok
          && !$hub->no_ending
          && !$hub->ended;
  
      my $pass = $ok && $hub->is_passing;
      my $e = $ctx->build_event(
          'Subtest',
          pass         => $pass,
          name         => $name,
          subtest_id   => $hub->id,
          subtest_uuid => $hub->uuid,
          buffered     => $buffered,
          subevents    => \@events,
      );
  
      my $plan_ok = $hub->check_plan;
  
      $ctx->hub->send($e);
  
      $ctx->failure_diag($e) unless $e->pass;
  
      $ctx->diag("Caught exception in subtest: $err") unless $ok;
  
      $ctx->diag("Bad subtest plan, expected " . $hub->plan . " but ran " . $hub->count)
          if defined($plan_ok) && !$plan_ok;
  
      $ctx->bail($bailed->reason) if $bailed && $buffered;
  
      $ctx->release;
      return $pass;
  }
  
  # There is a use-cycle between API and API/Context. Context needs to use some
  # API functions as the package is compiling. Test2::API::context() needs
  # Test2::API::Context to be loaded, but we cannot 'require' the module there as
  # it causes a very noticeable performance impact with how often context() is
  # called.
  require Test2::API::Context;
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API - Primary interface for writing Test2 based testing tools.
  
  =head1 ***INTERNALS NOTE***
  
  B<The internals of this package are subject to change at any time!> The public
  methods provided will not change in backwards-incompatible ways (once there is
  a stable release), but the underlying implementation details might.
  B<Do not break encapsulation here!>
  
  Currently the implementation is to create a single instance of the
  L<Test2::API::Instance> Object. All class methods defer to the single
  instance. There is no public access to the singleton, and that is intentional.
  The class methods provided by this package provide the only functionality
  publicly exposed.
  
  This is done primarily to avoid the problems Test::Builder had by exposing its
  singleton. We do not want anyone to replace this singleton, rebless it, or
  directly muck with its internals. If you need to do something and cannot
  because of the restrictions placed here, then please report it as an issue. If
  possible, we will create a way for you to implement your functionality without
  exposing things that should not be exposed.
  
  =head1 DESCRIPTION
  
  This package exports all the functions necessary to write and/or verify testing
  tools. Using these building blocks you can begin writing test tools very
  quickly. You are also provided with tools that help you to test the tools you
  write.
  
  =head1 SYNOPSIS
  
  =head2 WRITING A TOOL
  
  The C<context()> method is your primary interface into the Test2 framework.
  
      package My::Ok;
      use Test2::API qw/context/;
  
      our @EXPORT = qw/my_ok/;
      use base 'Exporter';
  
      # Just like ok() from Test::More
      sub my_ok($;$) {
          my ($bool, $name) = @_;
          my $ctx = context(); # Get a context
          $ctx->ok($bool, $name);
          $ctx->release; # Release the context
          return $bool;
      }
  
  See L<Test2::API::Context> for a list of methods available on the context object.
  
  =head2 TESTING YOUR TOOLS
  
  The C<intercept { ... }> tool lets you temporarily intercept all events
  generated by the test system:
  
      use Test2::API qw/intercept/;
  
      use My::Ok qw/my_ok/;
  
      my $events = intercept {
          # These events are not displayed
          my_ok(1, "pass");
          my_ok(0, "fail");
      };
  
      my_ok(@$events == 2, "got 2 events, the pass and the fail");
      my_ok($events->[0]->pass, "first event passed");
      my_ok(!$events->[1]->pass, "second event failed");
  
  =head3 DEEP EVENT INTERCEPTION
  
  Normally C<intercept { ... }> only intercepts events sent to the main hub (as
  added by intercept itself). Nested hubs, such as those created by subtests,
  will not be intercepted. This is normally what you will still see the nested
  events by inspecting the subtest event. However there are times where you want
  to verify each event as it is sent, in that case use C<intercept_deep { ... }>.
  
      my $events = intercept_Deep {
          buffered_subtest foo => sub {
              ok(1, "pass");
          };
      };
  
  C<$events> in this case will contain 3 items:
  
  =over 4
  
  =item The event from C<ok(1, "pass")>
  
  =item The plan event for the subtest
  
  =item The subtest event itself, with the first 2 events nested inside it as children.
  
  =back
  
  This lets you see the order in which the events were sent, unlike
  C<intercept { ... }> which only lets you see events as the main hub sees them.
  
  =head2 OTHER API FUNCTIONS
  
      use Test2::API qw{
          test2_init_done
          test2_stack
          test2_set_is_end
          test2_get_is_end
          test2_ipc
          test2_formatter_set
          test2_formatter
      };
  
      my $init  = test2_init_done();
      my $stack = test2_stack();
      my $ipc   = test2_ipc();
  
      test2_formatter_set($FORMATTER)
      my $formatter = test2_formatter();
  
      ... And others ...
  
  =head1 MAIN API EXPORTS
  
  All exports are optional. You must specify subs to import.
  
      use Test2::API qw/context intercept run_subtest/;
  
  This is the list of exports that are most commonly needed. If you are simply
  writing a tool, then this is probably all you need. If you need something and
  you cannot find it here, then you can also look at L</OTHER API EXPORTS>.
  
  These exports lack the 'test2_' prefix because of how important/common they
  are. Exports in the L</OTHER API EXPORTS> section have the 'test2_' prefix to
  ensure they stand out.
  
  =head2 context(...)
  
  Usage:
  
  =over 4
  
  =item $ctx = context()
  
  =item $ctx = context(%params)
  
  =back
  
  The C<context()> function will always return the current context. If
  there is already a context active, it will be returned. If there is not an
  active context, one will be generated. When a context is generated it will
  default to using the file and line number where the currently running sub was
  called from.
  
  Please see L<Test2::API::Context/"CRITICAL DETAILS"> for important rules about
  what you can and cannot do with a context once it is obtained.
  
  B<Note> This function will throw an exception if you ignore the context object
  it returns.
  
  B<Note> On perls 5.14+ a depth check is used to insure there are no context
  leaks. This cannot be safely done on older perls due to
  L<https://rt.perl.org/Public/Bug/Display.html?id=127774>
  You can forcefully enable it either by setting C<$ENV{T2_CHECK_DEPTH} = 1> or
  C<$Test2::API::DO_DEPTH_CHECK = 1> B<BEFORE> loading L<Test2::API>.
  
  =head3 OPTIONAL PARAMETERS
  
  All parameters to C<context> are optional.
  
  =over 4
  
  =item level => $int
  
  If you must obtain a context in a sub deeper than your entry point you can use
  this to tell it how many EXTRA stack frames to look back. If this option is not
  provided the default of C<0> is used.
  
      sub third_party_tool {
          my $sub = shift;
          ... # Does not obtain a context
          $sub->();
          ...
      }
  
      third_party_tool(sub {
          my $ctx = context(level => 1);
          ...
          $ctx->release;
      });
  
  =item wrapped => $int
  
  Use this if you need to write your own tool that wraps a call to C<context()>
  with the intent that it should return a context object.
  
      sub my_context {
          my %params = ( wrapped => 0, @_ );
          $params{wrapped}++;
          my $ctx = context(%params);
          ...
          return $ctx;
      }
  
      sub my_tool {
          my $ctx = my_context();
          ...
          $ctx->release;
      }
  
  If you do not do this, then tools you call that also check for a context will
  notice that the context they grabbed was created at the same stack depth, which
  will trigger protective measures that warn you and destroy the existing
  context.
  
  =item stack => $stack
  
  Normally C<context()> looks at the global hub stack. If you are maintaining
  your own L<Test2::API::Stack> instance you may pass it in to be used
  instead of the global one.
  
  =item hub => $hub
  
  Use this parameter if you want to obtain the context for a specific hub instead
  of whatever one happens to be at the top of the stack.
  
  =item on_init => sub { ... }
  
  This lets you provide a callback sub that will be called B<ONLY> if your call
  to C<context()> generated a new context. The callback B<WILL NOT> be called if
  C<context()> is returning an existing context. The only argument passed into
  the callback will be the context object itself.
  
      sub foo {
          my $ctx = context(on_init => sub { 'will run' });
  
          my $inner = sub {
              # This callback is not run since we are getting the existing
              # context from our parent sub.
              my $ctx = context(on_init => sub { 'will NOT run' });
              $ctx->release;
          }
          $inner->();
  
          $ctx->release;
      }
  
  =item on_release => sub { ... }
  
  This lets you provide a callback sub that will be called when the context
  instance is released. This callback will be added to the returned context even
  if an existing context is returned. If multiple calls to context add callbacks,
  then all will be called in reverse order when the context is finally released.
  
      sub foo {
          my $ctx = context(on_release => sub { 'will run second' });
  
          my $inner = sub {
              my $ctx = context(on_release => sub { 'will run first' });
  
              # Neither callback runs on this release
              $ctx->release;
          }
          $inner->();
  
          # Both callbacks run here.
          $ctx->release;
      }
  
  =back
  
  =head2 release($;$)
  
  Usage:
  
  =over 4
  
  =item release $ctx;
  
  =item release $ctx, ...;
  
  =back
  
  This is intended as a shortcut that lets you release your context and return a
  value in one statement. This function will get your context, and an optional
  return value. It will release your context, then return your value. Scalar
  context is always assumed.
  
      sub tool {
          my $ctx = context();
          ...
  
          return release $ctx, 1;
      }
  
  This tool is most useful when you want to return the value you get from calling
  a function that needs to see the current context:
  
      my $ctx = context();
      my $out = some_tool(...);
      $ctx->release;
      return $out;
  
  We can combine the last 3 lines of the above like so:
  
      my $ctx = context();
      release $ctx, some_tool(...);
  
  =head2 context_do(&;@)
  
  Usage:
  
      sub my_tool {
          context_do {
              my $ctx = shift;
  
              my (@args) = @_;
  
              $ctx->ok(1, "pass");
  
              ...
  
              # No need to call $ctx->release, done for you on scope exit.
          } @_;
      }
  
  Using this inside your test tool takes care of a lot of boilerplate for you. It
  will ensure a context is acquired. It will capture and rethrow any exception. It
  will insure the context is released when you are done. It preserves the
  subroutine call context (array, scalar, void).
  
  This is the safest way to write a test tool. The only two downsides to this are a
  slight performance decrease, and some extra indentation in your source. If the
  indentation is a problem for you then you can take a peek at the next section.
  
  =head2 no_context(&;$)
  
  Usage:
  
  =over 4
  
  =item no_context { ... };
  
  =item no_context { ... } $hid;
  
      sub my_tool(&) {
          my $code = shift;
          my $ctx = context();
          ...
  
          no_context {
              # Things in here will not see our current context, they get a new
              # one.
  
              $code->();
          };
  
          ...
          $ctx->release;
      };
  
  =back
  
  This tool will hide a context for the provided block of code. This means any
  tools run inside the block will get a completely new context if they acquire
  one. The new context will be inherited by tools nested below the one that
  acquired it.
  
  This will normally hide the current context for the top hub. If you need to
  hide the context for a different hub you can pass in the optional C<$hid>
  parameter.
  
  =head2 intercept(&)
  
  Usage:
  
      my $events = intercept {
          ok(1, "pass");
          ok(0, "fail");
          ...
      };
  
  This function takes a codeblock as its only argument, and it has a prototype.
  It will execute the codeblock, intercepting any generated events in the
  process. It will return an array reference with all the generated event
  objects. All events should be subclasses of L<Test2::Event>.
  
  This is a very low-level subtest tool. This is useful for writing tools which
  produce subtests. This is not intended for people simply writing tests.
  
  =head2 run_subtest(...)
  
  Usage:
  
      run_subtest($NAME, \&CODE, $BUFFERED, @ARGS)
  
      # or
  
      run_subtest($NAME, \&CODE, \%PARAMS, @ARGS)
  
  This will run the provided codeblock with the args in C<@args>. This codeblock
  will be run as a subtest. A subtest is an isolated test state that is condensed
  into a single L<Test2::Event::Subtest> event, which contains all events
  generated inside the subtest.
  
  =head3 ARGUMENTS:
  
  =over 4
  
  =item $NAME
  
  The name of the subtest.
  
  =item \&CODE
  
  The code to run inside the subtest.
  
  =item $BUFFERED or \%PARAMS
  
  If this is a simple scalar then it will be treated as a boolean for the
  'buffered' setting. If this is a hash reference then it will be used as a
  parameters hash. The param hash will be used for hub construction (with the
  specified keys removed).
  
  Keys that are removed and used by run_subtest:
  
  =over 4
  
  =item 'buffered' => $bool
  
  Toggle buffered status.
  
  =item 'inherit_trace' => $bool
  
  Normally the subtest hub is pushed and the sub is allowed to generate its own
  root context for the hub. When this setting is turned on a root context will be
  created for the hub that shares the same trace as the current context.
  
  Set this to true if your tool is producing subtests without user-specified
  subs.
  
  =item 'no_fork' => $bool
  
  Defaults to off. Normally forking inside a subtest will actually fork the
  subtest, resulting in 2 final subtest events. This parameter will turn off that
  behavior, only the original process/thread will return a final subtest event.
  
  =back
  
  =item @ARGS
  
  Any extra arguments you want passed into the subtest code.
  
  =back
  
  =head3 BUFFERED VS UNBUFFERED (OR STREAMED)
  
  Normally all events inside and outside a subtest are sent to the formatter
  immediately by the hub. Sometimes it is desirable to hold off sending events
  within a subtest until the subtest is complete. This usually depends on the
  formatter being used.
  
  =over 4
  
  =item Things not effected by this flag
  
  In both cases events are generated and stored in an array. This array is
  eventually used to populate the C<subevents> attribute on the
  L<Test2::Event::Subtest> event that is generated at the end of the subtest.
  This flag has no effect on this part, it always happens.
  
  At the end of the subtest, the final L<Test2::Event::Subtest> event is sent to
  the formatter.
  
  =item Things that are effected by this flag
  
  The C<buffered> attribute of the L<Test2::Event::Subtest> event will be set to
  the value of this flag. This means any formatter, listener, etc which looks at
  the event will know if it was buffered.
  
  =item Things that are formatter dependant
  
  Events within a buffered subtest may or may not be sent to the formatter as
  they happen. If a formatter fails to specify then the default is to B<NOT SEND>
  the events as they are generated, instead the formatter can pull them from the
  C<subevents> attribute.
  
  A formatter can specify by implementing the C<hide_buffered()> method. If this
  method returns true then events generated inside a buffered subtest will not be
  sent independently of the final subtest event.
  
  =back
  
  An example of how this is used is the L<Test2::Formatter::TAP> formatter. For
  unbuffered subtests the events are rendered as they are generated. At the end
  of the subtest, the final subtest event is rendered, but the C<subevents>
  attribute is ignored. For buffered subtests the opposite occurs, the events are
  NOT rendered as they are generated, instead the C<subevents> attribute is used
  to render them all at once. This is useful when running subtests tests in
  parallel, since without it the output from subtests would be interleaved
  together.
  
  =head1 OTHER API EXPORTS
  
  Exports in this section are not commonly needed. These all have the 'test2_'
  prefix to help ensure they stand out. You should look at the L</MAIN API
  EXPORTS> section before looking here. This section is one where "Great power
  comes with great responsibility". It is possible to break things badly if you
  are not careful with these.
  
  All exports are optional. You need to list which ones you want at import time:
  
      use Test2::API qw/test2_init_done .../;
  
  =head2 STATUS AND INITIALIZATION STATE
  
  These provide access to internal state and object instances.
  
  =over 4
  
  =item $bool = test2_init_done()
  
  This will return true if the stack and IPC instances have already been
  initialized. It will return false if they have not. Init happens as late as
  possible. It happens as soon as a tool requests the IPC instance, the
  formatter, or the stack.
  
  =item $bool = test2_load_done()
  
  This will simply return the boolean value of the loaded flag. If Test2 has
  finished loading this will be true, otherwise false. Loading is considered
  complete the first time a tool requests a context.
  
  =item test2_set_is_end()
  
  =item test2_set_is_end($bool)
  
  This is used to toggle Test2's belief that the END phase has already started.
  With no arguments this will set it to true. With arguments it will set it to
  the first argument's value.
  
  This is used to prevent the use of C<caller()> in END blocks which can cause
  segfaults. This is only necessary in some persistent environments that may have
  multiple END phases.
  
  =item $bool = test2_get_is_end()
  
  Check if Test2 believes it is the END phase.
  
  =item $stack = test2_stack()
  
  This will return the global L<Test2::API::Stack> instance. If this has not
  yet been initialized it will be initialized now.
  
  =item test2_ipc_disable
  
  Disable IPC.
  
  =item $bool = test2_ipc_diabled
  
  Check if IPC is disabled.
  
  =item test2_ipc_wait_enable()
  
  =item test2_ipc_wait_disable()
  
  =item $bool = test2_ipc_wait_enabled()
  
  These can be used to turn IPC waiting on and off, or check the current value of
  the flag.
  
  Waiting is turned on by default. Waiting will cause the parent process/thread
  to wait until all child processes and threads are finished before exiting. You
  will almost never want to turn this off.
  
  =item $bool = test2_no_wait()
  
  =item test2_no_wait($bool)
  
  B<DISCOURAGED>: This is a confusing interface, it is better to use
  C<test2_ipc_wait_enable()>, C<test2_ipc_wait_disable()> and
  C<test2_ipc_wait_enabled()>.
  
  This can be used to get/set the no_wait status. Waiting is turned on by
  default. Waiting will cause the parent process/thread to wait until all child
  processes and threads are finished before exiting. You will almost never want
  to turn this off.
  
  =item $fh = test2_stdout()
  
  =item $fh = test2_stderr()
  
  These functions return the filehandles that test output should be written to.
  They are primarily useful when writing a custom formatter and code that turns
  events into actual output (TAP, etc.)  They will return a dupe of the original
  filehandles that formatted output can be sent to regardless of whatever state
  the currently running test may have left STDOUT and STDERR in.
  
  =item test2_reset_io()
  
  Re-dupe the internal filehandles returned by C<test2_stdout()> and
  C<test2_stderr()> from the current STDOUT and STDERR.  You shouldn't need to do
  this except in very peculiar situations (for example, you're testing a new
  formatter and you need control over where the formatter is sending its output.)
  
  =back
  
  =head2 BEHAVIOR HOOKS
  
  These are hooks that allow you to add custom behavior to actions taken by Test2
  and tools built on top of it.
  
  =over 4
  
  =item test2_add_callback_exit(sub { ... })
  
  This can be used to add a callback that is called after all testing is done. This
  is too late to add additional results, the main use of this callback is to set the
  exit code.
  
      test2_add_callback_exit(
          sub {
              my ($context, $exit, \$new_exit) = @_;
              ...
          }
      );
  
  The C<$context> passed in will be an instance of L<Test2::API::Context>. The
  C<$exit> argument will be the original exit code before anything modified it.
  C<$$new_exit> is a reference to the new exit code. You may modify this to
  change the exit code. Please note that C<$$new_exit> may already be different
  from C<$exit>
  
  =item test2_add_callback_post_load(sub { ... })
  
  Add a callback that will be called when Test2 is finished loading. This
  means the callback will be run once, the first time a context is obtained.
  If Test2 has already finished loading then the callback will be run immediately.
  
  =item test2_add_callback_testing_done(sub { ... })
  
  This adds your coderef as a follow-up to the root hub after Test2 is finished loading.
  
  This is essentially a helper to do the following:
  
      test2_add_callback_post_load(sub {
          my $stack = test2_stack();
          $stack->top; # Insure we have a hub
          my ($hub) = Test2::API::test2_stack->all;
  
          $hub->set_active(1);
  
          $hub->follow_up(sub { ... }); # <-- Your coderef here
      });
  
  =item test2_add_callback_context_acquire(sub { ... })
  
  Add a callback that will be called every time someone tries to acquire a
  context. This will be called on EVERY call to C<context()>. It gets a single
  argument, a reference to the hash of parameters being used the construct the
  context. This is your chance to change the parameters by directly altering the
  hash.
  
      test2_add_callback_context_acquire(sub {
          my $params = shift;
          $params->{level}++;
      });
  
  This is a very scary API function. Please do not use this unless you need to.
  This is here for L<Test::Builder> and backwards compatibility. This has you
  directly manipulate the hash instead of returning a new one for performance
  reasons.
  
  =item test2_add_callback_context_init(sub { ... })
  
  Add a callback that will be called every time a new context is created. The
  callback will receive the newly created context as its only argument.
  
  =item test2_add_callback_context_release(sub { ... })
  
  Add a callback that will be called every time a context is released. The
  callback will receive the released context as its only argument.
  
  =item test2_add_callback_pre_subtest(sub { ... })
  
  Add a callback that will be called every time a subtest is going to be
  run. The callback will receive the subtest name, coderef, and any
  arguments.
  
  =item @list = test2_list_context_acquire_callbacks()
  
  Return all the context acquire callback references.
  
  =item @list = test2_list_context_init_callbacks()
  
  Returns all the context init callback references.
  
  =item @list = test2_list_context_release_callbacks()
  
  Returns all the context release callback references.
  
  =item @list = test2_list_exit_callbacks()
  
  Returns all the exit callback references.
  
  =item @list = test2_list_post_load_callbacks()
  
  Returns all the post load callback references.
  
  =item @list = test2_list_pre_subtest_callbacks()
  
  Returns all the pre-subtest callback references.
  
  =item test2_add_uuid_via(sub { ... })
  
  =item $sub = test2_add_uuid_via()
  
  This allows you to provide a UUID generator. If provided UUIDs will be attached
  to all events, hubs, and contexts. This is useful for storing, tracking, and
  linking these objects.
  
  The sub you provide should always return a unique identifier. Most things will
  expect a proper UUID string, however nothing in Test2::API enforces this.
  
  The sub will receive exactly 1 argument, the type of thing being tagged
  'context', 'hub', or 'event'. In the future additional things may be tagged, in
  which case new strings will be passed in. These are purely informative, you can
  (and usually should) ignore them.
  
  =back
  
  =head2 IPC AND CONCURRENCY
  
  These let you access, or specify, the IPC system internals.
  
  =over 4
  
  =item $bool = test2_has_ipc()
  
  Check if IPC is enabled.
  
  =item $ipc = test2_ipc()
  
  This will return the global L<Test2::IPC::Driver> instance. If this has not yet
  been initialized it will be initialized now.
  
  =item test2_ipc_add_driver($DRIVER)
  
  Add an IPC driver to the list. This will add the driver to the start of the
  list.
  
  =item @drivers = test2_ipc_drivers()
  
  Get the list of IPC drivers.
  
  =item $bool = test2_ipc_polling()
  
  Check if polling is enabled.
  
  =item test2_ipc_enable_polling()
  
  Turn on polling. This will cull events from other processes and threads every
  time a context is created.
  
  =item test2_ipc_disable_polling()
  
  Turn off IPC polling.
  
  =item test2_ipc_enable_shm()
  
  Turn on IPC SHM. Only some IPC drivers use this, and most will turn it on
  themselves.
  
  =item test2_ipc_set_pending($uniq_val)
  
  Tell other processes and events that an event is pending. C<$uniq_val> should
  be a unique value no other thread/process will generate.
  
  B<Note:> After calling this C<test2_ipc_get_pending()> will return 1. This is
  intentional, and not avoidable.
  
  =item $pending = test2_ipc_get_pending()
  
  This returns -1 if there is no way to check (assume yes)
  
  This returns 0 if there are (most likely) no pending events.
  
  This returns 1 if there are (likely) pending events. Upon return it will reset,
  nothing else will be able to see that there were pending events.
  
  =item $timeout = test2_ipc_get_timeout()
  
  =item test2_ipc_set_timeout($timeout)
  
  Get/Set the timeout value for the IPC system. This timeout is how long the IPC
  system will wait for child processes and threads to finish before aborting.
  
  The default value is C<30> seconds.
  
  =back
  
  =head2 MANAGING FORMATTERS
  
  These let you access, or specify, the formatters that can/should be used.
  
  =over 4
  
  =item $formatter = test2_formatter
  
  This will return the global formatter class. This is not an instance. By
  default the formatter is set to L<Test2::Formatter::TAP>.
  
  You can override this default using the C<T2_FORMATTER> environment variable.
  
  Normally 'Test2::Formatter::' is prefixed to the value in the
  environment variable:
  
      $ T2_FORMATTER='TAP' perl test.t     # Use the Test2::Formatter::TAP formatter
      $ T2_FORMATTER='Foo' perl test.t     # Use the Test2::Formatter::Foo formatter
  
  If you want to specify a full module name you use the '+' prefix:
  
      $ T2_FORMATTER='+Foo::Bar' perl test.t     # Use the Foo::Bar formatter
  
  =item test2_formatter_set($class_or_instance)
  
  Set the global formatter class. This can only be set once. B<Note:> This will
  override anything specified in the 'T2_FORMATTER' environment variable.
  
  =item @formatters = test2_formatters()
  
  Get a list of all loaded formatters.
  
  =item test2_formatter_add($class_or_instance)
  
  Add a formatter to the list. Last formatter added is used at initialization. If
  this is called after initialization a warning will be issued.
  
  =back
  
  =head1 OTHER EXAMPLES
  
  See the C</Examples/> directory included in this distribution.
  
  =head1 SEE ALSO
  
  L<Test2::API::Context> - Detailed documentation of the context object.
  
  L<Test2::IPC> - The IPC system used for threading/fork support.
  
  L<Test2::Formatter> - Formatters such as TAP live here.
  
  L<Test2::Event> - Events live in this namespace.
  
  L<Test2::Hub> - All events eventually funnel through a hub. Custom hubs are how
  C<intercept()> and C<run_subtest()> are implemented.
  
  =head1 MAGIC
  
  This package has an END block. This END block is responsible for setting the
  exit code based on the test results. This end block also calls the callbacks that
  can be added to this package.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API

$fatpacked{"Test2/API/Breakage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_BREAKAGE';
  package Test2::API::Breakage;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::Util qw/pkg_to_file/;
  
  our @EXPORT_OK = qw{
      upgrade_suggested
      upgrade_required
      known_broken
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub upgrade_suggested {
      return (
          'Test::Exception'    => '0.42',
          'Test::FITesque'     => '0.04',
          'Test::Module::Used' => '0.2.5',
          'Test::Moose::More'  => '0.025',
      );
  }
  
  sub upgrade_required {
      return (
          'Test::Builder::Clutch'   => '0.07',
          'Test::Dist::VersionSync' => '1.1.4',
          'Test::Modern'            => '0.012',
          'Test::SharedFork'        => '0.34',
          'Test::Alien'             => '0.04',
          'Test::UseAllModules'     => '0.14',
          'Test::More::Prefix'      => '0.005',
  
          'Test2::Tools::EventDumper' => 0.000007,
          'Test2::Harness'            => 0.000013,
  
          'Test::DBIx::Class::Schema'    => '1.0.9',
          'Test::Clustericious::Cluster' => '0.30',
      );
  }
  
  sub known_broken {
      return (
          'Net::BitTorrent'       => '0.052',
          'Test::Able'            => '0.11',
          'Test::Aggregate'       => '0.373',
          'Test::Flatten'         => '0.11',
          'Test::Group'           => '0.20',
          'Test::ParallelSubtest' => '0.05',
          'Test::Pretty'          => '0.32',
          'Test::Wrapper'         => '0.3.0',
  
          'Log::Dispatch::Config::TestLog' => '0.02',
      );
  }
  
  # Not reportable:
  # Device::Chip => 0.07   - Tests will not pass, but not broken if already installed, also no fixed version we can upgrade to.
  
  sub report {
      my $class = shift;
      my ($require) = @_;
  
      my %suggest  = __PACKAGE__->upgrade_suggested();
      my %required = __PACKAGE__->upgrade_required();
      my %broken   = __PACKAGE__->known_broken();
  
      my @warn;
      for my $mod (keys %suggest) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $want = $suggest{$mod};
          next if eval { $mod->VERSION($want); 1 };
          push @warn => " * Module '$mod' is outdated, we recommed updating above $want.";
      }
  
      for my $mod (keys %required) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $want = $required{$mod};
          next if eval { $mod->VERSION($want); 1 };
          push @warn => " * Module '$mod' is outdated and known to be broken, please update to $want or higher.";
      }
  
      for my $mod (keys %broken) {
          my $file = pkg_to_file($mod);
          next unless $INC{$file} || ($require && eval { require $file; 1 });
          my $tested = $broken{$mod};
          push @warn => " * Module '$mod' is known to be broken in version $tested and below, newer versions have not been tested. You have: " . $mod->VERSION;
      }
  
      return @warn;
  }
  
  1;
  
  __END__
  
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Breakage - What breaks at what version
  
  =head1 DESCRIPTION
  
  This module provides lists of modules that are broken, or have been broken in
  the past, when upgrading L<Test::Builder> to use L<Test2>.
  
  =head1 FUNCTIONS
  
  These can be imported, or called as methods on the class.
  
  =over 4
  
  =item %mod_ver = upgrade_suggested()
  
  =item %mod_ver = Test2::API::Breakage->upgrade_suggested()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then an upgrade would be a good idea, but not strictly necessary.
  
  =item %mod_ver = upgrade_required()
  
  =item %mod_ver = Test2::API::Breakage->upgrade_required()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then an upgrade is required for the module to work properly.
  
  =item %mod_ver = known_broken()
  
  =item %mod_ver = Test2::API::Breakage->known_broken()
  
  This returns key/value pairs. The key is the module name, the value is the
  version number. If the installed version of the module is at or below the
  specified one then the module will not work. A newer version may work, but is
  not tested or verified.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_BREAKAGE

$fatpacked{"Test2/API/Context.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_CONTEXT';
  package Test2::API::Context;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/confess croak/;
  use Scalar::Util qw/weaken blessed/;
  use Test2::Util qw/get_tid try pkg_to_file get_tid/;
  
  use Test2::EventFacet::Trace();
  use Test2::API();
  
  # Preload some key event types
  my %LOADED = (
      map {
          my $pkg  = "Test2::Event::$_";
          my $file = "Test2/Event/$_.pm";
          require $file unless $INC{$file};
          ( $pkg => $pkg, $_ => $pkg )
      } qw/Ok Diag Note Plan Bail Exception Waiting Skip Subtest Pass Fail V2/
  );
  
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util::HashBase qw{
      stack hub trace _on_release _depth _is_canon _is_spawn _aborted
      errno eval_error child_error thrown
  };
  
  # Private, not package vars
  # It is safe to cache these.
  my $ON_RELEASE = Test2::API::_context_release_callbacks_ref();
  my $CONTEXTS   = Test2::API::_contexts_ref();
  
  sub init {
      my $self = shift;
  
      confess "The 'trace' attribute is required"
          unless $self->{+TRACE};
  
      confess "The 'hub' attribute is required"
          unless $self->{+HUB};
  
      $self->{+_DEPTH} = 0 unless defined $self->{+_DEPTH};
  
      $self->{+ERRNO}       = $! unless exists $self->{+ERRNO};
      $self->{+EVAL_ERROR}  = $@ unless exists $self->{+EVAL_ERROR};
      $self->{+CHILD_ERROR} = $? unless exists $self->{+CHILD_ERROR};
  }
  
  sub snapshot { bless {%{$_[0]}, _is_canon => undef, _is_spawn => undef, _aborted => undef}, __PACKAGE__ }
  
  sub restore_error_vars {
      my $self = shift;
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR};
  }
  
  sub DESTROY {
      return unless $_[0]->{+_IS_CANON} || $_[0]->{+_IS_SPAWN};
      return if $_[0]->{+_ABORTED} && ${$_[0]->{+_ABORTED}};
      my ($self) = @_;
  
      my $hub = $self->{+HUB};
      my $hid = $hub->{hid};
  
      # Do not show the warning if it looks like an exception has been thrown, or
      # if the context is not local to this process or thread.
      {
          # Sometimes $@ is uninitialized, not a problem in this case so do not
          # show the warning about using eq.
          no warnings 'uninitialized';
          if($self->{+EVAL_ERROR} eq $@ && $hub->is_local) {
              my $frame = $self->{+_IS_SPAWN} || $self->{+TRACE}->frame;
              warn <<"            EOT";
  A context appears to have been destroyed without first calling release().
  Based on \$@ it does not look like an exception was thrown (this is not always
  a reliable test)
  
  This is a problem because the global error variables (\$!, \$@, and \$?) will
  not be restored. In addition some release callbacks will not work properly from
  inside a DESTROY method.
  
  Here are the context creation details, just in case a tool forgot to call
  release():
    File: $frame->[1]
    Line: $frame->[2]
    Tool: $frame->[3]
  
  Cleaning up the CONTEXT stack...
              EOT
          }
      }
  
      return if $self->{+_IS_SPAWN};
  
      # Remove the key itself to avoid a slow memory leak
      delete $CONTEXTS->{$hid};
      $self->{+_IS_CANON} = undef;
  
      if (my $cbk = $self->{+_ON_RELEASE}) {
          $_->($self) for reverse @$cbk;
      }
      if (my $hcbk = $hub->{_context_release}) {
          $_->($self) for reverse @$hcbk;
      }
      $_->($self) for reverse @$ON_RELEASE;
  }
  
  # release exists to implement behaviors like die-on-fail. In die-on-fail you
  # want to die after a failure, but only after diagnostics have been reported.
  # The ideal time for the die to happen is when the context is released.
  # Unfortunately die does not work in a DESTROY block.
  sub release {
      my ($self) = @_;
  
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} and return if $self->{+THROWN};
  
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} and return $self->{+_IS_SPAWN} = undef
          if $self->{+_IS_SPAWN};
  
      croak "release() should not be called on context that is neither canon nor a child"
          unless $self->{+_IS_CANON};
  
      my $hub = $self->{+HUB};
      my $hid = $hub->{hid};
  
      croak "context thinks it is canon, but it is not"
          unless $CONTEXTS->{$hid} && $CONTEXTS->{$hid} == $self;
  
      # Remove the key itself to avoid a slow memory leak
      $self->{+_IS_CANON} = undef;
      delete $CONTEXTS->{$hid};
  
      if (my $cbk = $self->{+_ON_RELEASE}) {
          $_->($self) for reverse @$cbk;
      }
      if (my $hcbk = $hub->{_context_release}) {
          $_->($self) for reverse @$hcbk;
      }
      $_->($self) for reverse @$ON_RELEASE;
  
      # Do this last so that nothing else changes them.
      # If one of the hooks dies then these do not get restored, this is
      # intentional
      ($!, $@, $?) = @$self{+ERRNO, +EVAL_ERROR, +CHILD_ERROR};
  
      return;
  }
  
  sub do_in_context {
      my $self = shift;
      my ($sub, @args) = @_;
  
      # We need to update the pid/tid and error vars.
      my $clone = $self->snapshot;
      @$clone{+ERRNO, +EVAL_ERROR, +CHILD_ERROR} = ($!, $@, $?);
      $clone->{+TRACE} = $clone->{+TRACE}->snapshot(pid => $$, tid => get_tid());
  
      my $hub = $clone->{+HUB};
      my $hid = $hub->hid;
  
      my $old = $CONTEXTS->{$hid};
  
      $clone->{+_IS_CANON} = 1;
      $CONTEXTS->{$hid} = $clone;
      weaken($CONTEXTS->{$hid});
      my ($ok, $err) = &try($sub, @args);
      my ($rok, $rerr) = try { $clone->release };
      delete $clone->{+_IS_CANON};
  
      if ($old) {
          $CONTEXTS->{$hid} = $old;
          weaken($CONTEXTS->{$hid});
      }
      else {
          delete $CONTEXTS->{$hid};
      }
  
      die $err  unless $ok;
      die $rerr unless $rok;
  }
  
  sub done_testing {
      my $self = shift;
      $self->hub->finalize($self->trace, 1);
      return;
  }
  
  sub throw {
      my ($self, $msg) = @_;
      $self->{+THROWN} = 1;
      ${$self->{+_ABORTED}}++ if $self->{+_ABORTED};
      $self->release if $self->{+_IS_CANON} || $self->{+_IS_SPAWN};
      $self->trace->throw($msg);
  }
  
  sub alert {
      my ($self, $msg) = @_;
      $self->trace->alert($msg);
  }
  
  sub send_ev2_and_release {
      my $self = shift;
      my $out  = $self->send_ev2(@_);
      $self->release;
      return $out;
  }
  
  sub send_ev2 {
      my $self = shift;
  
      my $e;
      {
          local $Carp::CarpLevel = $Carp::CarpLevel + 1;
          $e = Test2::Event::V2->new(
              trace => $self->{+TRACE}->snapshot,
              @_,
          );
      }
  
      if ($self->{+_ABORTED}) {
          my $f = $e->facet_data;
          ${$self->{+_ABORTED}}++ if $f->{control}->{halt} || defined($f->{control}->{terminate}) || defined($e->terminate);
      }
      $self->{+HUB}->send($e);
  }
  
  sub build_ev2 {
      my $self = shift;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      Test2::Event::V2->new(
          trace => $self->{+TRACE}->snapshot,
          @_,
      );
  }
  
  sub send_event_and_release {
      my $self = shift;
      my $out = $self->send_event(@_);
      $self->release;
      return $out;
  }
  
  sub send_event {
      my $self  = shift;
      my $event = shift;
      my %args  = @_;
  
      my $pkg = $LOADED{$event} || $self->_parse_event($event);
  
      my $e;
      {
          local $Carp::CarpLevel = $Carp::CarpLevel + 1;
          $e = $pkg->new(
              trace => $self->{+TRACE}->snapshot,
              %args,
          );
      }
  
      if ($self->{+_ABORTED}) {
          my $f = $e->facet_data;
          ${$self->{+_ABORTED}}++ if $f->{control}->{halt} || defined($f->{control}->{terminate}) || defined($e->terminate);
      }
      $self->{+HUB}->send($e);
  }
  
  sub build_event {
      my $self  = shift;
      my $event = shift;
      my %args  = @_;
  
      my $pkg = $LOADED{$event} || $self->_parse_event($event);
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      $pkg->new(
          trace => $self->{+TRACE}->snapshot,
          %args,
      );
  }
  
  sub pass {
      my $self = shift;
      my ($name) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Pass"
      );
  
      $self->{+HUB}->send($e);
      return $e;
  }
  
  sub pass_and_release {
      my $self = shift;
      my ($name) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Pass"
      );
  
      $self->{+HUB}->send($e);
      $self->release;
      return 1;
  }
  
  sub fail {
      my $self = shift;
      my ($name, @diag) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Fail"
      );
  
      $e->add_info({tag => 'DIAG', debug => 1, details => $_}) for @diag;
      $self->{+HUB}->send($e);
      return $e;
  }
  
  sub fail_and_release {
      my $self = shift;
      my ($name, @diag) = @_;
  
      my $e = bless(
          {
              trace => bless({%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
              name  => $name,
          },
          "Test2::Event::Fail"
      );
  
      $e->add_info({tag => 'DIAG', debug => 1, details => $_}) for @diag;
      $self->{+HUB}->send($e);
      $self->release;
      return 0;
  }
  
  sub ok {
      my $self = shift;
      my ($pass, $name, $on_fail) = @_;
  
      my $hub = $self->{+HUB};
  
      my $e = bless {
          trace => bless( {%{$self->{+TRACE}}}, 'Test2::EventFacet::Trace'),
          pass  => $pass,
          name  => $name,
      }, 'Test2::Event::Ok';
      $e->init;
  
      $hub->send($e);
      return $e if $pass;
  
      $self->failure_diag($e);
  
      if ($on_fail && @$on_fail) {
          $self->diag($_) for @$on_fail;
      }
  
      return $e;
  }
  
  sub failure_diag {
      my $self = shift;
      my ($e) = @_;
  
      # Figure out the debug info, this is typically the file name and line
      # number, but can also be a custom message. If no trace object is provided
      # then we have nothing useful to display.
      my $name  = $e->name;
      my $trace = $e->trace;
      my $debug = $trace ? $trace->debug : "[No trace info available]";
  
      # Create the initial diagnostics. If the test has a name we put the debug
      # info on a second line, this behavior is inherited from Test::Builder.
      my $msg = defined($name)
          ? qq[Failed test '$name'\n$debug.\n]
          : qq[Failed test $debug.\n];
  
      $self->diag($msg);
  }
  
  sub skip {
      my $self = shift;
      my ($name, $reason, @extra) = @_;
      $self->send_event(
          'Skip',
          name => $name,
          reason => $reason,
          pass => 1,
          @extra,
      );
  }
  
  sub note {
      my $self = shift;
      my ($message) = @_;
      $self->send_event('Note', message => $message);
  }
  
  sub diag {
      my $self = shift;
      my ($message) = @_;
      my $hub = $self->{+HUB};
      $self->send_event(
          'Diag',
          message => $message,
      );
  }
  
  sub plan {
      my ($self, $max, $directive, $reason) = @_;
      $self->send_event('Plan', max => $max, directive => $directive, reason => $reason);
  }
  
  sub bail {
      my ($self, $reason) = @_;
      $self->send_event('Bail', reason => $reason);
  }
  
  sub _parse_event {
      my $self = shift;
      my $event = shift;
  
      my $pkg;
      if ($event =~ m/^\+(.*)/) {
          $pkg = $1;
      }
      else {
          $pkg = "Test2::Event::$event";
      }
  
      unless ($LOADED{$pkg}) {
          my $file = pkg_to_file($pkg);
          my ($ok, $err) = try { require $file };
          $self->throw("Could not load event module '$pkg': $err")
              unless $ok;
  
          $LOADED{$pkg} = $pkg;
      }
  
      confess "'$pkg' is not a subclass of 'Test2::Event'"
          unless $pkg->isa('Test2::Event');
  
      $LOADED{$event} = $pkg;
  
      return $pkg;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Context - Object to represent a testing context.
  
  =head1 DESCRIPTION
  
  The context object is the primary interface for authors of testing tools
  written with L<Test2>. The context object represents the context in
  which a test takes place (File and Line Number), and provides a quick way to
  generate events from that context. The context object also takes care of
  sending events to the correct L<Test2::Hub> instance.
  
  =head1 SYNOPSIS
  
  In general you will not be creating contexts directly. To obtain a context you
  should always use C<context()> which is exported by the L<Test2::API> module.
  
      use Test2::API qw/context/;
  
      sub my_ok {
          my ($bool, $name) = @_;
          my $ctx = context();
          $ctx->ok($bool, $name);
          $ctx->release; # You MUST do this!
          return $bool;
      }
  
  Context objects make it easy to wrap other tools that also use context. Once
  you grab a context, any tool you call before releasing your context will
  inherit it:
  
      sub wrapper {
          my ($bool, $name) = @_;
          my $ctx = context();
          $ctx->diag("wrapping my_ok");
  
          my $out = my_ok($bool, $name);
          $ctx->release; # You MUST do this!
          return $out;
      }
  
  =head1 CRITICAL DETAILS
  
  =over 4
  
  =item you MUST always use the context() sub from Test2::API
  
  Creating your own context via C<< Test2::API::Context->new() >> will almost never
  produce a desirable result. Use C<context()> which is exported by L<Test2::API>.
  
  There are a handful of cases where a tool author may want to create a new
  context by hand, which is why the C<new> method exists. Unless you really know
  what you are doing you should avoid this.
  
  =item You MUST always release the context when done with it
  
  Releasing the context tells the system you are done with it. This gives it a
  chance to run any necessary callbacks or cleanup tasks. If you forget to
  release the context it will try to detect the problem and warn you about it.
  
  =item You MUST NOT pass context objects around
  
  When you obtain a context object it is made specifically for your tool and any
  tools nested within. If you pass a context around you run the risk of polluting
  other tools with incorrect context information.
  
  If you are certain that you want a different tool to use the same context you
  may pass it a snapshot. C<< $ctx->snapshot >> will give you a shallow clone of
  the context that is safe to pass around or store.
  
  =item You MUST NOT store or cache a context for later
  
  As long as a context exists for a given hub, all tools that try to get a
  context will get the existing instance. If you try to store the context you
  will pollute other tools with incorrect context information.
  
  If you are certain that you want to save the context for later, you can use a
  snapshot. C<< $ctx->snapshot >> will give you a shallow clone of the context
  that is safe to pass around or store.
  
  C<context()> has some mechanisms to protect you if you do cause a context to
  persist beyond the scope in which it was obtained. In practice you should not
  rely on these protections, and they are fairly noisy with warnings.
  
  =item You SHOULD obtain your context as soon as possible in a given tool
  
  You never know what tools you call from within your own tool will need a
  context. Obtaining the context early ensures that nested tools can find the
  context you want them to find.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item $ctx->done_testing;
  
  Note that testing is finished. If no plan has been set this will generate a
  Plan event.
  
  =item $clone = $ctx->snapshot()
  
  This will return a shallow clone of the context. The shallow clone is safe to
  store for later.
  
  =item $ctx->release()
  
  This will release the context. This runs cleanup tasks, and several important
  hooks. It will also restore C<$!>, C<$?>, and C<$@> to what they were when the
  context was created.
  
  B<Note:> If a context is acquired more than once an internal refcount is kept.
  C<release()> decrements the ref count, none of the other actions of
  C<release()> will occur unless the refcount hits 0. This means only the last
  call to C<release()> will reset C<$?>, C<$!>, C<$@>,and run the cleanup tasks.
  
  =item $ctx->throw($message)
  
  This will throw an exception reporting to the file and line number of the
  context. This will also release the context for you.
  
  =item $ctx->alert($message)
  
  This will issue a warning from the file and line number of the context.
  
  =item $stack = $ctx->stack()
  
  This will return the L<Test2::API::Stack> instance the context used to find
  the current hub.
  
  =item $hub = $ctx->hub()
  
  This will return the L<Test2::Hub> instance the context recognizes as the
  current one to which all events should be sent.
  
  =item $dbg = $ctx->trace()
  
  This will return the L<Test2::EventFacet::Trace> instance used by the context.
  
  =item $ctx->do_in_context(\&code, @args);
  
  Sometimes you have a context that is not current, and you want things to use it
  as the current one. In these cases you can call
  C<< $ctx->do_in_context(sub { ... }) >>. The codeblock will be run, and
  anything inside of it that looks for a context will find the one on which the
  method was called.
  
  This B<DOES NOT> affect context on other hubs, only the hub used by the context
  will be affected.
  
      my $ctx = ...;
      $ctx->do_in_context(sub {
          my $ctx = context(); # returns the $ctx the sub is called on
      });
  
  B<Note:> The context will actually be cloned, the clone will be used instead of
  the original. This allows the thread id, process id, and error variables to be correct without
  modifying the original context.
  
  =item $ctx->restore_error_vars()
  
  This will set C<$!>, C<$?>, and C<$@> to what they were when the context was
  created. There is no localization or anything done here, calling this method
  will actually set these vars.
  
  =item $! = $ctx->errno()
  
  The (numeric) value of C<$!> when the context was created.
  
  =item $? = $ctx->child_error()
  
  The value of C<$?> when the context was created.
  
  =item $@ = $ctx->eval_error()
  
  The value of C<$@> when the context was created.
  
  =back
  
  =head2 EVENT PRODUCTION METHODS
  
  B<Which one do I use?>
  
  The C<pass*> and C<fail*> are optimal if they meet your situation, using one of
  them will always be the most optimal. That said they are optimal by eliminating
  many features.
  
  Method such as C<ok>, and C<note> are shortcuts for generating common 1-task
  events based on the old API, however they are forward compatible, and easy to
  use. If these meet your needs then go ahead and use them, but please check back
  often for alternatives that may be added.
  
  If you want to generate new style events, events that do many things at once,
  then you want the C<*ev2*> methods. These let you directly specify which facets
  you wish to use.
  
  =over 4
  
  =item $event = $ctx->pass()
  
  =item $event = $ctx->pass($name)
  
  This will send and return an L<Test2::Event::Pass> event. You may optionally
  provide a C<$name> for the assertion.
  
  The L<Test2::Event::Pass> is a specially crafted and optimized event, using
  this will help the performance of passing tests.
  
  =item $true = $ctx->pass_and_release()
  
  =item $true = $ctx->pass_and_release($name)
  
  This is a combination of C<pass()> and C<release()>. You can use this if you do
  not plan to do anything with the context after sending the event. This helps
  write more clear and compact code.
  
      sub shorthand {
          my ($bool, $name) = @_;
          my $ctx = context();
          return $ctx->pass_and_release($name) if $bool;
  
          ... Handle a failure ...
      }
  
      sub longform {
          my ($bool, $name) = @_;
          my $ctx = context();
  
          if ($bool) {
              $ctx->pass($name);
              $ctx->release;
              return 1;
          }
  
          ... Handle a failure ...
      }
  
  =item my $event = $ctx->fail()
  
  =item my $event = $ctx->fail($name)
  
  =item my $event = $ctx->fail($name, @diagnostics)
  
  This lets you send an L<Test2::Event::Fail> event. You may optionally provide a
  C<$name> and C<@diagnostics> messages.
  
  =item my $false = $ctx->fail_and_release()
  
  =item my $false = $ctx->fail_and_release($name)
  
  =item my $false = $ctx->fail_and_release($name, @diagnostics)
  
  This is a combination of C<fail()> and C<release()>. This can be used to write
  clearer and shorter code.
  
      sub shorthand {
          my ($bool, $name) = @_;
          my $ctx = context();
          return $ctx->fail_and_release($name) unless $bool;
  
          ... Handle a success ...
      }
  
      sub longform {
          my ($bool, $name) = @_;
          my $ctx = context();
  
          unless ($bool) {
              $ctx->pass($name);
              $ctx->release;
              return 1;
          }
  
          ... Handle a success ...
      }
  
  
  =item $event = $ctx->ok($bool, $name)
  
  =item $event = $ctx->ok($bool, $name, \@on_fail)
  
  B<NOTE:> Use of this method is discouraged in favor of C<pass()> and C<fail()>
  which produce L<Test2::Event::Pass> and L<Test2::Event::Fail> events. These
  newer event types are faster and less crufty.
  
  This will create an L<Test2::Event::Ok> object for you. If C<$bool> is false
  then an L<Test2::Event::Diag> event will be sent as well with details about the
  failure. If you do not want automatic diagnostics you should use the
  C<send_event()> method directly.
  
  The third argument C<\@on_fail>) is an optional set of diagnostics to be sent in
  the event of a test failure.
  
  =item $event = $ctx->note($message)
  
  Send an L<Test2::Event::Note>. This event prints a message to STDOUT.
  
  =item $event = $ctx->diag($message)
  
  Send an L<Test2::Event::Diag>. This event prints a message to STDERR.
  
  =item $event = $ctx->plan($max)
  
  =item $event = $ctx->plan(0, 'SKIP', $reason)
  
  This can be used to send an L<Test2::Event::Plan> event. This event
  usually takes either a number of tests you expect to run. Optionally you can
  set the expected count to 0 and give the 'SKIP' directive with a reason to
  cause all tests to be skipped.
  
  =item $event = $ctx->skip($name, $reason);
  
  Send an L<Test2::Event::Skip> event.
  
  =item $event = $ctx->bail($reason)
  
  This sends an L<Test2::Event::Bail> event. This event will completely
  terminate all testing.
  
  =item $event = $ctx->send_ev2(%facets)
  
  This lets you build and send a V2 event directly from facets. The event is
  returned after it is sent.
  
  This example sends a single assertion, a note (comment for stdout in
  Test::Builder talk) and sets the plan to 1.
  
      my $event = $ctx->send_event(
          plan   => {count => 1},
          assert => {pass  => 1, details => "A passing assert"},
          info => [{tag => 'NOTE', details => "This is a note"}],
      );
  
  =item $event = $ctx->build_e2(%facets)
  
  This is the same as C<send_ev2()>, except it builds and returns the event
  without sending it.
  
  =item $event = $ctx->send_ev2_and_release($Type, %parameters)
  
  This is a combination of C<send_ev2()> and C<release()>.
  
      sub shorthand {
          my $ctx = context();
          return $ctx->send_ev2_and_release(assert => {pass => 1, details => 'foo'});
      }
  
      sub longform {
          my $ctx = context();
          my $event = $ctx->send_ev2(assert => {pass => 1, details => 'foo'});
          $ctx->release;
          return $event;
      }
  
  =item $event = $ctx->send_event($Type, %parameters)
  
  B<It is better to use send_ev2() in new code.>
  
  This lets you build and send an event of any type. The C<$Type> argument should
  be the event package name with C<Test2::Event::> left off, or a fully
  qualified package name prefixed with a '+'. The event is returned after it is
  sent.
  
      my $event = $ctx->send_event('Ok', ...);
  
  or
  
      my $event = $ctx->send_event('+Test2::Event::Ok', ...);
  
  =item $event = $ctx->build_event($Type, %parameters)
  
  B<It is better to use build_ev2() in new code.>
  
  This is the same as C<send_event()>, except it builds and returns the event
  without sending it.
  
  =item $event = $ctx->send_event_and_release($Type, %parameters)
  
  B<It is better to use send_ev2_and_release() in new code.>
  
  This is a combination of C<send_event()> and C<release()>.
  
      sub shorthand {
          my $ctx = context();
          return $ctx->send_event_and_release(Pass => { name => 'foo' });
      }
  
      sub longform {
          my $ctx = context();
          my $event = $ctx->send_event(Pass => { name => 'foo' });
          $ctx->release;
          return $event;
      }
  
  =back
  
  =head1 HOOKS
  
  There are 2 types of hooks, init hooks, and release hooks. As the names
  suggest, these hooks are triggered when contexts are created or released.
  
  =head2 INIT HOOKS
  
  These are called whenever a context is initialized. That means when a new
  instance is created. These hooks are B<NOT> called every time something
  requests a context, just when a new one is created.
  
  =head3 GLOBAL
  
  This is how you add a global init callback. Global callbacks happen for every
  context for any hub or stack.
  
      Test2::API::test2_add_callback_context_init(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER HUB
  
  This is how you add an init callback for all contexts created for a given hub.
  These callbacks will not run for other hubs.
  
      $hub->add_context_init(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER CONTEXT
  
  This is how you specify an init hook that will only run if your call to
  C<context()> generates a new context. The callback will be ignored if
  C<context()> is returning an existing context.
  
      my $ctx = context(on_init => sub {
          my $ctx = shift;
          ...
      });
  
  =head2 RELEASE HOOKS
  
  These are called whenever a context is released. That means when the last
  reference to the instance is about to be destroyed. These hooks are B<NOT>
  called every time C<< $ctx->release >> is called.
  
  =head3 GLOBAL
  
  This is how you add a global release callback. Global callbacks happen for every
  context for any hub or stack.
  
      Test2::API::test2_add_callback_context_release(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER HUB
  
  This is how you add a release callback for all contexts created for a given
  hub. These callbacks will not run for other hubs.
  
      $hub->add_context_release(sub {
          my $ctx = shift;
          ...
      });
  
  =head3 PER CONTEXT
  
  This is how you add release callbacks directly to a context. The callback will
  B<ALWAYS> be added to the context that gets returned, it does not matter if a
  new one is generated, or if an existing one is returned.
  
      my $ctx = context(on_release => sub {
          my $ctx = shift;
          ...
      });
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_CONTEXT

$fatpacked{"Test2/API/Instance.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_INSTANCE';
  package Test2::API::Instance;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  our @CARP_NOT = qw/Test2::API Test2::API::Instance Test2::IPC::Driver Test2::Formatter/;
  use Carp qw/confess carp/;
  use Scalar::Util qw/reftype/;
  
  use Test2::Util qw/get_tid USE_THREADS CAN_FORK pkg_to_file try CAN_SIGSYS/;
  
  use Test2::EventFacet::Trace();
  use Test2::API::Stack();
  
  use Test2::Util::HashBase qw{
      _pid _tid
      no_wait
      finalized loaded
      ipc stack formatter
      contexts
  
      add_uuid_via
  
      -preload
  
      ipc_disabled
      ipc_shm_size
      ipc_shm_last
      ipc_shm_id
      ipc_polling
      ipc_drivers
      ipc_timeout
      formatters
  
      exit_callbacks
      post_load_callbacks
      context_acquire_callbacks
      context_init_callbacks
      context_release_callbacks
      pre_subtest_callbacks
  };
  
  sub DEFAULT_IPC_TIMEOUT() { 30 }
  
  sub pid { $_[0]->{+_PID} }
  sub tid { $_[0]->{+_TID} }
  
  # Wrap around the getters that should call _finalize.
  BEGIN {
      for my $finalizer (IPC, FORMATTER) {
          my $orig = __PACKAGE__->can($finalizer);
          my $new  = sub {
              my $self = shift;
              $self->_finalize unless $self->{+FINALIZED};
              $self->$orig;
          };
  
          no strict 'refs';
          no warnings 'redefine';
          *{$finalizer} = $new;
      }
  }
  
  sub has_ipc { !!$_[0]->{+IPC} }
  
  sub import {
      my $class = shift;
      return unless @_;
      my ($ref) = @_;
      $$ref = $class->new;
  }
  
  sub init { $_[0]->reset }
  
  sub start_preload {
      my $self = shift;
  
      confess "preload cannot be started, Test2::API has already been initialized"
          if $self->{+FINALIZED} || $self->{+LOADED};
  
      return $self->{+PRELOAD} = 1;
  }
  
  sub stop_preload {
      my $self = shift;
  
      return 0 unless $self->{+PRELOAD};
      $self->{+PRELOAD} = 0;
  
      $self->post_preload_reset();
  
      return 1;
  }
  
  sub post_preload_reset {
      my $self = shift;
  
      delete $self->{+_PID};
      delete $self->{+_TID};
  
      $self->{+ADD_UUID_VIA} = undef unless exists $self->{+ADD_UUID_VIA};
  
      $self->{+CONTEXTS} = {};
  
      $self->{+FORMATTERS} = [];
  
      $self->{+FINALIZED} = undef;
      $self->{+IPC}       = undef;
      $self->{+IPC_DISABLED} = $ENV{T2_NO_IPC} ? 1 : 0;
  
      $self->{+IPC_TIMEOUT} = DEFAULT_IPC_TIMEOUT() unless defined $self->{+IPC_TIMEOUT};
  
      $self->{+LOADED} = 0;
  
      $self->{+STACK} ||= Test2::API::Stack->new;
  }
  
  sub reset {
      my $self = shift;
  
      delete $self->{+_PID};
      delete $self->{+_TID};
  
      $self->{+ADD_UUID_VIA} = undef;
  
      $self->{+CONTEXTS} = {};
  
      $self->{+IPC_DRIVERS} = [];
      $self->{+IPC_POLLING} = undef;
  
      $self->{+FORMATTERS} = [];
      $self->{+FORMATTER}  = undef;
  
      $self->{+FINALIZED}    = undef;
      $self->{+IPC}          = undef;
      $self->{+IPC_DISABLED} = $ENV{T2_NO_IPC} ? 1 : 0;
  
      $self->{+IPC_TIMEOUT} = DEFAULT_IPC_TIMEOUT() unless defined $self->{+IPC_TIMEOUT};
  
      $self->{+NO_WAIT} = 0;
      $self->{+LOADED}  = 0;
  
      $self->{+EXIT_CALLBACKS}            = [];
      $self->{+POST_LOAD_CALLBACKS}       = [];
      $self->{+CONTEXT_ACQUIRE_CALLBACKS} = [];
      $self->{+CONTEXT_INIT_CALLBACKS}    = [];
      $self->{+CONTEXT_RELEASE_CALLBACKS} = [];
      $self->{+PRE_SUBTEST_CALLBACKS}     = [];
  
      $self->{+STACK} = Test2::API::Stack->new;
  }
  
  sub _finalize {
      my $self = shift;
      my ($caller) = @_;
      $caller ||= [caller(1)];
  
      confess "Attempt to initialize Test2::API during preload"
          if $self->{+PRELOAD};
  
      $self->{+FINALIZED} = $caller;
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      unless ($self->{+FORMATTER}) {
          my ($formatter, $source);
          if ($ENV{T2_FORMATTER}) {
              $source = "set by the 'T2_FORMATTER' environment variable";
  
              if ($ENV{T2_FORMATTER} =~ m/^(\+)?(.*)$/) {
                  $formatter = $1 ? $2 : "Test2::Formatter::$2"
              }
              else {
                  $formatter = '';
              }
          }
          elsif (@{$self->{+FORMATTERS}}) {
              ($formatter) = @{$self->{+FORMATTERS}};
              $source = "Most recently added";
          }
          else {
              $formatter = 'Test2::Formatter::TAP';
              $source    = 'default formatter';
          }
  
          unless (ref($formatter) || $formatter->can('write')) {
              my $file = pkg_to_file($formatter);
              my ($ok, $err) = try { require $file };
              unless ($ok) {
                  my $line   = "* COULD NOT LOAD FORMATTER '$formatter' ($source) *";
                  my $border = '*' x length($line);
                  die "\n\n  $border\n  $line\n  $border\n\n$err";
              }
          }
  
          $self->{+FORMATTER} = $formatter;
      }
  
      # Turn on IPC if threads are on, drivers are registered, or the Test2::IPC
      # module is loaded.
      return if $self->{+IPC_DISABLED};
      return unless USE_THREADS || $INC{'Test2/IPC.pm'} || @{$self->{+IPC_DRIVERS}};
  
      # Turn on polling by default, people expect it.
      $self->enable_ipc_polling;
  
      unless (@{$self->{+IPC_DRIVERS}}) {
          my ($ok, $error) = try { require Test2::IPC::Driver::Files };
          die $error unless $ok;
          push @{$self->{+IPC_DRIVERS}} => 'Test2::IPC::Driver::Files';
      }
  
      for my $driver (@{$self->{+IPC_DRIVERS}}) {
          next unless $driver->can('is_viable') && $driver->is_viable;
          $self->{+IPC} = $driver->new or next;
          $self->ipc_enable_shm if $self->{+IPC}->use_shm;
          return;
      }
  
      die "IPC has been requested, but no viable drivers were found. Aborting...\n";
  }
  
  sub formatter_set { $_[0]->{+FORMATTER} ? 1 : 0 }
  
  sub add_formatter {
      my $self = shift;
      my ($formatter) = @_;
      unshift @{$self->{+FORMATTERS}} => $formatter;
  
      return unless $self->{+FINALIZED};
  
      # Why is the @CARP_NOT entry not enough?
      local %Carp::Internal = %Carp::Internal;
      $Carp::Internal{'Test2::Formatter'} = 1;
  
      carp "Formatter $formatter loaded too late to be used as the global formatter";
  }
  
  sub add_context_acquire_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-acquire callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_ACQUIRE_CALLBACKS}} => $code;
  }
  
  sub add_context_init_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-init callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_INIT_CALLBACKS}} => $code;
  }
  
  sub add_context_release_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Context-release callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+CONTEXT_RELEASE_CALLBACKS}} => $code;
  }
  
  sub add_post_load_callback {
      my $self = shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Post-load callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+POST_LOAD_CALLBACKS}} => $code;
      $code->() if $self->{+LOADED};
  }
  
  sub add_pre_subtest_callback {
      my $self =  shift;
      my ($code) = @_;
  
      my $rtype = reftype($code) || "";
  
      confess "Pre-subtest callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+PRE_SUBTEST_CALLBACKS}} => $code;
  }
  
  sub load {
      my $self = shift;
      unless ($self->{+LOADED}) {
          confess "Attempt to initialize Test2::API during preload"
              if $self->{+PRELOAD};
  
          $self->{+_PID} = $$        unless defined $self->{+_PID};
          $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
          # This is for https://github.com/Test-More/test-more/issues/16
          # and https://rt.perl.org/Public/Bug/Display.html?id=127774
          # END blocks run in reverse order. This insures the END block is loaded
          # as late as possible. It will not solve all cases, but it helps.
          eval "END { Test2::API::test2_set_is_end() }; 1" or die $@;
  
          $self->{+LOADED} = 1;
          $_->() for @{$self->{+POST_LOAD_CALLBACKS}};
      }
      return $self->{+LOADED};
  }
  
  sub add_exit_callback {
      my $self = shift;
      my ($code) = @_;
      my $rtype = reftype($code) || "";
  
      confess "End callbacks must be coderefs"
          unless $code && $rtype eq 'CODE';
  
      push @{$self->{+EXIT_CALLBACKS}} => $code;
  }
  
  sub ipc_disable {
      my $self = shift;
  
      confess "Attempt to disable IPC after it has been initialized"
          if $self->{+IPC};
  
      $self->{+IPC_DISABLED} = 1;
  }
  
  sub add_ipc_driver {
      my $self = shift;
      my ($driver) = @_;
      unshift @{$self->{+IPC_DRIVERS}} => $driver;
  
      return unless $self->{+FINALIZED};
  
      # Why is the @CARP_NOT entry not enough?
      local %Carp::Internal = %Carp::Internal;
      $Carp::Internal{'Test2::IPC::Driver'} = 1;
  
      carp "IPC driver $driver loaded too late to be used as the global ipc driver";
  }
  
  sub enable_ipc_polling {
      my $self = shift;
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      $self->add_context_init_callback(
          # This is called every time a context is created, it needs to be fast.
          # $_[0] is a context object
          sub {
              return unless $self->{+IPC_POLLING};
              return $_[0]->{hub}->cull unless $self->{+IPC_SHM_ID};
  
              my $val;
              if(shmread($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE})) {
                  return if $val eq $self->{+IPC_SHM_LAST};
                  $self->{+IPC_SHM_LAST} = $val;
              }
              else {
                  warn "SHM Read error: $!\n";
              }
  
              $_[0]->{hub}->cull;
          }
      ) unless defined $self->ipc_polling;
  
      $self->set_ipc_polling(1);
  }
  
  sub ipc_enable_shm {
      my $self = shift;
  
      return 1 if defined $self->{+IPC_SHM_ID};
  
      $self->{+_PID} = $$        unless defined $self->{+_PID};
      $self->{+_TID} = get_tid() unless defined $self->{+_TID};
  
      my ($ok, $err) = try {
          # SysV IPC can be available but not enabled.
          #
          # In some systems (*BSD) accessing the SysV IPC APIs without
          # them being enabled can cause a SIGSYS.  We suppress the SIGSYS
          # and then get ENOSYS from the calls.
          local $SIG{SYS} = 'IGNORE' if CAN_SIGSYS;
  
          require IPC::SysV;
  
          my $ipc_key = IPC::SysV::IPC_PRIVATE();
          my $shm_size = $self->{+IPC}->can('shm_size') ? $self->{+IPC}->shm_size : 64;
          my $shm_id = shmget($ipc_key, $shm_size, 0666) or die "Could not get shm: $!";
  
          my $initial = 'a' x $shm_size;
          shmwrite($shm_id, $initial, 0, $shm_size) or die "Could not write to shm: $!";
          my $val;
          shmread($shm_id, $val, 0, $shm_size) or die "Could not read from shm: $!";
          die "Read SHM value does not match the initial value ('$val' vs '$initial')"
              unless $val eq $initial;
  
          $self->{+IPC_SHM_SIZE} = $shm_size;
          $self->{+IPC_SHM_ID}   = $shm_id;
          $self->{+IPC_SHM_LAST} = $initial;
      };
  
      return $ok;
  }
  
  sub ipc_free_shm {
      my $self = shift;
  
      my $id = delete $self->{+IPC_SHM_ID};
      return unless defined $id;
  
      shmctl($id, IPC::SysV::IPC_RMID(), 0);
  }
  
  sub get_ipc_pending {
      my $self = shift;
      return -1 unless defined $self->{+IPC_SHM_ID};
      my $val;
      shmread($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE}) or return -1;
      return 0 if $val eq $self->{+IPC_SHM_LAST};
      $self->{+IPC_SHM_LAST} = $val;
      return 1;
  }
  
  sub set_ipc_pending {
      my $self = shift;
  
      return undef unless defined $self->{+IPC_SHM_ID};
  
      my ($val) = @_;
  
      confess "value is required for set_ipc_pending"
          unless $val;
  
      shmwrite($self->{+IPC_SHM_ID}, $val, 0, $self->{+IPC_SHM_SIZE});
  }
  
  sub disable_ipc_polling {
      my $self = shift;
      return unless defined $self->{+IPC_POLLING};
      $self->{+IPC_POLLING} = 0;
  }
  
  sub _ipc_wait {
      my ($timeout) = @_;
      my $fail = 0;
  
      $timeout = DEFAULT_IPC_TIMEOUT() unless defined $timeout;
  
      my $ok = eval {
          if (CAN_FORK) {
              local $SIG{ALRM} = sub { die "Timeout waiting on child processes" };
              alarm $timeout;
  
              while (1) {
                  my $pid = CORE::wait();
                  my $err = $?;
                  last if $pid == -1;
                  next unless $err;
                  $fail++;
  
                  my $sig = $err & 127;
                  my $exit = $err >> 8;
                  warn "Process $pid did not exit cleanly (wstat: $err, exit: $exit, sig: $sig)\n";
              }
  
              alarm 0;
          }
  
          if (USE_THREADS) {
              my $start = time;
  
              while (1) {
                  last unless threads->list();
                  die "Timeout waiting on child thread" if time - $start >= $timeout;
                  sleep 1;
                  for my $t (threads->list) {
                      # threads older than 1.34 do not have this :-(
                      next if $t->can('is_joinable') && !$t->is_joinable;
                      $t->join;
                      # In older threads we cannot check if a thread had an error unless
                      # we control it and its return.
                      my $err = $t->can('error') ? $t->error : undef;
                      next unless $err;
                      my $tid = $t->tid();
                      $fail++;
                      chomp($err);
                      warn "Thread $tid did not end cleanly: $err\n";
                  }
              }
          }
  
          1;
      };
      my $error = $@;
  
      return 0 if $ok && !$fail;
      warn $error unless $ok;
      return 255;
  }
  
  sub DESTROY {
      my $self = shift;
  
      return if $self->{+PRELOAD};
  
      return unless defined($self->{+_PID}) && $self->{+_PID} == $$;
      return unless defined($self->{+_TID}) && $self->{+_TID} == get_tid();
  
      shmctl($self->{+IPC_SHM_ID}, IPC::SysV::IPC_RMID(), 0)
          if defined $self->{+IPC_SHM_ID};
  }
  
  sub set_exit {
      my $self = shift;
  
      return if $self->{+PRELOAD};
  
      my $exit     = $?;
      my $new_exit = $exit;
  
      if ($INC{'Test/Builder.pm'} && $Test::Builder::VERSION ne $Test2::API::VERSION) {
          print STDERR <<"        EOT";
  
  ********************************************************************************
  *                                                                              *
  *            Test::Builder -- Test2::API version mismatch detected             *
  *                                                                              *
  ********************************************************************************
     Test2::API Version: $Test2::API::VERSION
  Test::Builder Version: $Test::Builder::VERSION
  
  This is not a supported configuration, you will have problems.
  
          EOT
      }
  
      for my $ctx (values %{$self->{+CONTEXTS}}) {
          next unless $ctx;
  
          next if $ctx->_aborted && ${$ctx->_aborted};
  
          # Only worry about contexts in this PID
          my $trace = $ctx->trace || next;
          next unless $trace->pid && $trace->pid == $$;
  
          # Do not worry about contexts that have no hub
          my $hub = $ctx->hub  || next;
  
          # Do not worry if the state came to a sudden end.
          next if $hub->bailed_out;
          next if defined $hub->skip_reason;
  
          # now we worry
          $trace->alert("context object was never released! This means a testing tool is behaving very badly");
  
          $exit     = 255;
          $new_exit = 255;
      }
  
      if (!defined($self->{+_PID}) or !defined($self->{+_TID}) or $self->{+_PID} != $$ or $self->{+_TID} != get_tid()) {
          $? = $exit;
          return;
      }
  
      my @hubs = $self->{+STACK} ? $self->{+STACK}->all : ();
  
      if (@hubs and $self->{+IPC} and !$self->{+NO_WAIT}) {
          local $?;
          my %seen;
          for my $hub (reverse @hubs) {
              my $ipc = $hub->ipc or next;
              next if $seen{$ipc}++;
              $ipc->waiting();
          }
  
          my $ipc_exit = _ipc_wait($self->{+IPC_TIMEOUT});
          $new_exit ||= $ipc_exit;
      }
  
      # None of this is necessary if we never got a root hub
      if(my $root = shift @hubs) {
          my $trace = Test2::EventFacet::Trace->new(
              frame  => [__PACKAGE__, __FILE__, 0, __PACKAGE__ . '::END'],
              detail => __PACKAGE__ . ' END Block finalization',
          );
          my $ctx = Test2::API::Context->new(
              trace => $trace,
              hub   => $root,
          );
  
          if (@hubs) {
              $ctx->diag("Test ended with extra hubs on the stack!");
              $new_exit  = 255;
          }
  
          unless ($root->no_ending) {
              local $?;
              $root->finalize($trace) unless $root->ended;
              $_->($ctx, $exit, \$new_exit) for @{$self->{+EXIT_CALLBACKS}};
              $new_exit ||= $root->failed;
              $new_exit ||= 255 unless $root->is_passing;
          }
      }
  
      $new_exit = 255 if $new_exit > 255;
  
      if ($new_exit && eval { require Test2::API::Breakage; 1 }) {
          my @warn = Test2::API::Breakage->report();
  
          if (@warn) {
              print STDERR "\nYou have loaded versions of test modules known to have problems with Test2.\nThis could explain some test failures.\n";
              print STDERR "$_\n" for @warn;
              print STDERR "\n";
          }
      }
  
      $? = $new_exit;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Instance - Object used by Test2::API under the hood
  
  =head1 DESCRIPTION
  
  This object encapsulates the global shared state tracked by
  L<Test2>. A single global instance of this package is stored (and
  obscured) by the L<Test2::API> package.
  
  There is no reason to directly use this package. This package is documented for
  completeness. This package can change, or go away completely at any time.
  Directly using, or monkeypatching this package is not supported in any way
  shape or form.
  
  =head1 SYNOPSIS
  
      use Test2::API::Instance;
  
      my $obj = Test2::API::Instance->new;
  
  =over 4
  
  =item $pid = $obj->pid
  
  PID of this instance.
  
  =item $obj->tid
  
  Thread ID of this instance.
  
  =item $obj->reset()
  
  Reset the object to defaults.
  
  =item $obj->load()
  
  Set the internal state to loaded, and run and stored post-load callbacks.
  
  =item $bool = $obj->loaded
  
  Check if the state is set to loaded.
  
  =item $arrayref = $obj->post_load_callbacks
  
  Get the post-load callbacks.
  
  =item $obj->add_post_load_callback(sub { ... })
  
  Add a post-load callback. If C<load()> has already been called then the callback will
  be immediately executed. If C<load()> has not been called then the callback will be
  stored and executed later when C<load()> is called.
  
  =item $hashref = $obj->contexts()
  
  Get a hashref of all active contexts keyed by hub id.
  
  =item $arrayref = $obj->context_acquire_callbacks
  
  Get all context acquire callbacks.
  
  =item $arrayref = $obj->context_init_callbacks
  
  Get all context init callbacks.
  
  =item $arrayref = $obj->context_release_callbacks
  
  Get all context release callbacks.
  
  =item $arrayref = $obj->pre_subtest_callbacks
  
  Get all pre-subtest callbacks.
  
  =item $obj->add_context_init_callback(sub { ... })
  
  Add a context init callback. Subs are called every time a context is created. Subs
  get the newly created context as their only argument.
  
  =item $obj->add_context_release_callback(sub { ... })
  
  Add a context release callback. Subs are called every time a context is released. Subs
  get the released context as their only argument. These callbacks should not
  call release on the context.
  
  =item $obj->add_pre_subtest_callback(sub { ... })
  
  Add a pre-subtest callback. Subs are called every time a subtest is
  going to be run. Subs get the subtest name, coderef, and any
  arguments.
  
  =item $obj->set_exit()
  
  This is intended to be called in an C<END { ... }> block. This will look at
  test state and set $?. This will also call any end callbacks, and wait on child
  processes/threads.
  
  =item $obj->ipc_enable_shm()
  
  Turn on SHM for IPC (if possible)
  
  =item $shm_id = $obj->ipc_shm_id()
  
  If SHM is enabled for IPC this will be the shm_id for it.
  
  =item $shm_size = $obj->ipc_shm_size()
  
  If SHM is enabled for IPC this will be the size of it.
  
  =item $shm_last_val = $obj->ipc_shm_last()
  
  If SHM is enabled for IPC this will return the last SHM value seen.
  
  =item $obj->set_ipc_pending($val)
  
  use the IPC SHM to tell other processes and threads there is a pending event.
  C<$val> should be a unique value no other thread/process will generate.
  
  B<Note:> This will also make the current process see a pending event. It does
  not set C<ipc_shm_last()>, this is important because doing so could hide a
  previous change.
  
  =item $pending = $obj->get_ipc_pending()
  
  This returns -1 if SHM is not enabled for IPC.
  
  This returns 0 if the SHM value matches the last known value, which means there
  are no pending events.
  
  This returns 1 if the SHM value has changed, which means there are probably
  pending events.
  
  When 1 is returned this will set C<< $obj->ipc_shm_last() >>.
  
  =item $timeout = $obj->ipc_timeout;
  
  =item $obj->set_ipc_timeout($timeout);
  
  How long to wait for child processes and threads before aborting.
  
  =item $drivers = $obj->ipc_drivers
  
  Get the list of IPC drivers.
  
  =item $obj->add_ipc_driver($DRIVER_CLASS)
  
  Add an IPC driver to the list. The most recently added IPC driver will become
  the global one during initialization. If a driver is added after initialization
  has occurred a warning will be generated:
  
      "IPC driver $driver loaded too late to be used as the global ipc driver"
  
  =item $bool = $obj->ipc_polling
  
  Check if polling is enabled.
  
  =item $obj->enable_ipc_polling
  
  Turn on polling. This will cull events from other processes and threads every
  time a context is created.
  
  =item $obj->disable_ipc_polling
  
  Turn off IPC polling.
  
  =item $bool = $obj->no_wait
  
  =item $bool = $obj->set_no_wait($bool)
  
  Get/Set no_wait. This option is used to turn off process/thread waiting at exit.
  
  =item $arrayref = $obj->exit_callbacks
  
  Get the exit callbacks.
  
  =item $obj->add_exit_callback(sub { ... })
  
  Add an exit callback. This callback will be called by C<set_exit()>.
  
  =item $bool = $obj->finalized
  
  Check if the object is finalized. Finalization happens when either C<ipc()>,
  C<stack()>, or C<format()> are called on the object. Once finalization happens
  these fields are considered unchangeable (not enforced here, enforced by
  L<Test2>).
  
  =item $ipc = $obj->ipc
  
  Get the one true IPC instance.
  
  =item $obj->ipc_disable
  
  Turn IPC off
  
  =item $bool = $obj->ipc_disabled
  
  Check if IPC is disabled
  
  =item $stack = $obj->stack
  
  Get the one true hub stack.
  
  =item $formatter = $obj->formatter
  
  Get the global formatter. By default this is the C<'Test2::Formatter::TAP'>
  package. This could be any package that implements the C<write()> method. This
  can also be an instantiated object.
  
  =item $bool = $obj->formatter_set()
  
  Check if a formatter has been set.
  
  =item $obj->add_formatter($class)
  
  =item $obj->add_formatter($obj)
  
  Add a formatter. The most recently added formatter will become the global one
  during initialization. If a formatter is added after initialization has occurred
  a warning will be generated:
  
      "Formatter $formatter loaded too late to be used as the global formatter"
  
  =item $obj->set_add_uuid_via(sub { ... })
  
  =item $sub = $obj->add_uuid_via()
  
  This allows you to provide a UUID generator. If provided UUIDs will be attached
  to all events, hubs, and contexts. This is useful for storing, tracking, and
  linking these objects.
  
  The sub you provide should always return a unique identifier. Most things will
  expect a proper UUID string, however nothing in Test2::API enforces this.
  
  The sub will receive exactly 1 argument, the type of thing being tagged
  'context', 'hub', or 'event'. In the future additional things may be tagged, in
  which case new strings will be passed in. These are purely informative, you can
  (and usually should) ignore them.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_INSTANCE

$fatpacked{"Test2/API/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_API_STACK';
  package Test2::API::Stack;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::Hub();
  
  use Carp qw/confess/;
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub new_hub {
      my $self = shift;
      my %params = @_;
  
      my $class = delete $params{class} || 'Test2::Hub';
  
      my $hub = $class->new(%params);
  
      if (@$self) {
          $hub->inherit($self->[-1], %params);
      }
      else {
          require Test2::API;
          $hub->format(Test2::API::test2_formatter()->new_root)
              unless $hub->format || exists($params{formatter});
  
          my $ipc = Test2::API::test2_ipc();
          if ($ipc && !$hub->ipc && !exists($params{ipc})) {
              $hub->set_ipc($ipc);
              $ipc->add_hub($hub->hid);
          }
      }
  
      push @$self => $hub;
  
      $hub;
  }
  
  sub top {
      my $self = shift;
      return $self->new_hub unless @$self;
      return $self->[-1];
  }
  
  sub peek {
      my $self = shift;
      return @$self ? $self->[-1] : undef;
  }
  
  sub cull {
      my $self = shift;
      $_->cull for reverse @$self;
  }
  
  sub all {
      my $self = shift;
      return @$self;
  }
  
  sub clear {
      my $self = shift;
      @$self = ();
  }
  
  # Do these last without keywords in order to prevent them from getting used
  # when we want the real push/pop.
  
  {
      no warnings 'once';
  
      *push = sub {
          my $self = shift;
          my ($hub) = @_;
          $hub->inherit($self->[-1]) if @$self;
          push @$self => $hub;
      };
  
      *pop = sub {
          my $self = shift;
          my ($hub) = @_;
          confess "No hubs on the stack"
              unless @$self;
          confess "You cannot pop the root hub"
              if 1 == @$self;
          confess "Hub stack mismatch, attempted to pop incorrect hub"
              unless $self->[-1] == $hub;
          pop @$self;
      };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::API::Stack - Object to manage a stack of L<Test2::Hub>
  instances.
  
  =head1 ***INTERNALS NOTE***
  
  B<The internals of this package are subject to change at any time!> The public
  methods provided will not change in backwards incompatible ways, but the
  underlying implementation details might. B<Do not break encapsulation here!>
  
  =head1 DESCRIPTION
  
  This module is used to represent and manage a stack of L<Test2::Hub>
  objects. Hubs are usually in a stack so that you can push a new hub into place
  that can intercept and handle events differently than the primary hub.
  
  =head1 SYNOPSIS
  
      my $stack = Test2::API::Stack->new;
      my $hub = $stack->top;
  
  =head1 METHODS
  
  =over 4
  
  =item $stack = Test2::API::Stack->new()
  
  This will create a new empty stack instance. All arguments are ignored.
  
  =item $hub = $stack->new_hub()
  
  =item $hub = $stack->new_hub(%params)
  
  =item $hub = $stack->new_hub(%params, class => $class)
  
  This will generate a new hub and push it to the top of the stack. Optionally
  you can provide arguments that will be passed into the constructor for the
  L<Test2::Hub> object.
  
  If you specify the C<< 'class' => $class >> argument, the new hub will be an
  instance of the specified class.
  
  Unless your parameters specify C<'formatter'> or C<'ipc'> arguments, the
  formatter and IPC instance will be inherited from the current top hub. You can
  set the parameters to C<undef> to avoid having a formatter or IPC instance.
  
  If there is no top hub, and you do not ask to leave IPC and formatter undef,
  then a new formatter will be created, and the IPC instance from
  L<Test2::API> will be used.
  
  =item $hub = $stack->top()
  
  This will return the top hub from the stack. If there is no top hub yet this
  will create it.
  
  =item $hub = $stack->peek()
  
  This will return the top hub from the stack. If there is no top hub yet this
  will return undef.
  
  =item $stack->cull
  
  This will call C<< $hub->cull >> on all hubs in the stack.
  
  =item @hubs = $stack->all
  
  This will return all the hubs in the stack as a list.
  
  =item $stack->clear
  
  This will completely remove all hubs from the stack. Normally you do not want
  to do this, but there are a few valid reasons for it.
  
  =item $stack->push($hub)
  
  This will push the new hub onto the stack.
  
  =item $stack->pop($hub)
  
  This will pop a hub from the stack, if the hub at the top of the stack does not
  match the hub you expect (passed in as an argument) it will throw an exception.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_API_STACK

$fatpacked{"Test2/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT';
  package Test2::Event;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Scalar::Util qw/blessed reftype/;
  use Carp qw/croak/;
  
  use Test2::Util::HashBase qw/trace -amnesty uuid -_eid -hubs/;
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util qw/pkg_to_file gen_uid/;
  
  use Test2::EventFacet::About();
  use Test2::EventFacet::Amnesty();
  use Test2::EventFacet::Assert();
  use Test2::EventFacet::Control();
  use Test2::EventFacet::Error();
  use Test2::EventFacet::Info();
  use Test2::EventFacet::Meta();
  use Test2::EventFacet::Parent();
  use Test2::EventFacet::Plan();
  use Test2::EventFacet::Trace();
  use Test2::EventFacet::Hub();
  
  # Legacy tools will expect this to be loaded now
  require Test2::Util::Trace;
  
  my %LOADED_FACETS = (
      'about'   => 'Test2::EventFacet::About',
      'amnesty' => 'Test2::EventFacet::Amnesty',
      'assert'  => 'Test2::EventFacet::Assert',
      'control' => 'Test2::EventFacet::Control',
      'errors'  => 'Test2::EventFacet::Error',
      'info'    => 'Test2::EventFacet::Info',
      'meta'    => 'Test2::EventFacet::Meta',
      'parent'  => 'Test2::EventFacet::Parent',
      'plan'    => 'Test2::EventFacet::Plan',
      'trace'   => 'Test2::EventFacet::Trace',
      'hubs'    => 'Test2::EventFacet::Hub',
  );
  
  sub FACET_TYPES { sort values %LOADED_FACETS }
  
  sub load_facet {
      my $class = shift;
      my ($facet) = @_;
  
      return $LOADED_FACETS{$facet} if exists $LOADED_FACETS{$facet};
  
      my @check = ($facet);
      if ('s' eq substr($facet, -1, 1)) {
          push @check => substr($facet, 0, -1);
      }
      else {
          push @check => $facet . 's';
      }
  
      my $found;
      for my $check (@check) {
          my $mod  = "Test2::EventFacet::" . ucfirst($facet);
          my $file = pkg_to_file($mod);
          next unless eval { require $file; 1 };
          $found = $mod;
          last;
      }
  
      return undef unless $found;
      $LOADED_FACETS{$facet} = $found;
  }
  
  sub causes_fail      { 0 }
  sub increments_count { 0 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  
  sub callback { }
  
  sub terminate { () }
  sub global    { () }
  sub sets_plan { () }
  
  sub summary { ref($_[0]) }
  
  sub related {
      my $self = shift;
      my ($event) = @_;
  
      my $tracea = $self->trace  or return undef;
      my $traceb = $event->trace or return undef;
  
      my $uuida = $tracea->uuid;
      my $uuidb = $traceb->uuid;
      if ($uuida && $uuidb) {
          return 1 if $uuida eq $uuidb;
          return 0;
      }
  
      my $siga = $tracea->signature or return undef;
      my $sigb = $traceb->signature or return undef;
  
      return 1 if $siga eq $sigb;
      return 0;
  }
  
  sub add_hub {
      my $self = shift;
      unshift @{$self->{+HUBS}} => @_;
  }
  
  sub add_amnesty {
      my $self = shift;
  
      for my $am (@_) {
          $am = {%$am} if ref($am) ne 'ARRAY';
          $am = Test2::EventFacet::Amnesty->new($am);
  
          push @{$self->{+AMNESTY}} => $am;
      }
  }
  
  sub eid { $_[0]->{+_EID} ||= gen_uid() }
  
  sub common_facet_data {
      my $self = shift;
  
      my %out;
  
      $out{about} = {package => ref($self) || undef};
      if (my $uuid = $self->uuid) {
          $out{about}->{uuid} = $uuid;
      }
  
      $out{about}->{eid} = $self->{+_EID} || $self->eid;
  
      if (my $trace = $self->trace) {
          $out{trace} = { %$trace };
      }
  
      if (my $hubs = $self->hubs) {
          $out{hubs} = $hubs;
      }
  
      $out{amnesty} = [map {{ %{$_} }} @{$self->{+AMNESTY}}]
          if $self->{+AMNESTY};
  
      if (my $meta = $self->meta_facet_data) {
          $out{meta} = $meta;
      }
  
      return \%out;
  }
  
  sub meta_facet_data {
      my $self = shift;
  
      my $key = Test2::Util::ExternalMeta::META_KEY();
  
      my $hash = $self->{$key} or return undef;
      return {%$hash};
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details}    = $self->summary    || undef;
      $out->{about}->{no_display} = $self->no_display || undef;
  
      # Might be undef, we want to preserve that
      my $terminate = $self->terminate;
      $out->{control} = {
          global    => $self->global    || 0,
          terminate => $terminate,
          has_callback => $self->can('callback') == \&callback ? 0 : 1,
      };
  
      $out->{assert} = {
          no_debug => 1,                     # Legacy behavior
          pass     => $self->causes_fail ? 0 : 1,
          details  => $self->summary,
      } if $self->increments_count;
  
      $out->{parent} = {hid => $self->subtest_id} if $self->subtest_id;
  
      if (my @plan = $self->sets_plan) {
          $out->{plan} = {};
  
          $out->{plan}->{count}   = $plan[0] if defined $plan[0];
          $out->{plan}->{details} = $plan[2] if defined $plan[2];
  
          if ($plan[1]) {
              $out->{plan}->{skip} = 1 if $plan[1] eq 'SKIP';
              $out->{plan}->{none} = 1 if $plan[1] eq 'NO PLAN';
          }
  
          $out->{control}->{terminate} ||= 0 if $out->{plan}->{skip};
      }
  
      if ($self->causes_fail && !$out->{assert}) {
          $out->{errors} = [
              {
                  tag     => 'FAIL',
                  fail    => 1,
                  details => $self->summary,
              }
          ];
      }
  
      my %IGNORE = (trace => 1, about => 1, control => 1);
      my $do_info = !grep { !$IGNORE{$_} } keys %$out;
  
      if ($do_info && !$self->no_display && $self->diagnostics) {
          $out->{info} = [
              {
                  tag     => 'DIAG',
                  debug   => 1,
                  details => $self->summary,
              }
          ];
      }
  
      return $out;
  }
  
  sub facets {
      my $self = shift;
      my %out;
  
      my $data = $self->facet_data;
      my @errors = $self->validate_facet_data($data);
      die join "\n" => @errors if @errors;
  
      for my $facet (keys %$data) {
          my $class = $self->load_facet($facet);
          my $val = $data->{$facet};
  
          unless($class) {
              $out{$facet} = $val;
              next;
          }
  
          my $is_list = reftype($val) eq 'ARRAY' ? 1 : 0;
          if ($is_list) {
              $out{$facet} = [map { $class->new($_) } @$val];
          }
          else {
              $out{$facet} = $class->new($val);
          }
      }
  
      return \%out;
  }
  
  sub validate_facet_data {
      my $class_or_self = shift;
      my ($f, %params);
  
      $f = shift if @_ && (reftype($_[0]) || '') eq 'HASH';
      %params = @_;
  
      $f ||= $class_or_self->facet_data if blessed($class_or_self);
      croak "No facet data" unless $f;
  
      my @errors;
  
      for my $k (sort keys %$f) {
          my $fclass = $class_or_self->load_facet($k);
  
          push @errors => "Could not find a facet class for facet '$k'"
              if $params{require_facet_class} && !$fclass;
  
          next unless $fclass;
  
          my $v = $f->{$k};
          next unless defined($v); # undef is always fine
  
          my $is_list = $fclass->is_list();
          my $got_list = reftype($v) eq 'ARRAY' ? 1 : 0;
  
          push @errors => "Facet '$k' should be a list, but got a single item ($v)"
              if $is_list && !$got_list;
  
          push @errors => "Facet '$k' should not be a list, but got a a list ($v)"
              if $got_list && !$is_list;
      }
  
      return @errors;
  }
  
  sub nested {
      my $self = shift;
  
      Carp::cluck("Use of Test2::Event->nested() is deprecated, use Test2::Event->trace->nested instead")
          if $ENV{AUTHOR_TESTING};
  
      if (my $hubs = $self->{+HUBS}) {
          return $hubs->[0]->{nested} if @$hubs;
      }
  
      my $trace = $self->{+TRACE} or return undef;
      return $trace->{nested};
  }
  
  sub in_subtest {
      my $self = shift;
  
      Carp::cluck("Use of Test2::Event->in_subtest() is deprecated, use Test2::Event->trace->hid instead")
          if $ENV{AUTHOR_TESTING};
  
      my $hubs = $self->{+HUBS};
      if ($hubs && @$hubs) {
          return undef unless $hubs->[0]->{nested};
          return $hubs->[0]->{hid}
      }
  
      my $trace = $self->{+TRACE} or return undef;
      return undef unless $trace->{nested};
      return $trace->{hid};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event - Base class for events
  
  =head1 DESCRIPTION
  
  Base class for all event objects that get passed through
  L<Test2>.
  
  =head1 SYNOPSIS
  
      package Test2::Event::MyEvent;
      use strict;
      use warnings;
  
      # This will make our class an event subclass (required)
      use base 'Test2::Event';
  
      # Add some accessors (optional)
      # You are not obligated to use HashBase, you can use any object tool you
      # want, or roll your own accessors.
      use Test2::Util::HashBase qw/foo bar baz/;
  
      # Use this if you want the legacy API to be written for you, for this to
      # work you will need to implement a facet_data() method.
      use Test2::Util::Facets2Legacy;
  
      # Chance to initialize some defaults
      sub init {
          my $self = shift;
          # no other args in @_
  
          $self->set_foo('xxx') unless defined $self->foo;
  
          ...
      }
  
      # This is the new way for events to convey data to the Test2 system
      sub facet_data {
          my $self = shift;
  
          # Get common facets such as 'about', 'trace' 'amnesty', and 'meta'
          my $facet_data = $self->common_facet_data();
  
          # Are you making an assertion?
          $facet_data->{assert} = {pass => 1, details => 'my assertion'};
          ...
  
          return $facet_data;
      }
  
      1;
  
  =head1 METHODS
  
  =head2 GENERAL
  
  =over 4
  
  =item $trace = $e->trace
  
  Get a snapshot of the L<Test2::EventFacet::Trace> as it was when this event was
  generated
  
  =item $bool_or_undef = $e->related($e2)
  
  Check if 2 events are related. In this case related means their traces share a
  signature meaning they were created with the same context (or at the very least
  by contexts which share an id, which is the same thing unless someone is doing
  something very bad).
  
  This can be used to reliably link multiple events created by the same tool. For
  instance a failing test like C<ok(0, "fail"> will generate 2 events, one being
  a L<Test2::Event::Ok>, the other being a L<Test2::Event::Diag>, both of these
  events are related having been created under the same context and by the same
  initial tool (though multiple tools may have been nested under the initial
  one).
  
  This will return C<undef> if the relationship cannot be checked, which happens
  if either event has an incomplete or missing trace. This will return C<0> if
  the traces are complete, but do not match. C<1> will be returned if there is a
  match.
  
  =item $e->add_amnesty({tag => $TAG, details => $DETAILS});
  
  This can be used to add amnesty to this event. Amnesty only effects failing
  assertions in most cases, but some formatters may display them for passing
  assertions, or even non-assertions as well.
  
  Amnesty will prevent a failed assertion from causing the overall test to fail.
  In other words it marks a failure as expected and allowed.
  
  B<Note:> This is how 'TODO' is implemented under the hood. TODO is essentially
  amnesty with the 'TODO' tag. The details are the reason for the TODO.
  
  =item $uuid = $e->uuid
  
  If UUID tagging is enabled (See L<Test::API>) then any event that has made its
  way through a hub will be tagged with a UUID. A newly created event will not
  yet be tagged in most cases.
  
  =item $class = $e->load_facet($name)
  
  This method is used to load a facet by name (or key). It will attempt to load
  the facet class, if it succeeds it will return the class it loaded. If it fails
  it will return C<undef>. This caches the result at the class level so that
  future calls will be faster.
  
  The C<$name> variable should be the key used to access the facet in a facets
  hashref. For instance the assertion facet has the key 'assert', the information
  facet has the 'info' key, and the error facet has the key 'errors'. You may
  include or omit the 's' at the end of the name, the method is smart enough to
  try both the 's' and no-'s' forms, it will check what you provided first, and
  if that is not found it will add or strip the 's and try again.
  
  =item @classes = $e->FACET_TYPES()
  
  =item @classes = Test2::Event->FACET_TYPES()
  
  This returns a list of all facets that have been loaded using the
  C<load_facet()> method. This will not return any classes that have not been
  loaded, or have been loaded directly without a call to C<load_facet()>.
  
  B<Note:> The core facet types are automatically loaded and populated in this
  list.
  
  =back
  
  =head2 NEW API
  
  =over 4
  
  =item $hashref = $e->common_facet_data();
  
  This can be used by subclasses to generate a starting facet data hashref. This
  will populate the hashref with the trace, meta, amnesty, and about facets.
  These facets are nearly always produced the same way for all events.
  
  =item $hashref = $e->facet_data()
  
  If you do not override this then the default implementation will attempt to
  generate facets from the legacy API. This generation is limited only to what
  the legacy API can provide. It is recommended that you override this method and
  write out explicit facet data.
  
  =item $hashref = $e->facets()
  
  This takes the hashref from C<facet_data()> and blesses each facet into the
  proper C<Test2::EventFacet::*> subclass. If no class can be found for any given
  facet it will be passed along unchanged.
  
  =item @errors = $e->validate_facet_data();
  
  =item @errors = $e->validate_facet_data(%params);
  
  =item @errors = $e->validate_facet_data(\%facets, %params);
  
  =item @errors = Test2::Event->validate_facet_data(%params);
  
  =item @errors = Test2::Event->validate_facet_data(\%facets, %params);
  
  This method will validate facet data and return a list of errors. If no errors
  are found this will return an empty list.
  
  This can be called as an object method with no arguments, in which case the
  C<facet_data()> method will be called to get the facet data to be validated.
  
  When used as an object method the C<\%facet_data> argument may be omitted.
  
  When used as a class method the C<\%facet_data> argument is required.
  
  Remaining arguments will be slurped into a C<%params> hash.
  
  Currently only 1 parameter is defined:
  
  =over 4
  
  =item require_facet_class => $BOOL
  
  When set to true (default is false) this will reject any facets where a facet
  class cannot be found. Normally facets without classes are assumed to be custom
  and are ignored.
  
  =back
  
  =back
  
  =head3 WHAT ARE FACETS?
  
  Facets are how events convey their purpose to the Test2 internals and
  formatters. An event without facets will have no intentional effect on the
  overall test state, and will not be displayed at all by most formatters, except
  perhaps to say that an event of an unknown type was seen.
  
  Facets are produced by the C<facet_data()> subroutine, which you should
  nearly-always override. C<facet_data()> is expected to return a hashref where
  each key is the facet type, and the value is either a hashref with the data for
  that facet, or an array of hashref's. Some facets must be defined as single
  hashrefs, some must be defined as an array of hashrefs, No facets allow both.
  
  C<facet_data()> B<MUST NOT> bless the data it returns, the main hashref, and
  nested facet hashref's B<MUST> be bare, though items contained within each
  facet may be blessed. The data returned by this method B<should> also be copies
  of the internal data in order to prevent accidental state modification.
  
  C<facets()> takes the data from C<facet_data()> and blesses it into the
  C<Test2::EventFacet::*> packages. This is rarely used however, the EventFacet
  packages are primarily for convenience and documentation. The EventFacet
  classes are not used at all internally, instead the raw data is used.
  
  Here is a list of facet types by package. The packages are not used internally,
  but are where the documentation for each type is kept.
  
  B<Note:> Every single facet type has the C<'details'> field. This field is
  always intended for human consumption, and when provided, should explain the
  'why' for the facet. All other fields are facet specific.
  
  =over 4
  
  =item about => {...}
  
  L<Test2::EventFacet::About>
  
  This contains information about the event itself such as the event package
  name. The C<details> field for this facet is an overall summary of the event.
  
  =item assert => {...}
  
  L<Test2::EventFacet::Assert>
  
  This facet is used if an assertion was made. The C<details> field of this facet
  is the description of the assertion.
  
  =item control => {...}
  
  L<Test2::EventFacet::Control>
  
  This facet is used to tell the L<Test2::Event::Hub> about special actions the
  event causes. Things like halting all testing, terminating the current test,
  etc. In this facet the C<details> field explains why any special action was
  taken.
  
  B<Note:> This is how bail-out is implemented.
  
  =item meta => {...}
  
  L<Test2::EventFacet::Meta>
  
  The meta facet contains all the meta-data attached to the event. In this case
  the C<details> field has no special meaning, but may be present if something
  sets the 'details' meta-key on the event.
  
  =item parent => {...}
  
  L<Test2::EventFacet::Parent>
  
  This facet contains nested events and similar details for subtests. In this
  facet the C<details> field will typically be the name of the subtest.
  
  =item plan => {...}
  
  L<Test2::EventFacet::Plan>
  
  This facet tells the system that a plan has been set. The C<details> field of
  this is usually left empty, but when present explains why the plan is what it
  is, this is most useful if the plan is to skip-all.
  
  =item trace => {...}
  
  L<Test2::EventFacet::Trace>
  
  This facet contains information related to when and where the event was
  generated. This is how the test file and line number of a failure is known.
  This facet can also help you to tell if tests are related.
  
  In this facet the C<details> field overrides the "failed at test_file.t line
  42." message provided on assertion failure.
  
  =item amnesty => [{...}, ...]
  
  L<Test2::EventFacet::Amnesty>
  
  The amnesty facet is a list instead of a single item, this is important as
  amnesty can come from multiple places at once.
  
  For each instance of amnesty the C<details> field explains why amnesty was
  granted.
  
  B<Note:> Outside of formatters amnesty only acts to forgive a failing
  assertion.
  
  =item errors => [{...}, ...]
  
  L<Test2::EventFacet::Error>
  
  The errors facet is a list instead of a single item, any number of errors can
  be listed. In this facet C<details> describes the error, or may contain the raw
  error message itself (such as an exception). In perl exception may be blessed
  objects, as such the raw data for this facet may contain nested items which are
  blessed.
  
  Not all errors are considered fatal, there is a C<fail> field that must be set
  for an error to cause the test to fail.
  
  B<Note:> This facet is unique in that the field name is 'errors' while the
  package is 'Error'. This is because this is the only facet type that is both a
  list, and has a name where the plural is not the same as the singular. This may
  cause some confusion, but I feel it will be less confusing than the
  alternative.
  
  =item info => [{...}, ...]
  
  L<Test2::EventFacet::Info>
  
  The 'info' facet is a list instead of a single item, any quantity of extra
  information can be attached to an event. Some information may be critical
  diagnostics, others may be simply commentary in nature, this is determined by
  the C<debug> flag.
  
  For this facet the C<details> flag is the info itself. This info may be a
  string, or it may be a data structure to display. This is one of the few facet
  types that may contain blessed items.
  
  =back
  
  =head2 LEGACY API
  
  =over 4
  
  =item $bool = $e->causes_fail
  
  Returns true if this event should result in a test failure. In general this
  should be false.
  
  =item $bool = $e->increments_count
  
  Should be true if this event should result in a test count increment.
  
  =item $e->callback($hub)
  
  If your event needs to have extra effects on the L<Test2::Hub> you can override
  this method.
  
  This is called B<BEFORE> your event is passed to the formatter.
  
  =item $num = $e->nested
  
  If this event is nested inside of other events, this should be the depth of
  nesting. (This is mainly for subtests)
  
  =item $bool = $e->global
  
  Set this to true if your event is global, that is ALL threads and processes
  should see it no matter when or where it is generated. This is not a common
  thing to want, it is used by bail-out and skip_all to end testing.
  
  =item $code = $e->terminate
  
  This is called B<AFTER> your event has been passed to the formatter. This
  should normally return undef, only change this if your event should cause the
  test to exit immediately.
  
  If you want this event to cause the test to exit you should return the exit
  code here. Exit code of 0 means exit success, any other integer means exit with
  failure.
  
  This is used by L<Test2::Event::Plan> to exit 0 when the plan is
  'skip_all'. This is also used by L<Test2::Event:Bail> to force the test
  to exit with a failure.
  
  This is called after the event has been sent to the formatter in order to
  ensure the event is seen and understood.
  
  =item $msg = $e->summary
  
  This is intended to be a human readable summary of the event. This should
  ideally only be one line long, but you can use multiple lines if necessary. This
  is intended for human consumption. You do not need to make it easy for machines
  to understand.
  
  The default is to simply return the event package name.
  
  =item ($count, $directive, $reason) = $e->sets_plan()
  
  Check if this event sets the testing plan. It will return an empty list if it
  does not. If it does set the plan it will return a list of 1 to 3 items in
  order: Expected Test Count, Test Directive, Reason for directive.
  
  =item $bool = $e->diagnostics
  
  True if the event contains diagnostics info. This is useful because a
  non-verbose harness may choose to hide events that are not in this category.
  Some formatters may choose to send these to STDERR instead of STDOUT to ensure
  they are seen.
  
  =item $bool = $e->no_display
  
  False by default. This will return true on events that should not be displayed
  by formatters.
  
  =item $id = $e->in_subtest
  
  If the event is inside a subtest this should have the subtest ID.
  
  =item $id = $e->subtest_id
  
  If the event is a final subtest event, this should contain the subtest ID.
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT

$fatpacked{"Test2/Event/Bail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_BAIL';
  package Test2::Event::Bail;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{reason buffered};
  
  # Make sure the tests terminate
  sub terminate { 255 };
  
  sub global { 1 };
  
  sub causes_fail { 1 }
  
  sub summary {
      my $self = shift;
      return "Bail out!  " . $self->{+REASON}
          if $self->{+REASON};
  
      return "Bail out!";
  }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{control} = {
          global    => 1,
          halt      => 1,
          details   => $self->{+REASON},
          terminate => 255,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Bail - Bailout!
  
  =head1 DESCRIPTION
  
  The bailout event is generated when things go horribly wrong and you need to
  halt all testing in the current file.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Bail;
  
      my $ctx = context();
      my $event = $ctx->bail('Stuff is broken');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $reason = $e->reason
  
  The reason for the bailout.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_BAIL

$fatpacked{"Test2/Event/Diag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_DIAG';
  package Test2::Event::Diag;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/message/;
  
  sub init {
      $_[0]->{+MESSAGE} = 'undef' unless defined $_[0]->{+MESSAGE};
  }
  
  sub summary { $_[0]->{+MESSAGE} }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{info} = [
          {
              tag     => 'DIAG',
              debug   => 1,
              details => $self->{+MESSAGE},
          }
      ];
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Diag - Diag event type
  
  =head1 DESCRIPTION
  
  Diagnostics messages, typically rendered to STDERR.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Diag;
  
      my $ctx = context();
      my $event = $ctx->diag($message);
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $diag->message
  
  The message for the diag.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_DIAG

$fatpacked{"Test2/Event/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_ENCODING';
  package Test2::Event::Encoding;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/encoding/;
  
  sub init {
      my $self = shift;
      defined $self->{+ENCODING} or croak "'encoding' is a required attribute";
  }
  
  sub summary { 'Encoding set to ' . $_[0]->{+ENCODING} }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
      $out->{control}->{encoding} = $self->{+ENCODING};
      $out->{about}->{details} = $self->summary;
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Encoding - Set the encoding for the output stream
  
  =head1 DESCRIPTION
  
  The encoding event is generated when a test file wants to specify the encoding
  to be used when formatting its output. This event is intended to be produced
  by formatter classes and used for interpreting test names, message contents,
  etc.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Encoding;
  
      my $ctx = context();
      my $event = $ctx->send_event('Encoding', encoding => 'UTF-8');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $encoding = $e->encoding
  
  The encoding being specified.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_ENCODING

$fatpacked{"Test2/Event/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_EXCEPTION';
  package Test2::Event::Exception;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{error};
  
  sub init {
      my $self = shift;
      $self->{+ERROR} = "$self->{+ERROR}";
  }
  
  sub causes_fail { 1 }
  
  sub summary {
      my $self = shift;
      chomp(my $msg = "Exception: " . $self->{+ERROR});
      return $msg;
  }
  
  sub diagnostics { 1 }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{errors} = [
          {
              tag     => 'ERROR',
              fail    => 1,
              details => $self->{+ERROR},
          }
      ];
  
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Exception - Exception event
  
  =head1 DESCRIPTION
  
  An exception event will display to STDERR, and will prevent the overall test
  file from passing.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Exception;
  
      my $ctx = context();
      my $event = $ctx->send_event('Exception', error => 'Stuff is broken');
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $reason = $e->error
  
  The reason for the exception.
  
  =back
  
  =head1 CAVEATS
  
  Be aware that all exceptions are stringified during construction.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_EXCEPTION

$fatpacked{"Test2/Event/Fail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_FAIL';
  package Test2::Event::Fail;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::EventFacet::Info;
  
  BEGIN {
      require Test2::Event;
      our @ISA = qw(Test2::Event);
      *META_KEY = \&Test2::Util::ExternalMeta::META_KEY;
  }
  
  use Test2::Util::HashBase qw{ -name -info };
  
  #############
  # Old API
  sub summary          { "fail" }
  sub increments_count { 1 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  sub terminate        { () }
  sub global           { () }
  sub sets_plan        { () }
  
  sub causes_fail {
      my $self = shift;
      return 0 if $self->{+AMNESTY} && @{$self->{+AMNESTY}};
      return 1;
  }
  
  #############
  # New API
  
  sub add_info {
      my $self = shift;
  
      for my $in (@_) {
          $in = {%$in} if ref($in) ne 'ARRAY';
          $in = Test2::EventFacet::Info->new($in);
  
          push @{$self->{+INFO}} => $in;
      }
  }
  
  sub facet_data {
      my $self = shift;
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = 'fail';
  
      $out->{assert} = {pass => 0, details => $self->{+NAME}};
  
      $out->{info} = [map {{ %{$_} }} @{$self->{+INFO}}] if $self->{+INFO};
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Fail - Event for a simple failed assertion
  
  =head1 DESCRIPTION
  
  This is an optimal representation of a failed assertion.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub fail {
          my ($name) = @_;
          my $ctx = context();
          $ctx->fail($name);
          $ctx->release;
      }
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_FAIL

$fatpacked{"Test2/Event/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_GENERIC';
  package Test2::Event::Generic;
  use strict;
  use warnings;
  
  use Carp qw/croak/;
  use Scalar::Util qw/reftype/;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase;
  
  my @FIELDS = qw{
      causes_fail increments_count diagnostics no_display callback terminate
      global sets_plan summary facet_data
  };
  my %DEFAULTS = (
      causes_fail      => 0,
      increments_count => 0,
      diagnostics      => 0,
      no_display       => 0,
  );
  
  sub init {
      my $self = shift;
  
      for my $field (@FIELDS) {
          my $val = defined $self->{$field} ? delete $self->{$field} : $DEFAULTS{$field};
          next unless defined $val;
  
          my $set = "set_$field";
          $self->$set($val);
      }
  }
  
  for my $field (@FIELDS) {
      no strict 'refs';
  
      *$field = sub { exists $_[0]->{$field} ? $_[0]->{$field} : () }
          unless exists &{$field};
  
      *{"set_$field"} = sub { $_[0]->{$field} = $_[1] }
          unless exists &{"set_$field"};
  }
  
  sub can {
      my $self = shift;
      my ($name) = @_;
      return $self->SUPER::can($name) unless $name eq 'callback';
      return $self->{callback} || \&Test2::Event::callback;
  }
  
  sub facet_data {
      my $self = shift;
      return $self->{facet_data} || $self->SUPER::facet_data();
  }
  
  sub summary {
      my $self = shift;
      return $self->{summary} if defined $self->{summary};
      $self->SUPER::summary();
  }
  
  sub sets_plan {
      my $self = shift;
      return unless $self->{sets_plan};
      return @{$self->{sets_plan}};
  }
  
  sub callback {
      my $self = shift;
      my $cb = $self->{callback} || return;
      $self->$cb(@_);
  }
  
  sub set_global {
      my $self = shift;
      my ($bool) = @_;
  
      if(!defined $bool) {
          delete $self->{global};
          return undef;
      }
  
      $self->{global} = $bool;
  }
  
  sub set_callback {
      my $self = shift;
      my ($cb) = @_;
  
      if(!defined $cb) {
          delete $self->{callback};
          return undef;
      }
  
      croak "callback must be a code reference"
          unless ref($cb) && reftype($cb) eq 'CODE';
  
      $self->{callback} = $cb;
  }
  
  sub set_terminate {
      my $self = shift;
      my ($exit) = @_;
  
      if(!defined $exit) {
          delete $self->{terminate};
          return undef;
      }
  
      croak "terminate must be a positive integer"
         unless $exit =~ m/^\d+$/;
  
      $self->{terminate} = $exit;
  }
  
  sub set_sets_plan {
      my $self = shift;
      my ($plan) = @_;
  
      if(!defined $plan) {
          delete $self->{sets_plan};
          return undef;
      }
  
      croak "'sets_plan' must be an array reference"
          unless ref($plan) && reftype($plan) eq 'ARRAY';
  
      $self->{sets_plan} = $plan;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Generic - Generic event type.
  
  =head1 DESCRIPTION
  
  This is a generic event that lets you customize all fields in the event API.
  This is useful if you have need for a custom event that does not make sense as
  a published reusable event subclass.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub send_custom_fail {
          my $ctx = shift;
  
          $ctx->send_event('Generic', causes_fail => 1, summary => 'The sky is falling');
  
          $ctx->release;
      }
  
      send_custom_fail();
  
  =head1 METHODS
  
  =over 4
  
  =item $e->facet_data($data)
  
  =item $data = $e->facet_data
  
  Get or set the facet data (see L<Test2::Event>). If no facet_data is set then
  C<< Test2::Event->facet_data >> will be called to produce facets from the other
  data.
  
  =item $e->callback($hub)
  
  Call the custom callback if one is set, otherwise this does nothing.
  
  =item $e->set_callback(sub { ... })
  
  Set the custom callback. The custom callback must be a coderef. The first
  argument to your callback will be the event itself, the second will be the
  L<Test2::Event::Hub> that is using the callback.
  
  =item $bool = $e->causes_fail
  
  =item $e->set_causes_fail($bool)
  
  Get/Set the C<causes_fail> attribute. This defaults to C<0>.
  
  =item $bool = $e->diagnostics
  
  =item $e->set_diagnostics($bool)
  
  Get/Set the C<diagnostics> attribute. This defaults to C<0>.
  
  =item $bool_or_undef = $e->global
  
  =item @bool_or_empty = $e->global
  
  =item $e->set_global($bool_or_undef)
  
  Get/Set the C<diagnostics> attribute. This defaults to an empty list which is
  undef in scalar context.
  
  =item $bool = $e->increments_count
  
  =item $e->set_increments_count($bool)
  
  Get/Set the C<increments_count> attribute. This defaults to C<0>.
  
  =item $bool = $e->no_display
  
  =item $e->set_no_display($bool)
  
  Get/Set the C<no_display> attribute. This defaults to C<0>.
  
  =item @plan = $e->sets_plan
  
  Get the plan if this event sets one. The plan is a list of up to 3 items:
  C<($count, $directive, $reason)>. C<$count> must be defined, the others may be
  undef, or may not exist at all.
  
  =item $e->set_sets_plan(\@plan)
  
  Set the plan. You must pass in an arrayref with up to 3 elements.
  
  =item $summary = $e->summary
  
  =item $e->set_summary($summary_or_undef)
  
  Get/Set the summary. This will default to the event package
  C<'Test2::Event::Generic'>. You can set it to any value. Setting this to
  C<undef> will reset it to the default.
  
  =item $int_or_undef = $e->terminate
  
  =item @int_or_empty = $e->terminate
  
  =item $e->set_terminate($int_or_undef)
  
  This will get/set the C<terminate> attribute. This defaults to undef in scalar
  context, or an empty list in list context. Setting this to undef will clear it
  completely. This must be set to a positive integer (0 or larger).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_GENERIC

$fatpacked{"Test2/Event/Note.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_NOTE';
  package Test2::Event::Note;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/message/;
  
  sub init {
      $_[0]->{+MESSAGE} = 'undef' unless defined $_[0]->{+MESSAGE};
  }
  
  sub summary { $_[0]->{+MESSAGE} }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{info} = [
          {
              tag     => 'NOTE',
              debug   => 0,
              details => $self->{+MESSAGE},
          }
      ];
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Note - Note event type
  
  =head1 DESCRIPTION
  
  Notes, typically rendered to STDOUT.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Note;
  
      my $ctx = context();
      my $event = $ctx->Note($message);
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $note->message
  
  The message for the note.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_NOTE

$fatpacked{"Test2/Event/Ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_OK';
  package Test2::Event::Ok;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{
      pass effective_pass name todo
  };
  
  sub init {
      my $self = shift;
  
      # Do not store objects here, only true or false
      $self->{+PASS} = $self->{+PASS} ? 1 : 0;
      $self->{+EFFECTIVE_PASS} = $self->{+PASS} || (defined($self->{+TODO}) ? 1 : 0);
  }
  
  {
      no warnings 'redefine';
      sub set_todo {
          my $self = shift;
          my ($todo) = @_;
          $self->{+TODO} = $todo;
          $self->{+EFFECTIVE_PASS} = defined($todo) ? 1 : $self->{+PASS};
      }
  }
  
  sub increments_count { 1 };
  
  sub causes_fail { !$_[0]->{+EFFECTIVE_PASS} }
  
  sub summary {
      my $self = shift;
  
      my $name = $self->{+NAME} || "Nameless Assertion";
  
      my $todo = $self->{+TODO};
      if ($todo) {
          $name .= " (TODO: $todo)";
      }
      elsif (defined $todo) {
          $name .= " (TODO)"
      }
  
      return $name;
  }
  
  sub extra_amnesty {
      my $self = shift;
      return unless defined($self->{+TODO}) || ($self->{+EFFECTIVE_PASS} && !$self->{+PASS});
      return {
          tag       => 'TODO',
          details   => $self->{+TODO},
      };
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{assert}  = {
          no_debug => 1,                # Legacy behavior
          pass     => $self->{+PASS},
          details  => $self->{+NAME},
      };
  
      if (my @exra_amnesty = $self->extra_amnesty) {
          unshift @{$out->{amnesty}} => @exra_amnesty;
      }
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Ok - Ok event type
  
  =head1 DESCRIPTION
  
  Ok events are generated whenever you run a test that produces a result.
  Examples are C<ok()>, and C<is()>.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Ok;
  
      my $ctx = context();
      my $event = $ctx->ok($bool, $name, \@diag);
  
  or:
  
      my $ctx   = context();
      my $event = $ctx->send_event(
          'Ok',
          pass => $bool,
          name => $name,
      );
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $rb = $e->pass
  
  The original true/false value of whatever was passed into the event (but
  reduced down to 1 or 0).
  
  =item $name = $e->name
  
  Name of the test.
  
  =item $b = $e->effective_pass
  
  This is the true/false value of the test after TODO and similar modifiers are
  taken into account.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_OK

$fatpacked{"Test2/Event/Pass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PASS';
  package Test2::Event::Pass;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::EventFacet::Info;
  
  BEGIN {
      require Test2::Event;
      our @ISA = qw(Test2::Event);
      *META_KEY = \&Test2::Util::ExternalMeta::META_KEY;
  }
  
  use Test2::Util::HashBase qw{ -name -info };
  
  ##############
  # Old API
  sub summary          { "pass" }
  sub increments_count { 1 }
  sub causes_fail      { 0 }
  sub diagnostics      { 0 }
  sub no_display       { 0 }
  sub subtest_id       { undef }
  sub terminate        { () }
  sub global           { () }
  sub sets_plan        { () }
  
  ##############
  # New API
  
  sub add_info {
      my $self = shift;
  
      for my $in (@_) {
          $in = {%$in} if ref($in) ne 'ARRAY';
          $in = Test2::EventFacet::Info->new($in);
  
          push @{$self->{+INFO}} => $in;
      }
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = 'pass';
  
      $out->{assert} = {pass => 1, details => $self->{+NAME}};
  
      $out->{info} = [map {{ %{$_} }} @{$self->{+INFO}}] if $self->{+INFO};
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Pass - Event for a simple passing assertion
  
  =head1 DESCRIPTION
  
  This is an optimal representation of a passing assertion.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
  
      sub pass {
          my ($name) = @_;
          my $ctx = context();
          $ctx->pass($name);
          $ctx->release;
      }
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_PASS

$fatpacked{"Test2/Event/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_PLAN';
  package Test2::Event::Plan;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw{max directive reason};
  
  use Carp qw/confess/;
  
  my %ALLOWED = (
      'SKIP'    => 1,
      'NO PLAN' => 1,
  );
  
  sub init {
      if ($_[0]->{+DIRECTIVE}) {
          $_[0]->{+DIRECTIVE} = 'SKIP'    if $_[0]->{+DIRECTIVE} eq 'skip_all';
          $_[0]->{+DIRECTIVE} = 'NO PLAN' if $_[0]->{+DIRECTIVE} eq 'no_plan';
  
          confess "'" . $_[0]->{+DIRECTIVE} . "' is not a valid plan directive"
              unless $ALLOWED{$_[0]->{+DIRECTIVE}};
      }
      else {
          confess "Cannot have a reason without a directive!"
              if defined $_[0]->{+REASON};
  
          confess "No number of tests specified"
              unless defined $_[0]->{+MAX};
  
          confess "Plan test count '" . $_[0]->{+MAX}  . "' does not appear to be a valid positive integer"
              unless $_[0]->{+MAX} =~ m/^\d+$/;
  
          $_[0]->{+DIRECTIVE} = '';
      }
  }
  
  sub sets_plan {
      my $self = shift;
      return (
          $self->{+MAX},
          $self->{+DIRECTIVE},
          $self->{+REASON},
      );
  }
  
  sub terminate {
      my $self = shift;
      # On skip_all we want to terminate the hub
      return 0 if $self->{+DIRECTIVE} && $self->{+DIRECTIVE} eq 'SKIP';
      return undef;
  }
  
  sub summary {
      my $self = shift;
      my $max = $self->{+MAX};
      my $directive = $self->{+DIRECTIVE};
      my $reason = $self->{+REASON};
  
      return "Plan is $max assertions"
          if $max || !$directive;
  
      return "Plan is '$directive', $reason"
          if $reason;
  
      return "Plan is '$directive'";
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{control}->{terminate} = $self->{+DIRECTIVE} eq 'SKIP' ? 0 : undef
          unless defined $out->{control}->{terminate};
  
      $out->{plan} = {count => $self->{+MAX}};
      $out->{plan}->{details} = $self->{+REASON} if defined $self->{+REASON};
  
      if (my $dir = $self->{+DIRECTIVE}) {
          $out->{plan}->{skip} = 1 if $dir eq 'SKIP';
          $out->{plan}->{none} = 1 if $dir eq 'NO PLAN';
      }
  
      return $out;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Plan - The event of a plan
  
  =head1 DESCRIPTION
  
  Plan events are fired off whenever a plan is declared, done testing is called,
  or a subtext completes.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Plan;
  
      my $ctx = context();
  
      # Plan for 10 tests to run
      my $event = $ctx->plan(10);
  
      # Plan to skip all tests (will exit 0)
      $ctx->plan(0, skip_all => "These tests need to be skipped");
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $num = $plan->max
  
  Get the number of expected tests
  
  =item $dir = $plan->directive
  
  Get the directive (such as TODO, skip_all, or no_plan).
  
  =item $reason = $plan->reason
  
  Get the reason for the directive.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_PLAN

$fatpacked{"Test2/Event/Skip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SKIP';
  package Test2::Event::Skip;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event::Ok; our @ISA = qw(Test2::Event::Ok) }
  use Test2::Util::HashBase qw{reason};
  
  sub init {
      my $self = shift;
      $self->SUPER::init;
      $self->{+EFFECTIVE_PASS} = 1;
  }
  
  sub causes_fail { 0 }
  
  sub summary {
      my $self = shift;
      my $out = $self->SUPER::summary(@_);
  
      if (my $reason = $self->reason) {
          $out .= " (SKIP: $reason)";
      }
      else {
          $out .= " (SKIP)";
      }
  
      return $out;
  }
  
  sub extra_amnesty {
      my $self = shift;
  
      my @out;
  
      push @out => {
          tag       => 'TODO',
          details   => $self->{+TODO},
      } if defined $self->{+TODO};
  
      push @out => {
          tag       => 'skip',
          details   => $self->{+REASON},
          inherited => 0,
      };
  
      return @out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Skip - Skip event type
  
  =head1 DESCRIPTION
  
  Skip events bump test counts just like L<Test2::Event::Ok> events, but
  they can never fail.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Skip;
  
      my $ctx = context();
      my $event = $ctx->skip($name, $reason);
  
  or:
  
      my $ctx   = context();
      my $event = $ctx->send_event(
          'Skip',
          name   => $name,
          reason => $reason,
      );
  
  =head1 ACCESSORS
  
  =over 4
  
  =item $reason = $e->reason
  
  The original true/false value of whatever was passed into the event (but
  reduced down to 1 or 0).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST2_EVENT_SKIP

$fatpacked{"Test2/Event/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_SUBTEST';
  package Test2::Event::Subtest;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Event::Ok; our @ISA = qw(Test2::Event::Ok) }
  use Test2::Util::HashBase qw{subevents buffered subtest_id subtest_uuid};
  
  sub init {
      my $self = shift;
      $self->SUPER::init();
      $self->{+SUBEVENTS} ||= [];
      if ($self->{+EFFECTIVE_PASS}) {
          $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}};
      }
  }
  
  {
      no warnings 'redefine';
  
      sub set_subevents {
          my $self      = shift;
          my @subevents = @_;
  
          if ($self->{+EFFECTIVE_PASS}) {
              $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @subevents;
          }
  
          $self->{+SUBEVENTS} = \@subevents;
      }
  
      sub set_effective_pass {
          my $self = shift;
          my ($pass) = @_;
  
          if ($pass) {
              $_->set_effective_pass(1) for grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}};
          }
          elsif ($self->{+EFFECTIVE_PASS} && !$pass) {
              for my $s (grep { $_->can('effective_pass') } @{$self->{+SUBEVENTS}}) {
                  $_->set_effective_pass(0) unless $s->can('todo') && defined $s->todo;
              }
          }
  
          $self->{+EFFECTIVE_PASS} = $pass;
      }
  }
  
  sub summary {
      my $self = shift;
  
      my $name = $self->{+NAME} || "Nameless Subtest";
  
      my $todo = $self->{+TODO};
      if ($todo) {
          $name .= " (TODO: $todo)";
      }
      elsif (defined $todo) {
          $name .= " (TODO)";
      }
  
      return $name;
  }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->SUPER::facet_data();
  
      $out->{parent} = {
          hid      => $self->subtest_id,
          children => [map {$_->facet_data} @{$self->{+SUBEVENTS}}],
          buffered => $self->{+BUFFERED},
      };
  
      return $out;
  }
  
  sub add_amnesty {
      my $self = shift;
  
      for my $am (@_) {
          $am = {%$am} if ref($am) ne 'ARRAY';
          $am = Test2::EventFacet::Amnesty->new($am);
  
          push @{$self->{+AMNESTY}} => $am;
  
          for my $e (@{$self->{+SUBEVENTS}}) {
              $e->add_amnesty($am->clone(inherited => 1));
          }
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Subtest - Event for subtest types
  
  =head1 DESCRIPTION
  
  This class represents a subtest. This class is a subclass of
  L<Test2::Event::Ok>.
  
  =head1 ACCESSORS
  
  This class inherits from L<Test2::Event::Ok>.
  
  =over 4
  
  =item $arrayref = $e->subevents
  
  Returns the arrayref containing all the events from the subtest
  
  =item $bool = $e->buffered
  
  True if the subtest is buffered, that is all subevents render at once. If this
  is false it means all subevents render as they are produced.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_SUBTEST

$fatpacked{"Test2/Event/TAP/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_TAP_VERSION';
  package Test2::Event::TAP::Version;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase qw/version/;
  
  sub init {
      my $self = shift;
      defined $self->{+VERSION} or croak "'version' is a required attribute";
  }
  
  sub summary { 'TAP version ' . $_[0]->{+VERSION} }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      $out->{about}->{details} = $self->summary;
  
      push @{$out->{info}} => {
          tag     => 'INFO',
          debug   => 0,
          details => $self->summary,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::TAP::Version - Event for TAP version.
  
  =head1 DESCRIPTION
  
  This event is used if a TAP formatter wishes to set a version.
  
  =head1 SYNOPSIS
  
      use Test2::API qw/context/;
      use Test2::Event::Encoding;
  
      my $ctx = context();
      my $event = $ctx->send_event('TAP::Version', version => 42);
  
  =head1 METHODS
  
  Inherits from L<Test2::Event>. Also defines:
  
  =over 4
  
  =item $version = $e->version
  
  The TAP version being parsed.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_TAP_VERSION

$fatpacked{"Test2/Event/V2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_V2';
  package Test2::Event::V2;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Scalar::Util qw/reftype/;
  use Carp qw/croak/;
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  
  use Test2::Util::Facets2Legacy qw{
      causes_fail diagnostics global increments_count no_display sets_plan
      subtest_id summary terminate
  };
  
  use Test2::Util::HashBase qw/-about/;
  
  sub non_facet_keys {
      return (
          +UUID,
          Test2::Util::ExternalMeta::META_KEY(),
      );
  }
  
  sub init {
      my $self = shift;
  
      my $uuid;
      if ($uuid = $self->{+UUID}) {
          croak "uuid '$uuid' passed to constructor, but uuid '$self->{+ABOUT}->{uuid}' is already set in the 'about' facet"
              if $self->{+ABOUT}->{uuid} && $self->{+ABOUT}->{uuid} ne $uuid;
  
          $self->{+ABOUT}->{uuid} = $uuid;
      }
      elsif ($uuid = $self->{+ABOUT}->{uuid}) {
          $self->SUPER::set_uuid($uuid);
      }
  
      # Clone the trace, make sure it is blessed
      if (my $trace = $self->{+TRACE}) {
          $self->{+TRACE} = Test2::EventFacet::Trace->new(%$trace);
      }
  }
  
  sub set_uuid {
      my $self = shift;
      my ($uuid) = @_;
      $self->{+ABOUT}->{uuid} = $uuid;
      $self->SUPER::set_uuid($uuid);
  }
  
  sub facet_data {
      my $self = shift;
      my $f = { %{$self} };
  
      delete $f->{$_} for $self->non_facet_keys;
  
      my %out;
      for my $k (keys %$f) {
          next if substr($k, 0, 1) eq '_';
  
          my $data = $f->{$k};
          my $is_list = reftype($data) eq 'ARRAY';
          $out{$k} = $is_list ? [ map { {%{$_}} } @$data ] : {%$data};
      }
  
      if (my $meta = $self->meta_facet_data) {
          $out{meta} = {%$meta, %{$out{meta} || {}}};
      }
  
      return \%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::V2 - Second generation event.
  
  =head1 DESCRIPTION
  
  This is the event type that should be used instead of L<Test2::Event> or its
  legacy subclasses.
  
  =head1 SYNOPSIS
  
  =head2 USING A CONTEXT
  
      use Test2::API qw/context/;
  
      sub my_tool {
          my $ctx = context();
  
          my $event = $ctx->send_ev2(info => [{tag => 'NOTE', details => "This is a note"}]);
  
          $ctx->release;
  
          return $event;
      }
  
  =head2 USING THE CONSTRUCTOR
  
      use Test2::Event::V2;
  
      my $e = Test2::Event::V2->new(
          trace => {frame => [$PKG, $FILE, $LINE, $SUBNAME]},
          info  => [{tag => 'NOTE', details => "This is a note"}],
      );
  
  =head1 METHODS
  
  This class inherits from L<Test2::Event>.
  
  =over 4
  
  =item $fd = $e->facet_data()
  
  This will return a hashref of facet data. Each facet hash will be a shallow
  copy of the original.
  
  =item $about = $e->about()
  
  This will return the 'about' facet hashref.
  
  B<NOTE:> This will return the internal hashref, not a copy.
  
  =item $trace = $e->trace()
  
  This will return the 'trace' facet, normally blessed (but this is not enforced
  when the trace is set using C<set_trace()>.
  
  B<NOTE:> This will return the internal trace, not a copy.
  
  =back
  
  =head2 MUTATION
  
  =over 4
  
  =item $e->add_amnesty({...})
  
  Inherited from L<Test2::Event>. This can be used to add 'amnesty' facets to an
  existing event. Each new item is added to the B<END> of the list.
  
  B<NOTE:> Items B<ARE> blessed when added.
  
  =item $e->add_hub({...})
  
  Inherited from L<Test2::Event>. This is used by hubs to stamp events as they
  pass through. New items are added to the B<START> of the list.
  
  B<NOTE:> Items B<ARE NOT> blessed when added.
  
  =item $e->set_uuid($UUID)
  
  Inherited from L<Test2::Event>, overridden to also vivify/mutate the 'about'
  facet.
  
  =item $e->set_trace($trace)
  
  Inherited from L<Test2::Event> which allows you to change the trace.
  
  B<Note:> This method does not bless/clone the trace for you. Many things will
  expect the trace to be blessed, so you should probably do that.
  
  =back
  
  =head2 LEGACY SUPPORT METHODS
  
  These are all imported from L<Test2::Util::Facets2Legacy>, see that module or
  L<Test2::Event> for documentation on what they do.
  
  =over 4
  
  =item causes_fail
  
  =item diagnostics
  
  =item global
  
  =item increments_count
  
  =item no_display
  
  =item sets_plan
  
  =item subtest_id
  
  =item summary
  
  =item terminate
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_V2

$fatpacked{"Test2/Event/Waiting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENT_WAITING';
  package Test2::Event::Waiting;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::Event; our @ISA = qw(Test2::Event) }
  use Test2::Util::HashBase;
  
  sub global { 1 };
  
  sub summary { "IPC is waiting for children to finish..." }
  
  sub facet_data {
      my $self = shift;
  
      my $out = $self->common_facet_data;
  
      push @{$out->{info}} => {
          tag     => 'INFO',
          debug   => 0,
          details => $self->summary,
      };
  
      return $out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Event::Waiting - Tell all procs/threads it is time to be done
  
  =head1 DESCRIPTION
  
  This event has no data of its own. This event is sent out by the IPC system
  when the main process/thread is ready to end.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENT_WAITING

$fatpacked{"Test2/EventFacet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET';
  package Test2::EventFacet;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::Util::HashBase qw/-details/;
  use Carp qw/croak/;
  
  my $SUBLEN = length(__PACKAGE__ . '::');
  sub facet_key {
      my $key = ref($_[0]) || $_[0];
      substr($key, 0, $SUBLEN, '');
      return lc($key);
  }
  
  sub is_list { 0 }
  
  sub clone {
      my $self = shift;
      my $type = ref($self);
      return bless {%$self, @_}, $type;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet - Base class for all event facets.
  
  =head1 DESCRIPTION
  
  Base class for all event facets.
  
  =head1 METHODS
  
  =over 4
  
  =item $key = $facet_class->facet_key()
  
  This will return the key for the facet in the facet data hash.
  
  =item $bool = $facet_class->is_list()
  
  This will return true if the facet should be in a list instead of a single
  item.
  
  =item $clone = $facet->clone()
  
  =item $clone = $facet->clone(%replace)
  
  This will make a shallow clone of the facet. You may specify fields to override
  as arguments.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET

$fatpacked{"Test2/EventFacet/About.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ABOUT';
  package Test2::EventFacet::About;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -package -no_display -uuid -eid };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::About - Facet with event details.
  
  =head1 DESCRIPTION
  
  This facet has information about the event, such as event package.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $about->{details}
  
  =item $string = $about->details()
  
  Summary about the event.
  
  =item $package = $about->{package}
  
  =item $package = $about->package()
  
  Event package name.
  
  =item $bool = $about->{no_display}
  
  =item $bool = $about->no_display()
  
  True if the event should be skipped by formatters.
  
  =item $uuid = $about->{uuid}
  
  =item $uuid = $about->uuid()
  
  Will be set to a uuid if uuid tagging was enabled.
  
  =item $uuid = $about->{eid}
  
  =item $uuid = $about->eid()
  
  A unique (for the test job) identifier for the event.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ABOUT

$fatpacked{"Test2/EventFacet/Amnesty.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_AMNESTY';
  package Test2::EventFacet::Amnesty;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -inherited };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Amnesty - Facet for assertion amnesty.
  
  =head1 DESCRIPTION
  
  This package represents what is expected in units of amnesty.
  
  =head1 NOTES
  
  This facet appears in a list instead of being a single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $amnesty->{details}
  
  =item $string = $amnesty->details()
  
  Human readable explanation of why amnesty was granted.
  
  Example: I<Not implemented yet, will fix>
  
  =item $short_string = $amnesty->{tag}
  
  =item $short_string = $amnesty->tag()
  
  Short string (usually 10 characters or less, not enforced, but may be truncated
  by renderers) categorizing the amnesty.
  
  =item $bool = $amnesty->{inherited}
  
  =item $bool = $amnesty->inherited()
  
  This will be true if the amnesty was granted to a parent event and inherited by
  this event, which is a child, such as an assertion within a subtest that is
  marked todo.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_AMNESTY

$fatpacked{"Test2/EventFacet/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ASSERT';
  package Test2::EventFacet::Assert;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -pass -no_debug -number };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Assert - Facet representing an assertion.
  
  =head1 DESCRIPTION
  
  The assertion facet is provided by any event representing an assertion that was
  made.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $assert->{details}
  
  =item $string = $assert->details()
  
  Human readable description of the assertion.
  
  =item $bool = $assert->{pass}
  
  =item $bool = $assert->pass()
  
  True if the assertion passed.
  
  =item $bool = $assert->{no_debug}
  
  =item $bool = $assert->no_debug()
  
  Set this to true if you have provided custom diagnostics and do not want the
  defaults to be displayed.
  
  =item $int = $assert->{number}
  
  =item $int = $assert->number()
  
  (Optional) assertion number. This may be omitted or ignored. This is usually
  only useful when parsing/processing TAP.
  
  B<Note>: This is not set by the Test2 system, assertion number is not known
  until AFTER the assertion has been processed. This attribute is part of the
  spec only for harnesses.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ASSERT

$fatpacked{"Test2/EventFacet/Control.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_CONTROL';
  package Test2::EventFacet::Control;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -global -terminate -halt -has_callback -encoding };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Control - Facet for hub actions and behaviors.
  
  =head1 DESCRIPTION
  
  This facet is used when the event needs to give instructions to the Test2
  internals.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $control->{details}
  
  =item $string = $control->details()
  
  Human readable explanation for the special behavior.
  
  =item $bool = $control->{global}
  
  =item $bool = $control->global()
  
  True if the event is global in nature and should be seen by all hubs.
  
  =item $exit = $control->{terminate}
  
  =item $exit = $control->terminate()
  
  Defined if the test should immediately exit, the value is the exit code and may
  be C<0>.
  
  =item $bool = $control->{halt}
  
  =item $bool = $control->halt()
  
  True if all testing should be halted immediately.
  
  =item $bool = $control->{has_callback}
  
  =item $bool = $control->has_callback()
  
  True if the C<callback($hub)> method on the event should be called.
  
  =item $encoding = $control->{encoding}
  
  =item $encoding = $control->encoding()
  
  This can be used to change the encoding from this event onward.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_CONTROL

$fatpacked{"Test2/EventFacet/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_ERROR';
  package Test2::EventFacet::Error;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub facet_key { 'errors' }
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -fail };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Error - Facet for errors that need to be shown.
  
  =head1 DESCRIPTION
  
  This facet is used when an event needs to convey errors.
  
  =head1 NOTES
  
  This facet has the hash key C<'errors'>, and is a list of facets instead of a
  single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $error->{details}
  
  =item $string = $error->details()
  
  Explanation of the error, or the error itself (such as an exception). In perl
  exceptions may be blessed objects, so this field may contain a blessed object.
  
  =item $short_string = $error->{tag}
  
  =item $short_string = $error->tag()
  
  Short tag to categorize the error. This is usually 10 characters or less,
  formatters may truncate longer tags.
  
  =item $bool = $error->{fail}
  
  =item $bool = $error->fail()
  
  Not all errors are fatal, some are displayed having already been handled. Set
  this to true if you want the error to cause the test to fail. Without this the
  error is simply a diagnostics message that has no effect on the overall
  pass/fail result.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_ERROR

$fatpacked{"Test2/EventFacet/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_HUB';
  package Test2::EventFacet::Hub;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  sub facet_key { 'hubs' }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{-pid -tid -hid -nested -buffered -uuid -ipc};
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Hub - Facet for the hubs an event passes through.
  
  =head1 DESCRIPTION
  
  These are a record of the hubs an event passes through. Most recent hub is the
  first one in the list.
  
  =head1 FACET FIELDS
  
  =over 4
  
  =item $string = $trace->{details}
  
  =item $string = $trace->details()
  
  The hub class or subclass
  
  =item $int = $trace->{pid}
  
  =item $int = $trace->pid()
  
  PID of the hub this event was sent to.
  
  =item $int = $trace->{tid}
  
  =item $int = $trace->tid()
  
  The thread ID of the hub the event was sent to.
  
  =item $hid = $trace->{hid}
  
  =item $hid = $trace->hid()
  
  The ID of the hub that the event was send to.
  
  =item $huuid = $trace->{huuid}
  
  =item $huuid = $trace->huuid()
  
  The UUID of the hub that the event was sent to.
  
  =item $int = $trace->{nested}
  
  =item $int = $trace->nested()
  
  How deeply nested the hub was.
  
  =item $bool = $trace->{buffered}
  
  =item $bool = $trace->buffered()
  
  True if the event was buffered and not sent to the formatter independent of a
  parent (This should never be set when nested is C<0> or C<undef>).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_HUB

$fatpacked{"Test2/EventFacet/Info.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_INFO';
  package Test2::EventFacet::Info;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{-tag -debug -important};
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Info - Facet for information a developer might care about.
  
  =head1 DESCRIPTION
  
  This facet represents messages intended for humans that will help them either
  understand a result, or diagnose a failure.
  
  =head1 NOTES
  
  This facet appears in a list instead of being a single item.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string_or_structure = $info->{details}
  
  =item $string_or_structure = $info->details()
  
  Human readable string or data structure, this is the information to display.
  Formatters are free to render the structures however they please. This may
  contain a blessed object.
  
  =item $short_string = $info->{tag}
  
  =item $short_string = $info->tag()
  
  Short tag to categorize the info. This is usually 10 characters or less,
  formatters may truncate longer tags.
  
  =item $bool = $info->{debug}
  
  =item $bool = $info->debug()
  
  Set this to true if the message is critical, or explains a failure. This is
  info that should be displayed by formatters even in less-verbose modes.
  
  When false the information is not considered critical and may not be rendered
  in less-verbose modes.
  
  =item $bool = $info->{important}
  
  =item $bool = $info->important
  
  This should be set for non debug messages that are still important enough to
  show when a formatter is in quiet mode. A formatter should send these to STDOUT
  not STDERR, but should show them even in non-verbose mode.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_INFO

$fatpacked{"Test2/EventFacet/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_META';
  package Test2::EventFacet::Meta;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use vars qw/$AUTOLOAD/;
  
  # replace set_details
  {
      no warnings 'redefine';
      sub set_details { $_[0]->{'set_details'} }
  }
  
  sub can {
      my $self = shift;
      my ($name) = @_;
  
      my $existing = $self->SUPER::can($name);
      return $existing if $existing;
  
      # Only vivify when called on an instance, do not vivify for a class. There
      # are a lot of magic class methods used in things like serialization (or
      # the forks.pm module) which cause problems when vivified.
      return undef unless ref($self);
  
      my $sub = sub { $_[0]->{$name} };
      {
          no strict 'refs';
          *$name = $sub;
      }
  
      return $sub;
  }
  
  sub AUTOLOAD {
      my $name = $AUTOLOAD;
      $name =~ s/^.*:://g;
      my $sub = $_[0]->can($name);
      goto &$sub;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Meta - Facet for meta-data
  
  =head1 DESCRIPTION
  
  This facet can contain any random meta-data that has been attached to the
  event.
  
  =head1 METHODS AND FIELDS
  
  Any/all fields and accessors are autovivified into existence. There is no way
  to know what metadata may be added, so any is allowed.
  
  =over 4
  
  =item $anything = $meta->{anything}
  
  =item $anything = $meta->anything()
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_META

$fatpacked{"Test2/EventFacet/Parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PARENT';
  package Test2::EventFacet::Parent;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/confess/;
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -hid -children -buffered };
  
  sub init {
      confess "Attribute 'hid' must be set"
          unless defined $_[0]->{+HID};
  
      $_[0]->{+CHILDREN} ||= [];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Parent - Base class for all event facets.
  
  =head1 DESCRIPTION
  
  This facet is used when an event contains other events, such as a subtest.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $parent->{details}
  
  =item $string = $parent->details()
  
  Human readable description of the event.
  
  =item $hid = $parent->{hid}
  
  =item $hid = $parent->hid()
  
  Hub ID of the hub that is represented in the parent-child relationship.
  
  =item $arrayref = $parent->{children}
  
  =item $arrayref = $parent->children()
  
  Arrayref containing the facet-data hashes of events nested under this one.
  
  I<To get the actual events you need to get them from the parent event directly>
  
  =item $bool = $parent->{buffered}
  
  =item $bool = $parent->buffered()
  
  True if the subtest is buffered (meaning the formatter has probably not seen
  them yet).
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_PARENT

$fatpacked{"Test2/EventFacet/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_PLAN';
  package Test2::EventFacet::Plan;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -count -skip -none };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Plan - Facet for setting the plan
  
  =head1 DESCRIPTION
  
  Events use this facet when they need to set the plan.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $plan->{details}
  
  =item $string = $plan->details()
  
  Human readable explanation for the plan being set. This is normally not
  rendered by most formatters except when the C<skip> field is also set.
  
  =item $positive_int = $plan->{count}
  
  =item $positive_int = $plan->count()
  
  Set the number of expected assertions. This should usually be set to C<0> when
  C<skip> or C<none> are also set.
  
  =item $bool = $plan->{skip}
  
  =item $bool = $plan->skip()
  
  When true the entire test should be skipped. This is usually paired with an
  explanation in the C<details> field, and a C<control> facet that has
  C<terminate> set to C<0>.
  
  =item $bool = $plan->{none}
  
  =item $bool = $plan->none()
  
  This is mainly used by legacy L<Test::Builder> tests which set the plan to C<no
  plan>, a construct that predates the much better C<done_testing()>.
  
  If you are using this in non-legacy code you may need to reconsider the course
  of your life, maybe a hermitage would suite you?
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_PLAN

$fatpacked{"Test2/EventFacet/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_RENDER';
  package Test2::EventFacet::Render;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  sub is_list { 1 }
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  use Test2::Util::HashBase qw{ -tag -facet -mode };
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Render - Facet that dictates how to render an event.
  
  =head1 DESCRIPTION
  
  This facet is used to dictate how the event should be rendered by the standard
  test2 rendering tools. If this facet is present then ONLY what is specified by
  it will be rendered. It is assumed that anything important or note-worthy will
  be present here, no other facets will be considered for rendering/display.
  
  This facet is a list type, you can add as many items as needed.
  
  =head1 FIELDS
  
  =over 4
  
  =item $string = $render->[#]->{details}
  
  =item $string = $render->[#]->details()
  
  Human readable text for display.
  
  =item $string = $render->[#]->{tag}
  
  =item $string = $render->[#]->tag()
  
  Tag that should prefix/identify the main text.
  
  =item $string = $render->[#]->{facet}
  
  =item $string = $render->[#]->facet()
  
  Optional, if the display text was generated from another facet this should
  state what facet it was.
  
  =item $mode = $render->[#]->mode{}
  
  =item $mode = $render->[#]->mode()
  
  =over 4
  
  =item calculated
  
  Calculated means the facet was generated from another facet. Calculated facets
  may be cleared and regenerated whenever the event state changes.
  
  =item replace
  
  Replace means the facet is intended to replace the normal rendering of the
  event.
  
  =back
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_RENDER

$fatpacked{"Test2/EventFacet/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_EVENTFACET_TRACE';
  package Test2::EventFacet::Trace;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::EventFacet; our @ISA = qw(Test2::EventFacet) }
  
  use Test2::Util qw/get_tid pkg_to_file gen_uid/;
  use Carp qw/confess/;
  
  use Test2::Util::HashBase qw{^frame ^pid ^tid ^cid -hid -nested details -buffered -uuid -huuid};
  
  {
      no warnings 'once';
      *DETAIL = \&DETAILS;
      *detail = \&details;
      *set_detail = \&set_details;
  }
  
  sub init {
      confess "The 'frame' attribute is required"
          unless $_[0]->{+FRAME};
  
      $_[0]->{+DETAILS} = delete $_[0]->{detail} if $_[0]->{detail};
  
      unless (defined($_[0]->{+PID}) || defined($_[0]->{+TID}) || defined($_[0]->{+CID})) {
          $_[0]->{+PID} = $$        unless defined $_[0]->{+PID};
          $_[0]->{+TID} = get_tid() unless defined $_[0]->{+TID};
      }
  }
  
  sub snapshot {
      my ($orig, @override) = @_;
      bless {%$orig, @override}, __PACKAGE__;
  }
  
  sub signature {
      my $self = shift;
  
      # Signature is only valid if all of these fields are defined, there is no
      # signature if any is missing. '0' is ok, but '' is not.
      return join ':' => map { (defined($_) && length($_)) ? $_ : return undef } (
          $self->{+CID},
          $self->{+PID},
          $self->{+TID},
          $self->{+FRAME}->[1],
          $self->{+FRAME}->[2],
      );
  }
  
  sub debug {
      my $self = shift;
      return $self->{+DETAILS} if $self->{+DETAILS};
      my ($pkg, $file, $line) = $self->call;
      return "at $file line $line";
  }
  
  sub alert {
      my $self = shift;
      my ($msg) = @_;
      warn $msg . ' ' . $self->debug . ".\n";
  }
  
  sub throw {
      my $self = shift;
      my ($msg) = @_;
      die $msg . ' ' . $self->debug . ".\n";
  }
  
  sub call { @{$_[0]->{+FRAME}} }
  
  sub package { $_[0]->{+FRAME}->[0] }
  sub file    { $_[0]->{+FRAME}->[1] }
  sub line    { $_[0]->{+FRAME}->[2] }
  sub subname { $_[0]->{+FRAME}->[3] }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::EventFacet::Trace - Debug information for events
  
  =head1 DESCRIPTION
  
  The L<Test2::API::Context> object, as well as all L<Test2::Event> types need to
  have access to information about where they were created.  This object
  represents that information.
  
  =head1 SYNOPSIS
  
      use Test2::EventFacet::Trace;
  
      my $trace = Test2::EventFacet::Trace->new(
          frame => [$package, $file, $line, $subname],
      );
  
  =head1 FACET FIELDS
  
  =over 4
  
  =item $string = $trace->{details}
  
  =item $string = $trace->details()
  
  Used as a custom trace message that will be used INSTEAD of
  C<< at <FILE> line <LINE> >> when calling C<< $trace->debug >>.
  
  =item $frame = $trace->{frame}
  
  =item $frame = $trace->frame()
  
  Get the call frame arrayref.
  
  =item $int = $trace->{pid}
  
  =item $int = $trace->pid()
  
  The process ID in which the event was generated.
  
  =item $int = $trace->{tid}
  
  =item $int = $trace->tid()
  
  The thread ID in which the event was generated.
  
  =item $id = $trace->{cid}
  
  =item $id = $trace->cid()
  
  The ID of the context that was used to create the event.
  
  =item $uuid = $trace->{uuid}
  
  =item $uuid = $trace->uuid()
  
  The UUID of the context that was used to create the event. (If uuid tagging was
  enabled)
  
  =back
  
  =head2 DISCOURAGED HUB RELATED FIELDS
  
  These fields were not always set properly by tools. These are B<MOSTLY>
  deprecated by the L<Test2::EventFacet::Hub> facets. These fields are not
  required, and may only reflect the hub that was current when the event was
  created, which is not necessarily the same as the hub the event was sent
  through.
  
  Some tools did do a good job setting these to the correct hub, but you cannot
  always rely on that. Use the 'hubs' facet list instead.
  
  =over 4
  
  =item $hid = $trace->{hid}
  
  =item $hid = $trace->hid()
  
  The ID of the hub that was current when the event was created.
  
  =item $huuid = $trace->{huuid}
  
  =item $huuid = $trace->huuid()
  
  The UUID of the hub that was current when the event was created. (If uuid
  tagging was enabled).
  
  =item $int = $trace->{nested}
  
  =item $int = $trace->nested()
  
  How deeply nested the event is.
  
  =item $bool = $trace->{buffered}
  
  =item $bool = $trace->buffered()
  
  True if the event was buffered and not sent to the formatter independent of a
  parent (This should never be set when nested is C<0> or C<undef>).
  
  =back
  
  =head1 METHODS
  
  B<Note:> All facet frames are also methods.
  
  =over 4
  
  =item $trace->set_detail($msg)
  
  =item $msg = $trace->detail
  
  Used to get/set a custom trace message that will be used INSTEAD of
  C<< at <FILE> line <LINE> >> when calling C<< $trace->debug >>.
  
  C<detail()> is an alias to the C<details> facet field for backwards
  compatibility.
  
  =item $str = $trace->debug
  
  Typically returns the string C<< at <FILE> line <LINE> >>. If C<detail> is set
  then its value will be returned instead.
  
  =item $trace->alert($MESSAGE)
  
  This issues a warning at the frame (filename and line number where
  errors should be reported).
  
  =item $trace->throw($MESSAGE)
  
  This throws an exception at the frame (filename and line number where
  errors should be reported).
  
  =item ($package, $file, $line, $subname) = $trace->call()
  
  Get the caller details for the debug-info. This is where errors should be
  reported.
  
  =item $pkg = $trace->package
  
  Get the debug-info package.
  
  =item $file = $trace->file
  
  Get the debug-info filename.
  
  =item $line = $trace->line
  
  Get the debug-info line number.
  
  =item $subname = $trace->subname
  
  Get the debug-info subroutine name.
  
  =item $sig = trace->signature
  
  Get a signature string that identifies this trace. This is used to check if
  multiple events are related. The signature includes pid, tid, file, line
  number, and the cid.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_EVENTFACET_TRACE

$fatpacked{"Test2/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER';
  package Test2::Formatter;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  my %ADDED;
  sub import {
      my $class = shift;
      return if $class eq __PACKAGE__;
      return if $ADDED{$class}++;
      require Test2::API;
      Test2::API::test2_formatter_add($class);
  }
  
  sub new_root {
      my $class = shift;
      return $class->new(@_);
  }
  
  sub hide_buffered { 1 }
  
  sub terminate { }
  
  sub finalize { }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Formatter - Namespace for formatters.
  
  =head1 DESCRIPTION
  
  This is the namespace for formatters. This is an empty package.
  
  =head1 CREATING FORMATTERS
  
  A formatter is any package or object with a C<write($event, $num)> method.
  
      package Test2::Formatter::Foo;
      use strict;
      use warnings;
  
      sub write {
          my $self_or_class = shift;
          my ($event, $assert_num) = @_;
          ...
      }
  
      sub hide_buffered { 1 }
  
      sub terminate { }
  
      sub finalize { }
  
      sub new_root {
          my $class = shift;
          ...
          $class->new(@_);
      }
  
      1;
  
  The C<write> method is a method, so it either gets a class or instance. The two
  arguments are the C<$event> object it should record, and the C<$assert_num>
  which is the number of the current assertion (ok), or the last assertion if
  this event is not itself an assertion. The assertion number may be any integer 0
  or greater, and may be undefined in some cases.
  
  The C<hide_buffered()> method must return a boolean. This is used to tell
  buffered subtests whether or not to send it events as they are being buffered.
  See L<Test2::API/"run_subtest(...)"> for more information.
  
  The C<terminate> and C<finalize> methods are optional methods called that you
  can implement if the format you're generating needs to handle these cases, for
  example if you are generating XML and need close open tags.
  
  The C<terminate> method is called when an event's C<terminate> method returns
  true, for example when a L<Test2::Event::Plan> has a C<'skip_all'> plan, or
  when a L<Test2::Event::Bail> event is sent. The C<terminate> method is passed
  a single argument, the L<Test2::Event> object which triggered the terminate.
  
  The C<finalize> method is always the last thing called on the formatter, I<<
  except when C<terminate> is called for a Bail event >>. It is passed the
  following arguments:
  
  The C<new_root> method is called when C<Test2::API::Stack> Initializes the root
  hub for the first time. Most formatters will simply have this call C<<
  $class->new >>, which is the default behavior. Some formatters however may want
  to take extra action during construction of the root formatter, this is where
  they can do that.
  
  =over 4
  
  =item * The number of tests that were planned
  
  =item * The number of tests actually seen
  
  =item * The number of tests which failed
  
  =item * A boolean indicating whether or not the test suite passed
  
  =item * A boolean indicating whether or not this call is for a subtest
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_FORMATTER

$fatpacked{"Test2/Formatter/TAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_FORMATTER_TAP';
  package Test2::Formatter::TAP;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Test2::Util qw/clone_io/;
  
  use Test2::Util::HashBase qw{
      no_numbers handles _encoding _last_fh
      -made_assertion
  };
  
  sub OUT_STD() { 0 }
  sub OUT_ERR() { 1 }
  
  BEGIN { require Test2::Formatter; our @ISA = qw(Test2::Formatter) }
  
  sub _autoflush {
      my($fh) = pop;
      my $old_fh = select $fh;
      $| = 1;
      select $old_fh;
  }
  
  _autoflush(\*STDOUT);
  _autoflush(\*STDERR);
  
  sub hide_buffered { 1 }
  
  sub init {
      my $self = shift;
  
      $self->{+HANDLES} ||= $self->_open_handles;
      if(my $enc = delete $self->{encoding}) {
          $self->encoding($enc);
      }
  }
  
  sub _open_handles {
      my $self = shift;
  
      require Test2::API;
      my $out = clone_io(Test2::API::test2_stdout());
      my $err = clone_io(Test2::API::test2_stderr());
  
      _autoflush($out);
      _autoflush($err);
  
      return [$out, $err];
  }
  
  sub encoding {
      my $self = shift;
  
      if ($] ge "5.007003" and @_) {
          my ($enc) = @_;
          my $handles = $self->{+HANDLES};
  
          # https://rt.perl.org/Public/Bug/Display.html?id=31923
          # If utf8 is requested we use ':utf8' instead of ':encoding(utf8)' in
          # order to avoid the thread segfault.
          if ($enc =~ m/^utf-?8$/i) {
              binmode($_, ":utf8") for @$handles;
          }
          else {
              binmode($_, ":encoding($enc)") for @$handles;
          }
          $self->{+_ENCODING} = $enc;
      }
  
      return $self->{+_ENCODING};
  }
  
  if ($^C) {
      no warnings 'redefine';
      *write = sub {};
  }
  sub write {
      my ($self, $e, $num, $f) = @_;
  
      # The most common case, a pass event with no amnesty and a normal name.
      return if $self->print_optimal_pass($e, $num);
  
      $f ||= $e->facet_data;
  
      $self->encoding($f->{control}->{encoding}) if $f->{control}->{encoding};
  
      my @tap = $self->event_tap($f, $num) or return;
  
      $self->{+MADE_ASSERTION} = 1 if $f->{assert};
  
      my $nesting = $f->{trace}->{nested} || 0;
      my $handles = $self->{+HANDLES};
      my $indent = '    ' x $nesting;
  
      # Local is expensive! Only do it if we really need to.
      local($\, $,) = (undef, '') if $\ || $,;
      for my $set (@tap) {
          no warnings 'uninitialized';
          my ($hid, $msg) = @$set;
          next unless $msg;
          my $io = $handles->[$hid] or next;
  
          print $io "\n"
              if $ENV{HARNESS_ACTIVE}
              && !$ENV{HARNESS_IS_VERBOSE}
              && $hid == OUT_ERR
              && $self->{+_LAST_FH} != $io
              && $msg =~ m/^#\s*Failed test /;
  
          $msg =~ s/^/$indent/mg if $nesting;
          print $io $msg;
          $self->{+_LAST_FH} = $io;
      }
  }
  
  sub print_optimal_pass {
      my ($self, $e, $num) = @_;
  
      my $type = ref($e);
  
      # Only optimal if this is a Pass or a passing Ok
      return unless $type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass});
  
      # Amnesty requires further processing (todo is a form of amnesty)
      return if ($e->{amnesty} && @{$e->{amnesty}}) || defined($e->{todo});
  
      # A name with a newline or hash symbol needs extra processing
      return if defined($e->{name}) && (-1 != index($e->{name}, "\n") || -1 != index($e->{name}, '#'));
  
      my $ok = 'ok';
      $ok .= " $num" if $num && !$self->{+NO_NUMBERS};
      $ok .= defined($e->{name}) ? " - $e->{name}\n" : "\n";
  
      if (my $nesting = $e->{trace}->{nested}) {
          my $indent = '    ' x $nesting;
          $ok = "$indent$ok";
      }
  
      my $io = $self->{+HANDLES}->[OUT_STD];
  
      local($\, $,) = (undef, '') if $\ || $,;
      print $io $ok;
      $self->{+_LAST_FH} = $io;
  
      return 1;
  }
  
  sub event_tap {
      my ($self, $f, $num) = @_;
  
      my @tap;
  
      # If this IS the first event the plan should come first
      # (plan must be before or after assertions, not in the middle)
      push @tap => $self->plan_tap($f) if $f->{plan} && !$self->{+MADE_ASSERTION};
  
      # The assertion is most important, if present.
      if ($f->{assert}) {
          push @tap => $self->assert_tap($f, $num);
          push @tap => $self->debug_tap($f, $num) unless $f->{assert}->{no_debug} || $f->{assert}->{pass};
      }
  
      # Almost as important as an assertion
      push @tap => $self->error_tap($f) if $f->{errors};
  
      # Now lets see the diagnostics messages
      push @tap => $self->info_tap($f) if $f->{info};
  
      # If this IS NOT the first event the plan should come last
      # (plan must be before or after assertions, not in the middle)
      push @tap => $self->plan_tap($f) if $self->{+MADE_ASSERTION} && $f->{plan};
  
      # Bail out
      push @tap => $self->halt_tap($f) if $f->{control}->{halt};
  
      return @tap if @tap;
      return @tap if $f->{control}->{halt};
      return @tap if grep { $f->{$_} } qw/assert plan info errors/;
  
      # Use the summary as a fallback if nothing else is usable.
      return $self->summary_tap($f, $num);
  }
  
  sub error_tap {
      my $self = shift;
      my ($f) = @_;
  
      my $IO = ($f->{amnesty} && @{$f->{amnesty}}) ? OUT_STD : OUT_ERR;
  
      return map {
          my $details = $_->{details};
  
          my $msg;
          if (ref($details)) {
              require Data::Dumper;
              my $dumper = Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);
              chomp($msg = $dumper->Dump);
          }
          else {
              chomp($msg = $details);
              $msg =~ s/^/# /;
              $msg =~ s/\n/\n# /g;
          }
  
          [$IO, "$msg\n"];
      } @{$f->{errors}};
  }
  
  sub plan_tap {
      my $self = shift;
      my ($f) = @_;
      my $plan = $f->{plan} or return;
  
      return if $plan->{none};
  
      if ($plan->{skip}) {
          my $reason = $plan->{details} or return [OUT_STD, "1..0 # SKIP\n"];
          chomp($reason);
          return [OUT_STD, '1..0 # SKIP ' . $reason . "\n"];
      }
  
      return [OUT_STD, "1.." . $plan->{count} . "\n"];
  }
  
  sub no_subtest_space { 0 }
  sub assert_tap {
      my $self = shift;
      my ($f, $num) = @_;
  
      my $assert = $f->{assert} or return;
      my $pass = $assert->{pass};
      my $name = $assert->{details};
  
      my $ok = $pass ? 'ok' : 'not ok';
      $ok .= " $num" if $num && !$self->{+NO_NUMBERS};
  
      # The regex form is ~250ms, the index form is ~50ms
      my @extra;
      defined($name) && (
          (index($name, "\n") != -1 && (($name, @extra) = split(/\n\r?/, $name, -1))),
          ((index($name, "#" ) != -1  || substr($name, -1) eq '\\') && (($name =~ s|\\|\\\\|g), ($name =~ s|#|\\#|g)))
      );
  
      my $extra_space = @extra ? ' ' x (length($ok) + 2) : '';
      my $extra_indent = '';
  
      my ($directives, $reason, $is_skip);
      if ($f->{amnesty}) {
          my %directives;
  
          for my $am (@{$f->{amnesty}}) {
              next if $am->{inherited};
              my $tag = $am->{tag} or next;
              $is_skip = 1 if $tag eq 'skip';
  
              $directives{$tag} ||= $am->{details};
          }
  
          my %seen;
          my @order = grep { !$seen{$_}++ } sort keys %directives;
  
          $directives = ' # ' . join ' & ' => @order;
  
          for my $tag ('skip', @order) {
              next unless defined($directives{$tag}) && length($directives{$tag});
              $reason = $directives{$tag};
              last;
          }
      }
  
      $ok .= " - $name" if defined $name && !($is_skip && !$name);
  
      my @subtap;
      if ($f->{parent} && $f->{parent}->{buffered}) {
          $ok .= ' {';
  
          # In a verbose harness we indent the extra since they will appear
          # inside the subtest braces. This helps readability. In a non-verbose
          # harness we do not do this because it is less readable.
          if ($ENV{HARNESS_IS_VERBOSE} || !$ENV{HARNESS_ACTIVE}) {
              $extra_indent = "    ";
              $extra_space = ' ';
          }
  
          # Render the sub-events, we use our own counter for these.
          my $count = 0;
          @subtap = map {
              my $f2 = $_;
  
              # Bump the count for any event that should bump it.
              $count++ if $f2->{assert};
  
              # This indents all output lines generated for the sub-events.
              # index 0 is the filehandle, index 1 is the message we want to indent.
              map { $_->[1] =~ s/^(.*\S.*)$/    $1/mg; $_ } $self->event_tap($f2, $count);
          } @{$f->{parent}->{children}};
  
          push @subtap => [OUT_STD, "}\n"];
      }
  
      if ($directives) {
          $directives = ' # TODO & SKIP' if $directives eq ' # TODO & skip';
          $ok .= $directives;
          $ok .= " $reason" if defined($reason);
      }
  
      $extra_space = ' ' if $self->no_subtest_space;
  
      my @out = ([OUT_STD, "$ok\n"]);
      push @out => map {[OUT_STD, "${extra_indent}#${extra_space}$_\n"]} @extra if @extra;
      push @out => @subtap;
  
      return @out;
  }
  
  sub debug_tap {
      my ($self, $f, $num) = @_;
  
      # Figure out the debug info, this is typically the file name and line
      # number, but can also be a custom message. If no trace object is provided
      # then we have nothing useful to display.
      my $name  = $f->{assert}->{details};
      my $trace = $f->{trace};
  
      my $debug = "[No trace info available]";
      if ($trace->{details}) {
          $debug = $trace->{details};
      }
      elsif ($trace->{frame}) {
          my ($pkg, $file, $line) = @{$trace->{frame}};
          $debug = "at $file line $line." if $file && $line;
      }
  
      my $amnesty = $f->{amnesty} && @{$f->{amnesty}}
          ? ' (with amnesty)'
          : '';
  
      # Create the initial diagnostics. If the test has a name we put the debug
      # info on a second line, this behavior is inherited from Test::Builder.
      my $msg = defined($name)
          ? qq[# Failed test${amnesty} '$name'\n# $debug\n]
          : qq[# Failed test${amnesty} $debug\n];
  
      my $IO = $f->{amnesty} && @{$f->{amnesty}} ? OUT_STD : OUT_ERR;
  
      return [$IO, $msg];
  }
  
  sub halt_tap {
      my ($self, $f) = @_;
  
      return if $f->{trace}->{nested} && !$f->{trace}->{buffered};
      my $details = $f->{control}->{details};
  
      return [OUT_STD, "Bail out!\n"] unless defined($details) && length($details);
      return [OUT_STD, "Bail out!  $details\n"];
  }
  
  sub info_tap {
      my ($self, $f) = @_;
  
      return map {
          my $details = $_->{details};
  
          my $IO = $_->{debug} && !($f->{amnesty} && @{$f->{amnesty}}) ? OUT_ERR : OUT_STD;
  
          my $msg;
          if (ref($details)) {
              require Data::Dumper;
              my $dumper = Data::Dumper->new([$details])->Indent(2)->Terse(1)->Pad('# ')->Useqq(1)->Sortkeys(1);
              chomp($msg = $dumper->Dump);
          }
          else {
              chomp($msg = $details);
              $msg =~ s/^/# /;
              $msg =~ s/\n/\n# /g;
          }
  
          [$IO, "$msg\n"];
      } @{$f->{info}};
  }
  
  sub summary_tap {
      my ($self, $f, $num) = @_;
  
      return if $f->{about}->{no_display};
  
      my $summary = $f->{about}->{details} or return;
      chomp($summary);
      $summary =~ s/^/# /smg;
  
      return [OUT_STD, "$summary\n"];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Formatter::TAP - Standard TAP formatter
  
  =head1 DESCRIPTION
  
  This is what takes events and turns them into TAP.
  
  =head1 SYNOPSIS
  
      use Test2::Formatter::TAP;
      my $tap = Test2::Formatter::TAP->new();
  
      # Switch to utf8
      $tap->encoding('utf8');
  
      $tap->write($event, $number); # Output an event
  
  =head1 METHODS
  
  =over 4
  
  =item $bool = $tap->no_numbers
  
  =item $tap->set_no_numbers($bool)
  
  Use to turn numbers on and off.
  
  =item $arrayref = $tap->handles
  
  =item $tap->set_handles(\@handles);
  
  Can be used to get/set the filehandles. Indexes are identified by the
  C<OUT_STD> and C<OUT_ERR> constants.
  
  =item $encoding = $tap->encoding
  
  =item $tap->encoding($encoding)
  
  Get or set the encoding. By default no encoding is set, the original settings
  of STDOUT and STDERR are used.
  
  This directly modifies the stored filehandles, it does not create new ones.
  
  =item $tap->write($e, $num)
  
  Write an event to the console.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_FORMATTER_TAP

$fatpacked{"Test2/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB';
  package Test2::Hub;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/carp croak confess/;
  use Test2::Util qw/get_tid gen_uid/;
  
  use Scalar::Util qw/weaken/;
  use List::Util qw/first/;
  
  use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  use Test2::Util::HashBase qw{
      pid tid hid ipc
      nested buffered
      no_ending
      _filters
      _pre_filters
      _listeners
      _follow_ups
      _formatter
      _context_acquire
      _context_init
      _context_release
  
      uuid
      active
      count
      failed
      ended
      bailed_out
      _passing
      _plan
      skip_reason
  };
  
  my $UUID_VIA;
  
  sub init {
      my $self = shift;
  
      $self->{+PID} = $$;
      $self->{+TID} = get_tid();
      $self->{+HID} = gen_uid();
  
      $UUID_VIA ||= Test2::API::_add_uuid_via_ref();
      $self->{+UUID} = ${$UUID_VIA}->('hub') if $$UUID_VIA;
  
      $self->{+NESTED}   = 0 unless defined $self->{+NESTED};
      $self->{+BUFFERED} = 0 unless defined $self->{+BUFFERED};
  
      $self->{+COUNT}    = 0;
      $self->{+FAILED}   = 0;
      $self->{+_PASSING} = 1;
  
      if (my $formatter = delete $self->{formatter}) {
          $self->format($formatter);
      }
  
      if (my $ipc = $self->{+IPC}) {
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub is_subtest { 0 }
  
  sub _tb_reset {
      my $self = shift;
  
      # Nothing to do
      return if $self->{+PID} == $$ && $self->{+TID} == get_tid();
  
      $self->{+PID} = $$;
      $self->{+TID} = get_tid();
      $self->{+HID} = gen_uid();
  
      if (my $ipc = $self->{+IPC}) {
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub reset_state {
      my $self = shift;
  
      $self->{+COUNT} = 0;
      $self->{+FAILED} = 0;
      $self->{+_PASSING} = 1;
  
      delete $self->{+_PLAN};
      delete $self->{+ENDED};
      delete $self->{+BAILED_OUT};
      delete $self->{+SKIP_REASON};
  }
  
  sub inherit {
      my $self = shift;
      my ($from, %params) = @_;
  
      $self->{+NESTED} ||= 0;
  
      $self->{+_FORMATTER} = $from->{+_FORMATTER}
          unless $self->{+_FORMATTER} || exists($params{formatter});
  
      if ($from->{+IPC} && !$self->{+IPC} && !exists($params{ipc})) {
          my $ipc = $from->{+IPC};
          $self->{+IPC} = $ipc;
          $ipc->add_hub($self->{+HID});
      }
  
      if (my $ls = $from->{+_LISTENERS}) {
          push @{$self->{+_LISTENERS}} => grep { $_->{inherit} } @$ls;
      }
  
      if (my $pfs = $from->{+_PRE_FILTERS}) {
          push @{$self->{+_PRE_FILTERS}} => grep { $_->{inherit} } @$pfs;
      }
  
      if (my $fs = $from->{+_FILTERS}) {
          push @{$self->{+_FILTERS}} => grep { $_->{inherit} } @$fs;
      }
  }
  
  sub format {
      my $self = shift;
  
      my $old = $self->{+_FORMATTER};
      ($self->{+_FORMATTER}) = @_ if @_;
  
      return $old;
  }
  
  sub is_local {
      my $self = shift;
      return $$ == $self->{+PID}
          && get_tid() == $self->{+TID};
  }
  
  sub listen {
      my $self = shift;
      my ($sub, %params) = @_;
  
      carp "Useless addition of a listener in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "listen only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_LISTENERS}} => { %params, code => $sub };
  
      $sub; # Intentional return.
  }
  
  sub unlisten {
      my $self = shift;
  
      carp "Useless removal of a listener in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      my %subs = map {$_ => $_} @_;
  
      @{$self->{+_LISTENERS}} = grep { !$subs{$_->{code}} } @{$self->{+_LISTENERS}};
  }
  
  sub filter {
      my $self = shift;
      my ($sub, %params) = @_;
  
      carp "Useless addition of a filter in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "filter only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_FILTERS}} => { %params, code => $sub };
  
      $sub; # Intentional Return
  }
  
  sub unfilter {
      my $self = shift;
      carp "Useless removal of a filter in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
      my %subs = map {$_ => $_} @_;
      @{$self->{+_FILTERS}} = grep { !$subs{$_->{code}} } @{$self->{+_FILTERS}};
  }
  
  sub pre_filter {
      my $self = shift;
      my ($sub, %params) = @_;
  
      croak "pre_filter only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_PRE_FILTERS}} => { %params, code => $sub };
  
      $sub; # Intentional Return
  }
  
  sub pre_unfilter {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_PRE_FILTERS}} = grep { !$subs{$_->{code}} } @{$self->{+_PRE_FILTERS}};
  }
  
  sub follow_up {
      my $self = shift;
      my ($sub) = @_;
  
      carp "Useless addition of a follow-up in a child process or thread!"
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      croak "follow_up only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_FOLLOW_UPS}} => $sub;
  }
  
  *add_context_aquire = \&add_context_acquire;
  sub add_context_acquire {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_acquire only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_ACQUIRE}} => $sub;
  
      $sub; # Intentional return.
  }
  
  *remove_context_aquire = \&remove_context_acquire;
  sub remove_context_acquire {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_ACQUIRE}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_ACQUIRE}};
  }
  
  sub add_context_init {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_init only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_INIT}} => $sub;
  
      $sub; # Intentional return.
  }
  
  sub remove_context_init {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_INIT}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_INIT}};
  }
  
  sub add_context_release {
      my $self = shift;
      my ($sub) = @_;
  
      croak "add_context_release only takes coderefs for arguments, got '$sub'"
          unless ref $sub && ref $sub eq 'CODE';
  
      push @{$self->{+_CONTEXT_RELEASE}} => $sub;
  
      $sub; # Intentional return.
  }
  
  sub remove_context_release {
      my $self = shift;
      my %subs = map {$_ => $_} @_;
      @{$self->{+_CONTEXT_RELEASE}} = grep { !$subs{$_} == $_ } @{$self->{+_CONTEXT_RELEASE}};
  }
  
  sub send {
      my $self = shift;
      my ($e) = @_;
  
      $e->eid;
  
      $e->add_hub(
          {
              details => ref($self),
  
              buffered => $self->{+BUFFERED},
              hid      => $self->{+HID},
              nested   => $self->{+NESTED},
              pid      => $self->{+PID},
              tid      => $self->{+TID},
              uuid     => $self->{+UUID},
  
              ipc => $self->{+IPC} ? 1 : 0,
          }
      );
  
      $e->set_uuid(${$UUID_VIA}->('event')) if $$UUID_VIA;
  
      if ($self->{+_PRE_FILTERS}) {
          for (@{$self->{+_PRE_FILTERS}}) {
              $e = $_->{code}->($self, $e);
              return unless $e;
          }
      }
  
      my $ipc = $self->{+IPC} || return $self->process($e);
  
      if($e->global) {
          $ipc->send($self->{+HID}, $e, 'GLOBAL');
          return $self->process($e);
      }
  
      return $ipc->send($self->{+HID}, $e)
          if $$ != $self->{+PID} || get_tid() != $self->{+TID};
  
      $self->process($e);
  }
  
  sub process {
      my $self = shift;
      my ($e) = @_;
  
      if ($self->{+_FILTERS}) {
          for (@{$self->{+_FILTERS}}) {
              $e = $_->{code}->($self, $e);
              return unless $e;
          }
      }
  
      # Optimize the most common case
      my $type = ref($e);
      if ($type eq 'Test2::Event::Pass' || ($type eq 'Test2::Event::Ok' && $e->{pass})) {
          my $count = ++($self->{+COUNT});
          $self->{+_FORMATTER}->write($e, $count) if $self->{+_FORMATTER};
  
          if ($self->{+_LISTENERS}) {
              $_->{code}->($self, $e, $count) for @{$self->{+_LISTENERS}};
          }
  
          return $e;
      }
  
      my $f = $e->facet_data;
  
      my $fail = 0;
      $fail = 1 if $f->{assert} && !$f->{assert}->{pass};
      $fail = 1 if $f->{errors} && grep { $_->{fail} } @{$f->{errors}};
      $fail = 0 if $f->{amnesty};
  
      $self->{+COUNT}++ if $f->{assert};
      $self->{+FAILED}++ if $fail && $f->{assert};
      $self->{+_PASSING} = 0 if $fail;
  
      my $code = $f->{control}->{terminate};
      my $count = $self->{+COUNT};
  
      if (my $plan = $f->{plan}) {
          if ($plan->{skip}) {
              $self->plan('SKIP');
              $self->set_skip_reason($plan->{details} || 1);
              $code ||= 0;
          }
          elsif ($plan->{none}) {
              $self->plan('NO PLAN');
          }
          else {
              $self->plan($plan->{count});
          }
      }
  
      $e->callback($self) if $f->{control}->{has_callback};
  
      $self->{+_FORMATTER}->write($e, $count, $f) if $self->{+_FORMATTER};
  
      if ($self->{+_LISTENERS}) {
          $_->{code}->($self, $e, $count, $f) for @{$self->{+_LISTENERS}};
      }
  
      if ($f->{control}->{halt}) {
          $code ||= 255;
          $self->set_bailed_out($e);
      }
  
      if (defined $code) {
          $self->{+_FORMATTER}->terminate($e, $f) if $self->{+_FORMATTER};
          $self->terminate($code, $e, $f);
      }
  
      return $e;
  }
  
  sub terminate {
      my $self = shift;
      my ($code) = @_;
      exit($code);
  }
  
  sub cull {
      my $self = shift;
  
      my $ipc = $self->{+IPC} || return;
      return if $self->{+PID} != $$ || $self->{+TID} != get_tid();
  
      # No need to do IPC checks on culled events
      $self->process($_) for $ipc->cull($self->{+HID});
  }
  
  sub finalize {
      my $self = shift;
      my ($trace, $do_plan) = @_;
  
      $self->cull();
  
      my $plan   = $self->{+_PLAN};
      my $count  = $self->{+COUNT};
      my $failed = $self->{+FAILED};
      my $active = $self->{+ACTIVE};
  
      # return if NOTHING was done.
      unless ($active || $do_plan || defined($plan) || $count || $failed) {
          $self->{+_FORMATTER}->finalize($plan, $count, $failed, 0, $self->is_subtest) if $self->{+_FORMATTER};
          return;
      }
  
      unless ($self->{+ENDED}) {
          if ($self->{+_FOLLOW_UPS}) {
              $_->($trace, $self) for reverse @{$self->{+_FOLLOW_UPS}};
          }
  
          # These need to be refreshed now
          $plan   = $self->{+_PLAN};
          $count  = $self->{+COUNT};
          $failed = $self->{+FAILED};
  
          if (($plan && $plan eq 'NO PLAN') || ($do_plan && !$plan)) {
              $self->send(
                  Test2::Event::Plan->new(
                      trace => $trace,
                      max => $count,
                  )
              );
          }
          $plan = $self->{+_PLAN};
      }
  
      my $frame = $trace->frame;
      if($self->{+ENDED}) {
          my (undef, $ffile, $fline) = @{$self->{+ENDED}};
          my (undef, $sfile, $sline) = @$frame;
  
          die <<"        EOT"
  Test already ended!
  First End:  $ffile line $fline
  Second End: $sfile line $sline
          EOT
      }
  
      $self->{+ENDED} = $frame;
      my $pass = $self->is_passing(); # Generate the final boolean.
  
      $self->{+_FORMATTER}->finalize($plan, $count, $failed, $pass, $self->is_subtest) if $self->{+_FORMATTER};
  
      return $pass;
  }
  
  sub is_passing {
      my $self = shift;
  
      ($self->{+_PASSING}) = @_ if @_;
  
      # If we already failed just return 0.
      my $pass = $self->{+_PASSING} or return 0;
      return $self->{+_PASSING} = 0 if $self->{+FAILED};
  
      my $count = $self->{+COUNT};
      my $ended = $self->{+ENDED};
      my $plan = $self->{+_PLAN};
  
      return $pass if !$count && $plan && $plan =~ m/^SKIP$/;
  
      return $self->{+_PASSING} = 0
          if $ended && (!$count || !$plan);
  
      return $pass unless $plan && $plan =~ m/^\d+$/;
  
      if ($ended) {
          return $self->{+_PASSING} = 0 if $count != $plan;
      }
      else {
          return $self->{+_PASSING} = 0 if $count > $plan;
      }
  
      return $pass;
  }
  
  sub plan {
      my $self = shift;
  
      return $self->{+_PLAN} unless @_;
  
      my ($plan) = @_;
  
      confess "You cannot unset the plan"
          unless defined $plan;
  
      confess "You cannot change the plan"
          if $self->{+_PLAN} && $self->{+_PLAN} !~ m/^NO PLAN$/;
  
      confess "'$plan' is not a valid plan! Plan must be an integer greater than 0, 'NO PLAN', or 'SKIP'"
          unless $plan =~ m/^(\d+|NO PLAN|SKIP)$/;
  
      $self->{+_PLAN} = $plan;
  }
  
  sub check_plan {
      my $self = shift;
  
      return undef unless $self->{+ENDED};
      my $plan = $self->{+_PLAN} || return undef;
  
      return 1 if $plan !~ m/^\d+$/;
  
      return 1 if $plan == $self->{+COUNT};
      return 0;
  }
  
  sub DESTROY {
      my $self = shift;
      my $ipc = $self->{+IPC} || return;
      return unless $$ == $self->{+PID};
      return unless get_tid() == $self->{+TID};
      $ipc->drop_hub($self->{+HID});
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub - The conduit through which all events flow.
  
  =head1 SYNOPSIS
  
      use Test2::Hub;
  
      my $hub = Test2::Hub->new();
      $hub->send(...);
  
  =head1 DESCRIPTION
  
  The hub is the place where all events get processed and handed off to the
  formatter. The hub also tracks test state, and provides several hooks into the
  event pipeline.
  
  =head1 COMMON TASKS
  
  =head2 SENDING EVENTS
  
      $hub->send($event)
  
  The C<send()> method is used to issue an event to the hub. This method will
  handle thread/fork sync, filters, listeners, TAP output, etc.
  
  =head2 ALTERING OR REMOVING EVENTS
  
  You can use either C<filter()> or C<pre_filter()>, depending on your
  needs. Both have identical syntax, so only C<filter()> is shown here.
  
      $hub->filter(sub {
          my ($hub, $event) = @_;
  
          my $action = get_action($event);
  
          # No action should be taken
          return $event if $action eq 'none';
  
          # You want your filter to remove the event
          return undef if $action eq 'delete';
  
          if ($action eq 'do_it') {
              my $new_event = copy_event($event);
              ... Change your copy of the event ...
              return $new_event;
          }
  
          die "Should not happen";
      });
  
  By default, filters are not inherited by child hubs. That means if you start a
  subtest, the subtest will not inherit the filter. You can change this behavior
  with the C<inherit> parameter:
  
      $hub->filter(sub { ... }, inherit => 1);
  
  =head2 LISTENING FOR EVENTS
  
      $hub->listen(sub {
          my ($hub, $event, $number) = @_;
  
          ... do whatever you want with the event ...
  
          # return is ignored
      });
  
  By default listeners are not inherited by child hubs. That means if you start a
  subtest, the subtest will not inherit the listener. You can change this behavior
  with the C<inherit> parameter:
  
      $hub->listen(sub { ... }, inherit => 1);
  
  
  =head2 POST-TEST BEHAVIORS
  
      $hub->follow_up(sub {
          my ($trace, $hub) = @_;
  
          ... do whatever you need to ...
  
          # Return is ignored
      });
  
  follow_up subs are called only once, either when done_testing is called, or in
  an END block.
  
  =head2 SETTING THE FORMATTER
  
  By default an instance of L<Test2::Formatter::TAP> is created and used.
  
      my $old = $hub->format(My::Formatter->new);
  
  Setting the formatter will REPLACE any existing formatter. You may set the
  formatter to undef to prevent output. The old formatter will be returned if one
  was already set. Only one formatter is allowed at a time.
  
  =head1 METHODS
  
  =over 4
  
  =item $hub->send($event)
  
  This is where all events enter the hub for processing.
  
  =item $hub->process($event)
  
  This is called by send after it does any IPC handling. You can use this to
  bypass the IPC process, but in general you should avoid using this.
  
  =item $old = $hub->format($formatter)
  
  Replace the existing formatter instance with a new one. Formatters must be
  objects that implement a C<< $formatter->write($event) >> method.
  
  =item $sub = $hub->listen(sub { ... }, %optional_params)
  
  You can use this to record all events AFTER they have been sent to the
  formatter. No changes made here will be meaningful, except possibly to other
  listeners.
  
      $hub->listen(sub {
          my ($hub, $event, $number) = @_;
  
          ... do whatever you want with the event ...
  
          # return is ignored
      });
  
  Normally listeners are not inherited by child hubs such as subtests. You can
  add the C<< inherit => 1 >> parameter to allow a listener to be inherited.
  
  =item $hub->unlisten($sub)
  
  You can use this to remove a listen callback. You must pass in the coderef
  returned by the C<listen()> method.
  
  =item $sub = $hub->filter(sub { ... }, %optional_params)
  
  =item $sub = $hub->pre_filter(sub { ... }, %optional_params)
  
  These can be used to add filters. Filters can modify, replace, or remove events
  before anything else can see them.
  
      $hub->filter(
          sub {
              my ($hub, $event) = @_;
  
              return $event;    # No Changes
              return;           # Remove the event
  
              # Or you can modify an event before returning it.
              $event->modify;
              return $event;
          }
      );
  
  If you are not using threads, forking, or IPC then the only difference between
  a C<filter> and a C<pre_filter> is that C<pre_filter> subs run first. When you
  are using threads, forking, or IPC, pre_filters happen to events before they
  are sent to their destination proc/thread, ordinary filters happen only in the
  destination hub/thread.
  
  You cannot add a regular filter to a hub if the hub was created in another
  process or thread. You can always add a pre_filter.
  
  =item $hub->unfilter($sub)
  
  =item $hub->pre_unfilter($sub)
  
  These can be used to remove filters and pre_filters. The C<$sub> argument is
  the reference returned by C<filter()> or C<pre_filter()>.
  
  =item $hub->follow_op(sub { ... })
  
  Use this to add behaviors that are called just before the hub is finalized. The
  only argument to your codeblock will be a L<Test2::EventFacet::Trace> instance.
  
      $hub->follow_up(sub {
          my ($trace, $hub) = @_;
  
          ... do whatever you need to ...
  
          # Return is ignored
      });
  
  follow_up subs are called only once, ether when done_testing is called, or in
  an END block.
  
  =item $sub = $hub->add_context_acquire(sub { ... });
  
  Add a callback that will be called every time someone tries to acquire a
  context. It gets a single argument, a reference of the hash of parameters
  being used the construct the context. This is your chance to change the
  parameters by directly altering the hash.
  
      test2_add_callback_context_acquire(sub {
          my $params = shift;
          $params->{level}++;
      });
  
  This is a very scary API function. Please do not use this unless you need to.
  This is here for L<Test::Builder> and backwards compatibility. This has you
  directly manipulate the hash instead of returning a new one for performance
  reasons.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_acquire($sub);
  
  This can be used to remove a context acquire hook.
  
  =item $sub = $hub->add_context_init(sub { ... });
  
  This allows you to add callbacks that will trigger every time a new context is
  created for the hub. The only argument to the sub will be the
  L<Test2::API::Context> instance that was created.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_init($sub);
  
  This can be used to remove a context init hook.
  
  =item $sub = $hub->add_context_release(sub { ... });
  
  This allows you to add callbacks that will trigger every time a context for
  this hub is released. The only argument to the sub will be the
  L<Test2::API::Context> instance that was released. These will run in reverse
  order.
  
  B<Note> Using this hook could have a huge performance impact.
  
  The coderef you provide is returned and can be used to remove the hook later.
  
  =item $hub->remove_context_release($sub);
  
  This can be used to remove a context release hook.
  
  =item $hub->cull()
  
  Cull any IPC events (and process them).
  
  =item $pid = $hub->pid()
  
  Get the process id under which the hub was created.
  
  =item $tid = $hub->tid()
  
  Get the thread id under which the hub was created.
  
  =item $hud = $hub->hid()
  
  Get the identifier string of the hub.
  
  =item $uuid = $hub->uuid()
  
  If UUID tagging is enabled (see L<Test2::API>) then the hub will have a UUID.
  
  =item $ipc = $hub->ipc()
  
  Get the IPC object used by the hub.
  
  =item $hub->set_no_ending($bool)
  
  =item $bool = $hub->no_ending
  
  This can be used to disable auto-ending behavior for a hub. The auto-ending
  behavior is triggered by an end block and is used to cull IPC events, and
  output the final plan if the plan was 'no_plan'.
  
  =item $bool = $hub->active
  
  =item $hub->set_active($bool)
  
  These are used to get/set the 'active' attribute. When true this attribute will
  force C<< hub->finalize() >> to take action even if there is no plan, and no
  tests have been run. This flag is useful for plugins that add follow-up
  behaviors that need to run even if no events are seen.
  
  =back
  
  =head2 STATE METHODS
  
  =over 4
  
  =item $hub->reset_state()
  
  Reset all state to the start. This sets the test count to 0, clears the plan,
  removes the failures, etc.
  
  =item $num = $hub->count
  
  Get the number of tests that have been run.
  
  =item $num = $hub->failed
  
  Get the number of failures (Not all failures come from a test fail, so this
  number can be larger than the count).
  
  =item $bool = $hub->ended
  
  True if the testing has ended. This MAY return the stack frame of the tool that
  ended the test, but that is not guaranteed.
  
  =item $bool = $hub->is_passing
  
  =item $hub->is_passing($bool)
  
  Check if the overall test run is a failure. Can also be used to set the
  pass/fail status.
  
  =item $hub->plan($plan)
  
  =item $plan = $hub->plan
  
  Get or set the plan. The plan must be an integer larger than 0, the string
  'no_plan', or the string 'skip_all'.
  
  =item $bool = $hub->check_plan
  
  Check if the plan and counts match, but only if the tests have ended. If tests
  have not ended this will return undef, otherwise it will be a true/false.
  
  =back
  
  =head1 THIRD PARTY META-DATA
  
  This object consumes L<Test2::Util::ExternalMeta> which provides a consistent
  way for you to attach meta-data to instances of this class. This is useful for
  tools, plugins, and other extensions.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB

$fatpacked{"Test2/Hub/Interceptor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR';
  package Test2::Hub::Interceptor;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::Hub::Interceptor::Terminator();
  
  BEGIN { require Test2::Hub; our @ISA = qw(Test2::Hub) }
  use Test2::Util::HashBase;
  
  sub init {
      my $self = shift;
      $self->SUPER::init();
      $self->{+NESTED} = 0;
  }
  
  sub inherit {
      my $self = shift;
      my ($from, %params) = @_;
  
      $self->{+NESTED} = 0;
  
      if ($from->{+IPC} && !$self->{+IPC} && !exists($params{ipc})) {
          my $ipc = $from->{+IPC};
          $self->{+IPC} = $ipc;
          $ipc->add_hub($self->{+HID});
      }
  }
  
  sub terminate {
      my $self = shift;
      my ($code) = @_;
  
      eval {
          no warnings 'exiting';
          last T2_SUBTEST_WRAPPER;
      };
      my $err = $@;
  
      # Fallback
      die bless(\$err, 'Test2::Hub::Interceptor::Terminator');
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Interceptor - Hub used by interceptor to grab results.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_INTERCEPTOR

$fatpacked{"Test2/Hub/Interceptor/Terminator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_INTERCEPTOR_TERMINATOR';
  package Test2::Hub::Interceptor::Terminator;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Interceptor::Terminator - Exception class used by
  Test2::Hub::Interceptor
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_INTERCEPTOR_TERMINATOR

$fatpacked{"Test2/Hub/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_HUB_SUBTEST';
  package Test2::Hub::Subtest;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  BEGIN { require Test2::Hub; our @ISA = qw(Test2::Hub) }
  use Test2::Util::HashBase qw/nested exit_code manual_skip_all/;
  use Test2::Util qw/get_tid/;
  
  sub is_subtest { 1 }
  
  sub inherit {
      my $self = shift;
      my ($from) = @_;
  
      $self->SUPER::inherit($from);
  
      $self->{+NESTED} = $from->nested + 1;
  }
  
  {
      # Legacy
      no warnings 'once';
      *ID = \&Test2::Hub::HID;
      *id = \&Test2::Hub::hid;
      *set_id = \&Test2::Hub::set_hid;
  }
  
  sub send {
      my $self = shift;
      my ($e) = @_;
  
      my $out = $self->SUPER::send($e);
  
      return $out if $self->{+MANUAL_SKIP_ALL};
  
      my $f = $e->facet_data;
  
      my $plan = $f->{plan} or return $out;
      return $out unless $plan->{skip};
  
      my $trace = $f->{trace} or die "Missing Trace!";
      return $out unless $trace->{pid} != $self->pid
                      || $trace->{tid} != $self->tid;
  
      no warnings 'exiting';
      last T2_SUBTEST_WRAPPER;
  }
  
  sub terminate {
      my $self = shift;
      my ($code, $e, $f) = @_;
      $self->set_exit_code($code);
  
      return if $self->{+MANUAL_SKIP_ALL};
  
      $f ||= $e->facet_data;
  
      if(my $plan = $f->{plan}) {
          my $trace = $f->{trace} or die "Missing Trace!";
          return if $plan->{skip}
                 && ($trace->{pid} != $$ || $trace->{tid} != get_tid);
      }
  
      no warnings 'exiting';
      last T2_SUBTEST_WRAPPER;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Hub::Subtest - Hub used by subtests
  
  =head1 DESCRIPTION
  
  Subtests make use of this hub to route events.
  
  =head1 TOGGLES
  
  =over 4
  
  =item $bool = $hub->manual_skip_all
  
  =item $hub->set_manual_skip_all($bool)
  
  The default is false.
  
  Normally a skip-all plan event will cause a subtest to stop executing. This is
  accomplished via C<last LABEL> to a label inside the subtest code. Most of the
  time this is perfectly fine. There are times however where this flow control
  causes bad things to happen.
  
  This toggle lets you turn off the abort logic for the hub. When this is toggled
  to true B<you> are responsible for ensuring no additional events are generated.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_HUB_SUBTEST

$fatpacked{"Test2/IPC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC';
  package Test2::IPC;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Test2::API::Instance;
  use Test2::Util qw/get_tid/;
  use Test2::API qw{
      test2_init_done
      test2_ipc
      test2_has_ipc
      test2_ipc_enable_polling
      test2_pid
      test2_stack
      test2_tid
      context
  };
  
  use Carp qw/confess/;
  
  our @EXPORT_OK = qw/cull/;
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub unimport { Test2::API::test2_ipc_disable() }
  
  sub import {
      goto &Exporter::import if test2_has_ipc || !test2_init_done();
  
      confess "IPC is disabled" if Test2::API::test2_ipc_disabled();
      confess "Cannot add IPC in a child process (" . test2_pid() . " vs $$)" if test2_pid() != $$;
      confess "Cannot add IPC in a child thread (" . test2_tid() . " vs " . get_tid() . ")"  if test2_tid() != get_tid();
  
      Test2::API::_set_ipc(_make_ipc());
      apply_ipc(test2_stack());
  
      goto &Exporter::import;
  }
  
  sub _make_ipc {
      # Find a driver
      my ($driver) = Test2::API::test2_ipc_drivers();
      unless ($driver) {
          require Test2::IPC::Driver::Files;
          $driver = 'Test2::IPC::Driver::Files';
      }
  
      return $driver->new();
  }
  
  sub apply_ipc {
      my $stack = shift;
  
      my ($root) = @$stack;
  
      return unless $root;
  
      confess "Cannot add IPC in a child process" if $root->pid != $$;
      confess "Cannot add IPC in a child thread"  if $root->tid != get_tid();
  
      my $ipc = $root->ipc || test2_ipc() || _make_ipc();
  
      # Add the IPC to all hubs
      for my $hub (@$stack) {
          my $has = $hub->ipc;
          confess "IPC Mismatch!" if $has && $has != $ipc;
          next if $has;
          $hub->set_ipc($ipc);
          $ipc->add_hub($hub->hid);
      }
  
      test2_ipc_enable_polling();
  
      return $ipc;
  }
  
  sub cull {
      my $ctx = context();
      $ctx->hub->cull;
      $ctx->release;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC - Turn on IPC for threading or forking support.
  
  =head1 SYNOPSIS
  
  You should C<use Test2::IPC;> as early as possible in your test file. If you
  import this module after API initialization it will attempt to retrofit IPC
  onto the existing hubs.
  
  =head2 DISABLING IT
  
  You can use C<no Test2::IPC;> to disable IPC for good. You can also use the
  T2_NO_IPC env var.
  
  =head1 EXPORTS
  
  All exports are optional.
  
  =over 4
  
  =item cull()
  
  Cull allows you to collect results from other processes or threads on demand.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC

$fatpacked{"Test2/IPC/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER';
  package Test2::IPC::Driver;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/confess/;
  use Test2::Util::HashBase qw{no_fatal no_bail};
  
  use Test2::API qw/test2_ipc_add_driver/;
  
  my %ADDED;
  sub import {
      my $class = shift;
      return if $class eq __PACKAGE__;
      return if $ADDED{$class}++;
      test2_ipc_add_driver($class);
  }
  
  sub use_shm { 0 }
  
  for my $meth (qw/send cull add_hub drop_hub waiting is_viable/) {
      no strict 'refs';
      *$meth = sub {
          my $thing = shift;
          confess "'$thing' did not define the required method '$meth'."
      };
  }
  
  # Print the error and call exit. We are not using 'die' cause this is a
  # catastrophic error that should never be caught. If we get here it
  # means some serious shit has happened in a child process, the only way
  # to inform the parent may be to exit false.
  
  sub abort {
      my $self = shift;
      chomp(my ($msg) = @_);
  
      $self->driver_abort($msg) if $self->can('driver_abort');
  
      print STDERR "IPC Fatal Error: $msg\n";
      print STDOUT "Bail out! IPC Fatal Error: $msg\n" unless $self->no_bail;
  
      CORE::exit(255) unless $self->no_fatal;
  }
  
  sub abort_trace {
      my $self = shift;
      my ($msg) = @_;
      # Older versions of Carp do not export longmess() function, so it needs to be called with package name
      $self->abort(Carp::longmess($msg));
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC::Driver - Base class for Test2 IPC drivers.
  
  =head1 SYNOPSIS
  
      package Test2::IPC::Driver::MyDriver;
  
      use base 'Test2::IPC::Driver';
  
      ...
  
  =head1 METHODS
  
  =over 4
  
  =item $self->abort($msg)
  
  If an IPC encounters a fatal error it should use this. This will print the
  message to STDERR with C<'IPC Fatal Error: '> prefixed to it, then it will
  forcefully exit 255. IPC errors may occur in threads or processes other than
  the main one, this method provides the best chance of the harness noticing the
  error.
  
  =item $self->abort_trace($msg)
  
  This is the same as C<< $ipc->abort($msg) >> except that it uses
  C<Carp::longmess> to add a stack trace to the message.
  
  =item $false = $self->use_shm
  
  The base class always returns false for this method. You may override it if you
  wish to use the SHM made available in L<Test2::API>/L<Test2::API::Instance>.
  
  =back
  
  =head1 LOADING DRIVERS
  
  Test2::IPC::Driver has an C<import()> method. All drivers inherit this import
  method. This import method registers the driver.
  
  In most cases you just need to load the desired IPC driver to make it work. You
  should load this driver as early as possible. A warning will be issued if you
  load it too late for it to be effective.
  
      use Test2::IPC::Driver::MyDriver;
      ...
  
  =head1 WRITING DRIVERS
  
      package Test2::IPC::Driver::MyDriver;
      use strict;
      use warnings;
  
      use base 'Test2::IPC::Driver';
  
      sub is_viable {
          return 0 if $^O eq 'win32'; # Will not work on windows.
          return 1;
      }
  
      sub add_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Make it possible to contact the hub
      }
  
      sub drop_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Nothing should try to reach the hub anymore.
      }
  
      sub send {
          my $self = shift;
          my ($hid, $e, $global) = @_;
  
          ... # Send the event to the proper hub.
  
          # If you are using the SHM you should notify other procs/threads that
          # there is a pending event.
          Test2::API::test2_ipc_set_pending($uniq_val);
      }
  
      sub cull {
          my $self = shift;
          my ($hid) = @_;
  
          my @events = ...; # Here is where you get the events for the hub
  
          return @events;
      }
  
      sub waiting {
          my $self = shift;
  
          ... # Notify all listening procs and threads that the main
          ... # process/thread is waiting for them to finish.
      }
  
      1;
  
  =head2 METHODS SUBCLASSES MUST IMPLEMENT
  
  =over 4
  
  =item $ipc->is_viable
  
  This should return true if the driver works in the current environment. This
  should return false if it does not. This is a CLASS method.
  
  =item $ipc->add_hub($hid)
  
  This is used to alert the driver that a new hub is expecting events. The driver
  should keep track of the process and thread ids, the hub should only be dropped
  by the proc+thread that started it.
  
      sub add_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Make it possible to contact the hub
      }
  
  =item $ipc->drop_hub($hid)
  
  This is used to alert the driver that a hub is no longer accepting events. The
  driver should keep track of the process and thread ids, the hub should only be
  dropped by the proc+thread that started it (This is the drivers responsibility
  to enforce).
  
      sub drop_hub {
          my $self = shift;
          my ($hid) = @_;
  
          ... # Nothing should try to reach the hub anymore.
      }
  
  =item $ipc->send($hid, $event);
  
  =item $ipc->send($hid, $event, $global);
  
  Used to send events from the current process/thread to the specified hub in its
  process+thread.
  
      sub send {
          my $self = shift;
          my ($hid, $e) = @_;
  
          ... # Send the event to the proper hub.
  
          # If you are using the SHM you should notify other procs/threads that
          # there is a pending event.
          Test2::API::test2_ipc_set_pending($uniq_val);
      }
  
  If C<$global> is true then the driver should send the event to all hubs in all
  processes and threads.
  
  =item @events = $ipc->cull($hid)
  
  Used to collect events that have been sent to the specified hub.
  
      sub cull {
          my $self = shift;
          my ($hid) = @_;
  
          my @events = ...; # Here is where you get the events for the hub
  
          return @events;
      }
  
  =item $ipc->waiting()
  
  This is called in the parent process when it is complete and waiting for all
  child processes and threads to complete.
  
      sub waiting {
          my $self = shift;
  
          ... # Notify all listening procs and threads that the main
          ... # process/thread is waiting for them to finish.
      }
  
  =back
  
  =head2 METHODS SUBCLASSES MAY IMPLEMENT OR OVERRIDE
  
  =over 4
  
  =item $ipc->driver_abort($msg)
  
  This is a hook called by C<< Test2::IPC::Driver->abort() >>. This is your
  chance to cleanup when an abort happens. You cannot prevent the abort, but you
  can gracefully except it.
  
  =item $bool = $ipc->use_shm()
  
  True if you want to make use of the L<Test2::API>/L<Test2::API::Instance> SHM.
  
  =item $bites = $ipc->shm_size()
  
  Use this to customize the size of the SHM space. There are no guarantees about
  what the size will be if you do not implement this.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC_DRIVER

$fatpacked{"Test2/IPC/Driver/Files.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_IPC_DRIVER_FILES';
  package Test2::IPC::Driver::Files;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  BEGIN { require Test2::IPC::Driver; our @ISA = qw(Test2::IPC::Driver) }
  
  use Test2::Util::HashBase qw{tempdir event_ids read_ids timeouts tid pid globals};
  
  use Scalar::Util qw/blessed/;
  use File::Temp();
  use Storable();
  use File::Spec();
  use POSIX();
  
  use Test2::Util qw/try get_tid pkg_to_file IS_WIN32 ipc_separator do_rename do_unlink try_sig_mask/;
  use Test2::API qw/test2_ipc_set_pending/;
  
  sub use_shm { 1 }
  sub shm_size() { 64 }
  
  sub is_viable { 1 }
  
  sub init {
      my $self = shift;
  
      my $tmpdir = File::Temp::tempdir(
          $ENV{T2_TEMPDIR_TEMPLATE} || "test2" . ipc_separator . $$ . ipc_separator . "XXXXXX",
          CLEANUP => 0,
          TMPDIR => 1,
      );
  
      $self->abort_trace("Could not get a temp dir") unless $tmpdir;
  
      $self->{+TEMPDIR} = File::Spec->canonpath($tmpdir);
  
      print STDERR "\nIPC Temp Dir: $tmpdir\n\n"
          if $ENV{T2_KEEP_TEMPDIR};
  
      $self->{+EVENT_IDS} = {};
      $self->{+READ_IDS} = {};
      $self->{+TIMEOUTS} = {};
  
      $self->{+TID} = get_tid();
      $self->{+PID} = $$;
  
      $self->{+GLOBALS} = {};
  
      return $self;
  }
  
  sub hub_file {
      my $self = shift;
      my ($hid) = @_;
      my $tdir = $self->{+TEMPDIR};
      return File::Spec->catfile($tdir, "HUB" . ipc_separator . $hid);
  }
  
  sub event_file {
      my $self = shift;
      my ($hid, $e) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
      my $type = blessed($e) or $self->abort("'$e' is not a blessed object!");
  
      $self->abort("'$e' is not an event object!")
          unless $type->isa('Test2::Event');
  
      my $tid = get_tid();
      my $eid = $self->{+EVENT_IDS}->{$hid}->{$$}->{$tid} += 1;
  
      my @type = split '::', $type;
      my $name = join(ipc_separator, $hid, $$, $tid, $eid, @type);
  
      return File::Spec->catfile($tempdir, $name);
  }
  
  sub add_hub {
      my $self = shift;
      my ($hid) = @_;
  
      my $hfile = $self->hub_file($hid);
  
      $self->abort_trace("File for hub '$hid' already exists")
          if -e $hfile;
  
      open(my $fh, '>', $hfile) or $self->abort_trace("Could not create hub file '$hid': $!");
      print $fh "$$\n" . get_tid() . "\n";
      close($fh);
  }
  
  sub drop_hub {
      my $self = shift;
      my ($hid) = @_;
  
      my $tdir = $self->{+TEMPDIR};
      my $hfile = $self->hub_file($hid);
  
      $self->abort_trace("File for hub '$hid' does not exist")
          unless -e $hfile;
  
      open(my $fh, '<', $hfile) or $self->abort_trace("Could not open hub file '$hid': $!");
      my ($pid, $tid) = <$fh>;
      close($fh);
  
      $self->abort_trace("A hub file can only be closed by the process that started it\nExpected $pid, got $$")
          unless $pid == $$;
  
      $self->abort_trace("A hub file can only be closed by the thread that started it\nExpected $tid, got " . get_tid())
          unless get_tid() == $tid;
  
      if ($ENV{T2_KEEP_TEMPDIR}) {
          my ($ok, $err) = do_rename($hfile, File::Spec->canonpath("$hfile.complete"));
          $self->abort_trace("Could not rename file '$hfile' -> '$hfile.complete': $err") unless $ok
      }
      else {
          my ($ok, $err) = do_unlink($hfile);
          $self->abort_trace("Could not remove file for hub '$hid': $err") unless $ok
      }
  
      opendir(my $dh, $tdir) or $self->abort_trace("Could not open temp dir!");
      for my $file (readdir($dh)) {
          next if $file =~ m{\.complete$};
          next unless $file =~ m{^$hid};
          $self->abort_trace("Not all files from hub '$hid' have been collected!");
      }
      closedir($dh);
  }
  
  sub send {
      my $self = shift;
      my ($hid, $e, $global) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
      my $hfile = $self->hub_file($hid);
      my $dest = $global ? 'GLOBAL' : $hid;
  
      $self->abort(<<"    EOT") unless $global || -f $hfile;
  hub '$hid' is not available, failed to send event!
  
  There was an attempt to send an event to a hub in a parent process or thread,
  but that hub appears to be gone. This can happen if you fork, or start a new
  thread from inside subtest, and the parent finishes the subtest before the
  child returns.
  
  This can also happen if the parent process is done testing before the child
  finishes. Test2 normally waits automatically in the root process, but will not
  do so if Test::Builder is loaded for legacy reasons.
      EOT
  
      my $file = $self->event_file($dest, $e);
      my $ready = File::Spec->canonpath("$file.ready");
  
      if ($global) {
          my $name = $ready;
          $name =~ s{^.*(GLOBAL)}{GLOBAL};
          $self->{+GLOBALS}->{$hid}->{$name}++;
      }
  
      # Write and rename the file.
      my ($ren_ok, $ren_err);
      my ($ok, $err) = try_sig_mask {
          Storable::store($e, $file);
          ($ren_ok, $ren_err) = do_rename("$file", $ready);
      };
  
      if ($ok) {
          $self->abort("Could not rename file '$file' -> '$ready': $ren_err") unless $ren_ok;
          test2_ipc_set_pending(substr($file, -(shm_size)));
      }
      else {
          my $src_file = __FILE__;
          $err =~ s{ at \Q$src_file\E.*$}{};
          chomp($err);
          my $tid = get_tid();
          my $trace = $e->trace->debug;
          my $type = blessed($e);
  
          $self->abort(<<"        EOT");
  
  *******************************************************************************
  There was an error writing an event:
  Destination: $dest
  Origin PID:  $$
  Origin TID:  $tid
  Event Type:  $type
  Event Trace: $trace
  File Name:   $file
  Ready Name:  $ready
  Error: $err
  *******************************************************************************
  
          EOT
      }
  
      return 1;
  }
  
  sub driver_abort {
      my $self = shift;
      my ($msg) = @_;
  
      local ($@, $!, $?, $^E);
      eval {
          my $abort = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
          open(my $fh, '>>', $abort) or die "Could not open abort file: $!";
          print $fh $msg, "\n";
          close($fh) or die "Could not close abort file: $!";
          1;
      } or warn $@;
  }
  
  sub cull {
      my $self = shift;
      my ($hid) = @_;
  
      my $tempdir = $self->{+TEMPDIR};
  
      opendir(my $dh, $tempdir) or $self->abort("could not open IPC temp dir ($tempdir)!");
  
      my $read = $self->{+READ_IDS};
      my $timeouts = $self->{+TIMEOUTS};
  
      my @out;
      for my $info (sort cmp_events map { $self->should_read_event($hid, $_) } readdir($dh)) {
          unless ($info->{global}) {
              my $next = $self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}} ||= 1;
  
              $timeouts->{$info->{file}} ||= time;
  
              if ($next != $info->{eid}) {
                  # Wait up to N seconds for missing events
                  next unless 5 < time - $timeouts->{$info->{file}};
                  $self->abort("Missing event HID: $info->{hid}, PID: $info->{pid}, TID: $info->{tid}, EID: $info->{eid}.");
              }
  
              $self->{+READ_IDS}->{$info->{hid}}->{$info->{pid}}->{$info->{tid}} = $info->{eid} + 1;
          }
  
          my $full = $info->{full_path};
          my $obj = $self->read_event_file($full);
          push @out => $obj;
  
          # Do not remove global events
          next if $info->{global};
  
          if ($ENV{T2_KEEP_TEMPDIR}) {
              my $complete = File::Spec->canonpath("$full.complete");
              my ($ok, $err) = do_rename($full, $complete);
              $self->abort("Could not rename IPC file '$full', '$complete': $err") unless $ok;
          }
          else {
              my ($ok, $err) = do_unlink("$full");
              $self->abort("Could not unlink IPC file '$full': $err") unless $ok;
          }
      }
  
      closedir($dh);
      return @out;
  }
  
  sub parse_event_filename {
      my $self = shift;
      my ($file) = @_;
  
      # The || is to force 0 in false
      my $complete = substr($file, -9, 9) eq '.complete' || 0 and substr($file, -9, 9, "");
      my $ready    = substr($file, -6, 6) eq '.ready'    || 0 and substr($file, -6, 6, "");
  
      my @parts = split ipc_separator, $file;
      my ($global, $hid) = $parts[0] eq 'GLOBAL' ? (1, shift @parts) : (0, join ipc_separator, splice(@parts, 0, 4));
      my ($pid, $tid, $eid) = splice(@parts, 0, 3);
      my $type = join '::' => @parts;
  
      return {
          file     => $file,
          ready    => $ready,
          complete => $complete,
          global   => $global,
          type     => $type,
          hid      => $hid,
          pid      => $pid,
          tid      => $tid,
          eid      => $eid,
      };
  }
  
  sub should_read_event {
      my $self = shift;
      my ($hid, $file) = @_;
  
      return if substr($file, 0, 1) eq '.';
      return if substr($file, 0, 3) eq 'HUB';
      CORE::exit(255) if $file eq 'ABORT';
  
      my $parsed = $self->parse_event_filename($file);
  
      return if $parsed->{complete};
      return unless $parsed->{ready};
      return unless $parsed->{global} || $parsed->{hid} eq $hid;
  
      return if $parsed->{global} && $self->{+GLOBALS}->{$hid}->{$file}++;
  
      # Untaint the path.
      my $full = File::Spec->catfile($self->{+TEMPDIR}, $file);
      ($full) = ($full =~ m/^(.*)$/gs) if ${^TAINT};
  
      $parsed->{full_path} = $full;
  
      return $parsed;
  }
  
  sub cmp_events {
      # Globals first
      return -1 if $a->{global} && !$b->{global};
      return  1 if $b->{global} && !$a->{global};
  
      return $a->{pid} <=> $b->{pid}
          || $a->{tid} <=> $b->{tid}
          || $a->{eid} <=> $b->{eid};
  }
  
  sub read_event_file {
      my $self = shift;
      my ($file) = @_;
  
      my $obj = Storable::retrieve($file);
      $self->abort("Got an unblessed object: '$obj'")
          unless blessed($obj);
  
      unless ($obj->isa('Test2::Event')) {
          my $pkg  = blessed($obj);
          my $mod_file = pkg_to_file($pkg);
          my ($ok, $err) = try { require $mod_file };
  
          $self->abort("Event has unknown type ($pkg), tried to load '$mod_file' but failed: $err")
              unless $ok;
  
          $self->abort("'$obj' is not a 'Test2::Event' object")
              unless $obj->isa('Test2::Event');
      }
  
      return $obj;
  }
  
  sub waiting {
      my $self = shift;
      require Test2::Event::Waiting;
      $self->send(
          GLOBAL => Test2::Event::Waiting->new(
              trace => Test2::EventFacet::Trace->new(frame => [caller()]),
          ),
          'GLOBAL'
      );
      return;
  }
  
  sub DESTROY {
      my $self = shift;
  
      return unless defined $self->pid;
      return unless defined $self->tid;
  
      return unless $$        == $self->pid;
      return unless get_tid() == $self->tid;
  
      my $tempdir = $self->{+TEMPDIR};
  
      my $aborted = 0;
      my $abort_file = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
      if (-e $abort_file) {
          $aborted = 1;
          my ($ok, $err) = do_unlink($abort_file);
          warn $err unless $ok;
      }
  
      opendir(my $dh, $tempdir) or $self->abort("Could not open temp dir! ($tempdir)");
      while(my $file = readdir($dh)) {
          next if $file =~ m/^\.+$/;
          next if $file =~ m/\.complete$/;
          my $full = File::Spec->catfile($tempdir, $file);
  
          my $sep = ipc_separator;
          if ($aborted || $file =~ m/^(GLOBAL|HUB$sep)/) {
              $full =~ m/^(.*)$/;
              $full = $1; # Untaint it
              next if $ENV{T2_KEEP_TEMPDIR};
              my ($ok, $err) = do_unlink($full);
              $self->abort("Could not unlink IPC file '$full': $err") unless $ok;
              next;
          }
  
          $self->abort("Leftover files in the directory ($full)!\n");
      }
      closedir($dh);
  
      if ($ENV{T2_KEEP_TEMPDIR}) {
          print STDERR "# Not removing temp dir: $tempdir\n";
          return;
      }
  
      my $abort = File::Spec->catfile($self->{+TEMPDIR}, "ABORT");
      unlink($abort) if -e $abort;
      rmdir($tempdir) or warn "Could not remove IPC temp dir ($tempdir)";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::IPC::Driver::Files - Temp dir + Files concurrency model.
  
  =head1 DESCRIPTION
  
  This is the default, and fallback concurrency model for L<Test2>. This
  sends events between processes and threads using serialized files in a
  temporary directory. This is not particularly fast, but it works everywhere.
  
  =head1 SYNOPSIS
  
      use Test2::IPC::Driver::Files;
  
      # IPC is now enabled
  
  =head1 ENVIRONMENT VARIABLES
  
  =over 4
  
  =item T2_KEEP_TEMPDIR=0
  
  When true, the tempdir used by the IPC driver will not be deleted when the test
  is done.
  
  =item T2_TEMPDIR_TEMPLATE='test2-XXXXXX'
  
  This can be used to set the template for the IPC temp dir. The template should
  follow template specifications from L<File::Temp>.
  
  =back
  
  =head1 SEE ALSO
  
  See L<Test2::IPC::Driver> for methods.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_IPC_DRIVER_FILES

$fatpacked{"Test2/Tools/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TINY';
  package Test2::Tools::Tiny;
  use strict;
  use warnings;
  
  BEGIN {
      if ($] lt "5.008") {
          require Test::Builder::IO::Scalar;
      }
  }
  
  use Scalar::Util qw/blessed/;
  
  use Test2::Util qw/try/;
  use Test2::API qw/context run_subtest test2_stack/;
  
  use Test2::Hub::Interceptor();
  use Test2::Hub::Interceptor::Terminator();
  
  our $VERSION = '1.302136';
  
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  our @EXPORT = qw{
      ok is isnt like unlike is_deeply diag note skip_all todo plan done_testing
      warnings exception tests capture
  };
  
  sub ok($;$@) {
      my ($bool, $name, @diag) = @_;
      my $ctx = context();
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub is($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($got) && defined($want)) {
          $bool = "$got" eq "$want";
      }
      elsif (defined($got) xor defined($want)) {
          $bool = 0;
      }
      else {    # Both are undef
          $bool = 1;
      }
  
      return $ctx->pass_and_release($name) if $bool;
  
      $got  = '*NOT DEFINED*' unless defined $got;
      $want = '*NOT DEFINED*' unless defined $want;
      unshift @diag => (
          "GOT:      $got",
          "EXPECTED: $want",
      );
  
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub isnt($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($got) && defined($want)) {
          $bool = "$got" ne "$want";
      }
      elsif (defined($got) xor defined($want)) {
          $bool = 1;
      }
      else {    # Both are undef
          $bool = 0;
      }
  
      return $ctx->pass_and_release($name) if $bool;
  
      unshift @diag => "Strings are the same (they should not be)"
          unless $bool;
  
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub like($$;$@) {
      my ($thing, $pattern, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($thing)) {
          $bool = "$thing" =~ $pattern;
          unshift @diag => (
              "Value: $thing",
              "Does not match: $pattern"
          ) unless $bool;
      }
      else {
          $bool = 0;
          unshift @diag => "Got an undefined value.";
      }
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub unlike($$;$@) {
      my ($thing, $pattern, $name, @diag) = @_;
      my $ctx = context();
  
      my $bool;
      if (defined($thing)) {
          $bool = "$thing" !~ $pattern;
          unshift @diag => (
              "Unexpected pattern match (it should not match)",
              "Value:   $thing",
              "Matches: $pattern"
          ) unless $bool;
      }
      else {
          $bool = 0;
          unshift @diag => "Got an undefined value.";
      }
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, @diag);
  }
  
  sub is_deeply($$;$@) {
      my ($got, $want, $name, @diag) = @_;
      my $ctx = context();
  
      no warnings 'once';
      require Data::Dumper;
  
      # Otherwise numbers might be unquoted
      local $Data::Dumper::Useperl  = 1;
  
      local $Data::Dumper::Sortkeys = 1;
      local $Data::Dumper::Deparse  = 1;
      local $Data::Dumper::Freezer  = 'XXX';
      local *UNIVERSAL::XXX         = sub {
          my ($thing) = @_;
          if (ref($thing)) {
              $thing = {%$thing}  if "$thing" =~ m/=HASH/;
              $thing = [@$thing]  if "$thing" =~ m/=ARRAY/;
              $thing = \"$$thing" if "$thing" =~ m/=SCALAR/;
          }
          $_[0] = $thing;
      };
  
      my $g = Data::Dumper::Dumper($got);
      my $w = Data::Dumper::Dumper($want);
  
      my $bool = $g eq $w;
  
      return $ctx->pass_and_release($name) if $bool;
      return $ctx->fail_and_release($name, $g, $w, @diag);
  }
  
  sub diag {
      my $ctx = context();
      $ctx->diag(join '', @_);
      $ctx->release;
  }
  
  sub note {
      my $ctx = context();
      $ctx->note(join '', @_);
      $ctx->release;
  }
  
  sub skip_all {
      my ($reason) = @_;
      my $ctx = context();
      $ctx->plan(0, SKIP => $reason);
      $ctx->release if $ctx;
  }
  
  sub todo {
      my ($reason, $sub) = @_;
      my $ctx = context();
  
      # This code is mostly copied from Test2::Todo in the Test2-Suite
      # distribution.
      my $hub    = test2_stack->top;
      my $filter = $hub->pre_filter(
          sub {
              my ($active_hub, $event) = @_;
              if ($active_hub == $hub) {
                  $event->set_todo($reason) if $event->can('set_todo');
                  $event->add_amnesty({tag => 'TODO', details => $reason});
              }
              else {
                  $event->add_amnesty({tag => 'TODO', details => $reason, inherited => 1});
              }
              return $event;
          },
          inherit => 1,
          todo    => $reason,
      );
      $sub->();
      $hub->pre_unfilter($filter);
  
      $ctx->release if $ctx;
  }
  
  sub plan {
      my ($max) = @_;
      my $ctx = context();
      $ctx->plan($max);
      $ctx->release;
  }
  
  sub done_testing {
      my $ctx = context();
      $ctx->done_testing;
      $ctx->release;
  }
  
  sub warnings(&) {
      my $code = shift;
      my @warnings;
      local $SIG{__WARN__} = sub { push @warnings => @_ };
      $code->();
      return \@warnings;
  }
  
  sub exception(&) {
      my $code = shift;
      local ($@, $!, $SIG{__DIE__});
      my $ok = eval { $code->(); 1 };
      my $error = $@ || 'SQUASHED ERROR';
      return $ok ? undef : $error;
  }
  
  sub tests {
      my ($name, $code) = @_;
      my $ctx = context();
  
      my $be = caller->can('before_each');
  
      $be->($name) if $be;
  
      my $bool = run_subtest($name, $code, 1);
  
      $ctx->release;
  
      return $bool;
  }
  
  sub capture(&) {
      my $code = shift;
  
      my ($err, $out) = ("", "");
  
      my $handles = test2_stack->top->format->handles;
      my ($ok, $e);
      {
          my ($out_fh, $err_fh);
  
          ($ok, $e) = try {
            # Scalar refs as filehandles were added in 5.8.
            if ($] ge "5.008") {
              open($out_fh, '>', \$out) or die "Failed to open a temporary STDOUT: $!";
              open($err_fh, '>', \$err) or die "Failed to open a temporary STDERR: $!";
            }
            # Emulate scalar ref filehandles with a tie.
            else {
              $out_fh = Test::Builder::IO::Scalar->new(\$out) or die "Failed to open a temporary STDOUT";
              $err_fh = Test::Builder::IO::Scalar->new(\$err) or die "Failed to open a temporary STDERR";
            }
  
              test2_stack->top->format->set_handles([$out_fh, $err_fh, $out_fh]);
  
              $code->();
          };
      }
      test2_stack->top->format->set_handles($handles);
  
      die $e unless $ok;
  
      $err =~ s/ $/_/mg;
      $out =~ s/ $/_/mg;
  
      return {
          STDOUT => $out,
          STDERR => $err,
      };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Tools::Tiny - Tiny set of tools for unfortunate souls who cannot use
  L<Test2::Suite>.
  
  =head1 DESCRIPTION
  
  You should really look at L<Test2::Suite>. This package is some very basic
  essential tools implemented using L<Test2>. This exists only so that L<Test2>
  and other tools required by L<Test2::Suite> can be tested. This is the package
  L<Test2> uses to test itself.
  
  =head1 USE Test2::Suite INSTEAD
  
  Use L<Test2::Suite> if at all possible.
  
  =head1 EXPORTS
  
  =over 4
  
  =item ok($bool, $name)
  
  =item ok($bool, $name, @diag)
  
  Run a simple assertion.
  
  =item is($got, $want, $name)
  
  =item is($got, $want, $name, @diag)
  
  Assert that 2 strings are the same.
  
  =item isnt($got, $do_not_want, $name)
  
  =item isnt($got, $do_not_want, $name, @diag)
  
  Assert that 2 strings are not the same.
  
  =item like($got, $regex, $name)
  
  =item like($got, $regex, $name, @diag)
  
  Check that the input string matches the regex.
  
  =item unlike($got, $regex, $name)
  
  =item unlike($got, $regex, $name, @diag)
  
  Check that the input string does not match the regex.
  
  =item is_deeply($got, $want, $name)
  
  =item is_deeply($got, $want, $name, @diag)
  
  Check 2 data structures. Please note that this is a I<DUMB> implementation that
  compares the output of L<Data::Dumper> against both structures.
  
  =item diag($msg)
  
  Issue a diagnostics message to STDERR.
  
  =item note($msg)
  
  Issue a diagnostics message to STDOUT.
  
  =item skip_all($reason)
  
  Skip all tests.
  
  =item todo $reason => sub { ... }
  
  Run a block in TODO mode.
  
  =item plan($count)
  
  Set the plan.
  
  =item done_testing()
  
  Set the plan to the current test count.
  
  =item $warnings = warnings { ... }
  
  Capture an arrayref of warnings from the block.
  
  =item $exception = exception { ... }
  
  Capture an exception.
  
  =item tests $name => sub { ... }
  
  Run a subtest.
  
  =item $output = capture { ... }
  
  Capture STDOUT and STDERR output.
  
  Result looks like this:
  
      {
          STDOUT => "...",
          STDERR => "...",
      }
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_TOOLS_TINY

$fatpacked{"Test2/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL';
  package Test2::Util;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use POSIX();
  use Config qw/%Config/;
  use Carp qw/croak/;
  
  BEGIN {
      local ($@, $!, $SIG{__DIE__});
      *HAVE_PERLIO = eval { require PerlIO; PerlIO->VERSION(1.02); } ? sub() { 1 } : sub() { 0 };
  }
  
  our @EXPORT_OK = qw{
      try
  
      pkg_to_file
  
      get_tid USE_THREADS
      CAN_THREAD
      CAN_REALLY_FORK
      CAN_FORK
  
      CAN_SIGSYS
  
      IS_WIN32
  
      ipc_separator
  
      gen_uid
  
      do_rename do_unlink
  
      try_sig_mask
  
      clone_io
  };
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  BEGIN {
      *IS_WIN32 = ($^O eq 'MSWin32') ? sub() { 1 } : sub() { 0 };
  }
  
  sub _can_thread {
      return 0 unless $] >= 5.008001;
      return 0 unless $Config{'useithreads'};
  
      # Threads are broken on perl 5.10.0 built with gcc 4.8+
      if ($] == 5.010000 && $Config{'ccname'} eq 'gcc' && $Config{'gccversion'}) {
          my @parts = split /\./, $Config{'gccversion'};
          return 0 if $parts[0] > 4 || ($parts[0] == 4 && $parts[1] >= 8);
      }
  
      # Change to a version check if this ever changes
      return 0 if $INC{'Devel/Cover.pm'};
      return 1;
  }
  
  sub _can_fork {
      return 1 if $Config{d_fork};
      return 0 unless IS_WIN32 || $^O eq 'NetWare';
      return 0 unless $Config{useithreads};
      return 0 unless $Config{ccflags} =~ /-DPERL_IMPLICIT_SYS/;
  
      return _can_thread();
  }
  
  BEGIN {
      no warnings 'once';
      *CAN_THREAD      = _can_thread()   ? sub() { 1 } : sub() { 0 };
  }
  my $can_fork;
  sub CAN_FORK () {
      return $can_fork
          if defined $can_fork;
      $can_fork = !!_can_fork();
      no warnings 'redefine';
      *CAN_FORK = $can_fork ? sub() { 1 } : sub() { 0 };
      $can_fork;
  }
  my $can_really_fork;
  sub CAN_REALLY_FORK () {
      return $can_really_fork
          if defined $can_really_fork;
      $can_really_fork = !!$Config{d_fork};
      no warnings 'redefine';
      *CAN_REALLY_FORK = $can_really_fork ? sub() { 1 } : sub() { 0 };
      $can_really_fork;
  }
  
  sub _manual_try(&;@) {
      my $code = shift;
      my $args = \@_;
      my $err;
  
      my $die = delete $SIG{__DIE__};
  
      eval { $code->(@$args); 1 } or $err = $@ || "Error was squashed!\n";
  
      $die ? $SIG{__DIE__} = $die : delete $SIG{__DIE__};
  
      return (!defined($err), $err);
  }
  
  sub _local_try(&;@) {
      my $code = shift;
      my $args = \@_;
      my $err;
  
      no warnings;
      local $SIG{__DIE__};
      eval { $code->(@$args); 1 } or $err = $@ || "Error was squashed!\n";
  
      return (!defined($err), $err);
  }
  
  # Older versions of perl have a nasty bug on win32 when localizing a variable
  # before forking or starting a new thread. So for those systems we use the
  # non-local form. When possible though we use the faster 'local' form.
  BEGIN {
      if (IS_WIN32 && $] < 5.020002) {
          *try = \&_manual_try;
      }
      else {
          *try = \&_local_try;
      }
  }
  
  BEGIN {
      if (CAN_THREAD) {
          if ($INC{'threads.pm'}) {
              # Threads are already loaded, so we do not need to check if they
              # are loaded each time
              *USE_THREADS = sub() { 1 };
              *get_tid     = sub() { threads->tid() };
          }
          else {
              # :-( Need to check each time to see if they have been loaded.
              *USE_THREADS = sub() { $INC{'threads.pm'} ? 1 : 0 };
              *get_tid     = sub() { $INC{'threads.pm'} ? threads->tid() : 0 };
          }
      }
      else {
          # No threads, not now, not ever!
          *USE_THREADS = sub() { 0 };
          *get_tid     = sub() { 0 };
      }
  }
  
  sub pkg_to_file {
      my $pkg = shift;
      my $file = $pkg;
      $file =~ s{(::|')}{/}g;
      $file .= '.pm';
      return $file;
  }
  
  sub ipc_separator() { "~" }
  
  my $UID = 1;
  sub gen_uid() { join ipc_separator() => ($$, get_tid(), time, $UID++) }
  
  sub _check_for_sig_sys {
      my $sig_list = shift;
      return $sig_list =~ m/\bSYS\b/;
  }
  
  BEGIN {
      if (_check_for_sig_sys($Config{sig_name})) {
          *CAN_SIGSYS = sub() { 1 };
      }
      else {
          *CAN_SIGSYS = sub() { 0 };
      }
  }
  
  my %PERLIO_SKIP = (
      unix => 1,
      via  => 1,
  );
  
  sub clone_io {
      my ($fh) = @_;
      my $fileno = fileno($fh);
  
      return $fh if !defined($fileno) || !length($fileno) || $fileno < 0;
  
      open(my $out, '>&' . $fileno) or die "Can't dup fileno $fileno: $!";
  
      my %seen;
      my @layers = HAVE_PERLIO ? grep { !$PERLIO_SKIP{$_} and !$seen{$_}++ } PerlIO::get_layers($fh) : ();
      binmode($out, join(":", "", "raw", @layers));
  
      my $old = select $fh;
      my $af  = $|;
      select $out;
      $| = $af;
      select $old;
  
      return $out;
  }
  
  BEGIN {
      if (IS_WIN32) {
          my $max_tries = 5;
  
          *do_rename = sub {
              my ($from, $to) = @_;
  
              my $err;
              for (1 .. $max_tries) {
                  return (1) if rename($from, $to);
                  $err = "$!";
                  last if $_ == $max_tries;
                  sleep 1;
              }
  
              return (0, $err);
          };
          *do_unlink = sub {
              my ($file) = @_;
  
              my $err;
              for (1 .. $max_tries) {
                  return (1) if unlink($file);
                  $err = "$!";
                  last if $_ == $max_tries;
                  sleep 1;
              }
  
              return (0, "$!");
          };
      }
      else {
          *do_rename = sub {
              my ($from, $to) = @_;
              return (1) if rename($from, $to);
              return (0, "$!");
          };
          *do_unlink = sub {
              my ($file) = @_;
              return (1) if unlink($file);
              return (0, "$!");
          };
      }
  }
  
  sub try_sig_mask(&) {
      my $code = shift;
  
      my ($old, $blocked);
      unless(IS_WIN32) {
          my $to_block = POSIX::SigSet->new(
              POSIX::SIGINT(),
              POSIX::SIGALRM(),
              POSIX::SIGHUP(),
              POSIX::SIGTERM(),
              POSIX::SIGUSR1(),
              POSIX::SIGUSR2(),
          );
          $old = POSIX::SigSet->new;
          $blocked = POSIX::sigprocmask(POSIX::SIG_BLOCK(), $to_block, $old);
          # Silently go on if we failed to log signals, not much we can do.
      }
  
      my ($ok, $err) = &try($code);
  
      # If our block was successful we want to restore the old mask.
      POSIX::sigprocmask(POSIX::SIG_SETMASK(), $old, POSIX::SigSet->new()) if defined $blocked;
  
      return ($ok, $err);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util - Tools used by Test2 and friends.
  
  =head1 DESCRIPTION
  
  Collection of tools used by L<Test2> and friends.
  
  =head1 EXPORTS
  
  All exports are optional. You must specify subs to import.
  
  =over 4
  
  =item ($success, $error) = try { ... }
  
  Eval the codeblock, return success or failure, and the error message. This code
  protects $@ and $!, they will be restored by the end of the run. This code also
  temporarily blocks $SIG{DIE} handlers.
  
  =item protect { ... }
  
  Similar to try, except that it does not catch exceptions. The idea here is to
  protect $@ and $! from changes. $@ and $! will be restored to whatever they
  were before the run so long as it is successful. If the run fails $! will still
  be restored, but $@ will contain the exception being thrown.
  
  =item CAN_FORK
  
  True if this system is capable of true or pseudo-fork.
  
  =item CAN_REALLY_FORK
  
  True if the system can really fork. This will be false for systems where fork
  is emulated.
  
  =item CAN_THREAD
  
  True if this system is capable of using threads.
  
  =item USE_THREADS
  
  Returns true if threads are enabled, false if they are not.
  
  =item get_tid
  
  This will return the id of the current thread when threads are enabled,
  otherwise it returns 0.
  
  =item my $file = pkg_to_file($package)
  
  Convert a package name to a filename.
  
  =item $string = ipc_separator()
  
  Get the IPC separator. Currently this is always the string C<'~'>.
  
  =item $string = gen_uid()
  
  Generate a unique id (NOT A UUID). This will typically be the process id, the
  thread id, the time, and an incrementing integer all joined with the
  C<ipc_separator()>.
  
  These ID's are unique enough for most purposes. For identical ids to be
  generated you must have 2 processes with the same PID generate IDs at the same
  time with the same current state of the incrementing integer. This is a
  perfectly reasonable thing to expect to happen across multiple machines, but is
  quite unlikely to happen on one machine.
  
  This can fail to be unique if a process generates an id, calls exec, and does
  it again after the exec and it all happens in less than a second. It can also
  happen if the systems process id's cycle in less than a second allowing 2
  different programs that use this generator to run with the same PID in less
  than a second. Both these cases are sufficiently unlikely. If you need
  universally unique ids, or ids that are unique in these conditions, look at
  L<Data::UUID>.
  
  =item ($ok, $err) = do_rename($old_name, $new_name)
  
  Rename a file, this wraps C<rename()> in a way that makes it more reliable
  cross-platform when trying to rename files you recently altered.
  
  =item ($ok, $err) = do_unlink($filename)
  
  Unlink a file, this wraps C<unlink()> in a way that makes it more reliable
  cross-platform when trying to unlink files you recently altered.
  
  =item ($ok, $err) = try_sig_mask { ... }
  
  Complete an action with several signals masked, they will be unmasked at the
  end allowing any signals that were intercepted to get handled.
  
  This is primarily used when you need to make several actions atomic (against
  some signals anyway).
  
  Signals that are intercepted:
  
  =over 4
  
  =item SIGINT
  
  =item SIGALRM
  
  =item SIGHUP
  
  =item SIGTERM
  
  =item SIGUSR1
  
  =item SIGUSR2
  
  =back
  
  =back
  
  =head1 NOTES && CAVEATS
  
  =over 4
  
  =item 5.10.0
  
  Perl 5.10.0 has a bug when compiled with newer gcc versions. This bug causes a
  segfault whenever a new thread is launched. Test2 will attempt to detect
  this, and note that the system is not capable of forking when it is detected.
  
  =item Devel::Cover
  
  Devel::Cover does not support threads. CAN_THREAD will return false if
  Devel::Cover is loaded before the check is first run.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =item Kent Fredric E<lt>kentnl@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL

$fatpacked{"Test2/Util/ExternalMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_EXTERNALMETA';
  package Test2::Util::ExternalMeta;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  
  use Carp qw/croak/;
  
  sub META_KEY() { '_meta' }
  
  our @EXPORT = qw/meta set_meta get_meta delete_meta/;
  BEGIN { require Exporter; our @ISA = qw(Exporter) }
  
  sub set_meta {
      my $self = shift;
      my ($key, $value) = @_;
  
      validate_key($key);
  
      $self->{+META_KEY} ||= {};
      $self->{+META_KEY}->{$key} = $value;
  }
  
  sub get_meta {
      my $self = shift;
      my ($key) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY} or return undef;
      return $meta->{$key};
  }
  
  sub delete_meta {
      my $self = shift;
      my ($key) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY} or return undef;
      delete $meta->{$key};
  }
  
  sub meta {
      my $self = shift;
      my ($key, $default) = @_;
  
      validate_key($key);
  
      my $meta = $self->{+META_KEY};
      return undef unless $meta || defined($default);
  
      unless($meta) {
          $meta = {};
          $self->{+META_KEY} = $meta;
      }
  
      $meta->{$key} = $default
          if defined($default) && !defined($meta->{$key});
  
      return $meta->{$key};
  }
  
  sub validate_key {
      my $key = shift;
  
      return if $key && !ref($key);
  
      my $render_key = defined($key) ? "'$key'" : 'undef';
      croak "Invalid META key: $render_key, keys must be true, and may not be references";
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::ExternalMeta - Allow third party tools to safely attach meta-data
  to your instances.
  
  =head1 DESCRIPTION
  
  This package lets you define a clear, and consistent way to allow third party
  tools to attach meta-data to your instances. If your object consumes this
  package, and imports its methods, then third party meta-data has a safe place
  to live.
  
  =head1 SYNOPSIS
  
      package My::Object;
      use strict;
      use warnings;
  
      use Test2::Util::ExternalMeta qw/meta get_meta set_meta delete_meta/;
  
      ...
  
  Now to use it:
  
      my $inst = My::Object->new;
  
      $inst->set_meta(foo => 'bar');
      my $val = $inst->get_meta('foo');
  
  =head1 WHERE IS THE DATA STORED?
  
  This package assumes your instances are blessed hashrefs, it will not work if
  that is not true. It will store all meta-data in the C<_meta> key on your
  objects hash. If your object makes use of the C<_meta> key in its underlying
  hash, then there is a conflict and you cannot use this package.
  
  =head1 EXPORTS
  
  =over 4
  
  =item $val = $obj->meta($key)
  
  =item $val = $obj->meta($key, $default)
  
  This will get the value for a specified meta C<$key>. Normally this will return
  C<undef> when there is no value for the C<$key>, however you can specify a
  C<$default> value to set when no value is already set.
  
  =item $val = $obj->get_meta($key)
  
  This will get the value for a specified meta C<$key>. This does not have the
  C<$default> overhead that C<meta()> does.
  
  =item $val = $obj->delete_meta($key)
  
  This will remove the value of a specified meta C<$key>. The old C<$val> will be
  returned.
  
  =item $obj->set_meta($key, $val)
  
  Set the value of a specified meta C<$key>.
  
  =back
  
  =head1 META-KEY RESTRICTIONS
  
  Meta keys must be defined, and must be true when used as a boolean. Keys may
  not be references. You are free to stringify a reference C<"$ref"> for use as a
  key, but this package will not stringify it for you.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_EXTERNALMETA

$fatpacked{"Test2/Util/Facets2Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_FACETS2LEGACY';
  package Test2::Util::Facets2Legacy;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  use Carp qw/croak confess/;
  use Scalar::Util qw/blessed/;
  
  use base 'Exporter';
  our @EXPORT_OK = qw{
      causes_fail
      diagnostics
      global
      increments_count
      no_display
      sets_plan
      subtest_id
      summary
      terminate
      uuid
  };
  our %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  our $CYCLE_DETECT = 0;
  sub _get_facet_data {
      my $in = shift;
  
      if (blessed($in) && $in->isa('Test2::Event')) {
          confess "Cycle between Facets2Legacy and $in\->facet_data() (Did you forget to override the facet_data() method?)"
              if $CYCLE_DETECT;
  
          local $CYCLE_DETECT = 1;
          return $in->facet_data;
      }
  
      return $in if ref($in) eq 'HASH';
  
      croak "'$in' Does not appear to be either a Test::Event or an EventFacet hashref";
  }
  
  sub causes_fail {
      my $facet_data = _get_facet_data(shift @_);
  
      return 1 if $facet_data->{errors} && grep { $_->{fail} } @{$facet_data->{errors}};
  
      if (my $control = $facet_data->{control}) {
          return 1 if $control->{halt};
          return 1 if $control->{terminate};
      }
  
      return 0 if $facet_data->{amnesty} && @{$facet_data->{amnesty}};
      return 1 if $facet_data->{assert} && !$facet_data->{assert}->{pass};
      return 0;
  }
  
  sub diagnostics {
      my $facet_data = _get_facet_data(shift @_);
      return 1 if $facet_data->{errors} && @{$facet_data->{errors}};
      return 0 unless $facet_data->{info} && @{$facet_data->{info}};
      return (grep { $_->{debug} } @{$facet_data->{info}}) ? 1 : 0;
  }
  
  sub global {
      my $facet_data = _get_facet_data(shift @_);
      return 0 unless $facet_data->{control};
      return $facet_data->{control}->{global};
  }
  
  sub increments_count {
      my $facet_data = _get_facet_data(shift @_);
      return $facet_data->{assert} ? 1 : 0;
  }
  
  sub no_display {
      my $facet_data = _get_facet_data(shift @_);
      return 0 unless $facet_data->{about};
      return $facet_data->{about}->{no_display};
  }
  
  sub sets_plan {
      my $facet_data = _get_facet_data(shift @_);
      my $plan = $facet_data->{plan} or return;
      my @out = ($plan->{count} || 0);
  
      if ($plan->{skip}) {
          push @out => 'SKIP';
          push @out => $plan->{details} if defined $plan->{details};
      }
      elsif ($plan->{none}) {
          push @out => 'NO PLAN'
      }
  
      return @out;
  }
  
  sub subtest_id {
      my $facet_data = _get_facet_data(shift @_);
      return undef unless $facet_data->{parent};
      return $facet_data->{parent}->{hid};
  }
  
  sub summary {
      my $facet_data = _get_facet_data(shift @_);
      return '' unless $facet_data->{about} && $facet_data->{about}->{details};
      return $facet_data->{about}->{details};
  }
  
  sub terminate {
      my $facet_data = _get_facet_data(shift @_);
      return undef unless $facet_data->{control};
      return $facet_data->{control}->{terminate};
  }
  
  sub uuid {
      my $in = shift;
  
      if ($CYCLE_DETECT) {
          if (blessed($in) && $in->isa('Test2::Event')) {
              my $meth = $in->can('uuid');
              $meth = $in->can('SUPER::uuid') if $meth == \&uuid;
              my $uuid = $in->$meth if $meth && $meth != \&uuid;
              return $uuid if $uuid;
          }
  
          return undef;
      }
  
      my $facet_data = _get_facet_data($in);
      return $facet_data->{about}->{uuid} if $facet_data->{about} && $facet_data->{about}->{uuid};
  
      return undef;
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::Facets2Legacy - Convert facet data to the legacy event API.
  
  =head1 DESCRIPTION
  
  This module exports several subroutines from the older event API (see
  L<Test2::Event>). These subroutines can be used as methods on any object that
  provides a custom C<facet_data()> method. These subroutines can also be used as
  functions that take a facet data hashref as arguments.
  
  =head1 SYNOPSIS
  
  =head2 AS METHODS
  
      package My::Event;
  
      use Test2::Util::Facets2Legacy ':ALL';
  
      sub facet_data { return { ... } }
  
  Then to use it:
  
      my $e = My::Event->new(...);
  
      my $causes_fail = $e->causes_fail;
      my $summary     = $e->summary;
      ....
  
  =head2 AS FUNCTIONS
  
      use Test2::Util::Facets2Legacy ':ALL';
  
      my $f = {
          assert => { ... },
          info => [{...}, ...],
          control => {...},
          ...
      };
  
      my $causes_fail = causes_fail($f);
      my $summary     = summary($f);
  
  =head1 NOTE ON CYCLES
  
  When used as methods, all these subroutines call C<< $e->facet_data() >>. The
  default C<facet_data()> method in L<Test2::Event> relies on the legacy methods
  this module emulates in order to work. As a result of this it is very easy to
  create infinite recursion bugs.
  
  These methods have cycle detection and will throw an exception early if a cycle
  is detected. C<uuid()> is currently the only subroutine in this library that
  has a fallback behavior when cycles are detected.
  
  =head1 EXPORTS
  
  Nothing is exported by default. You must specify which methods to import, or
  use the ':ALL' tag.
  
  =over 4
  
  =item $bool = $e->causes_fail()
  
  =item $bool = causes_fail($f)
  
  Check if the event or facets result in a failing state.
  
  =item $bool = $e->diagnostics()
  
  =item $bool = diagnostics($f)
  
  Check if the event or facets contain any diagnostics information.
  
  =item $bool = $e->global()
  
  =item $bool = global($f)
  
  Check if the event or facets need to be globally processed.
  
  =item $bool = $e->increments_count()
  
  =item $bool = increments_count($f)
  
  Check if the event or facets make an assertion.
  
  =item $bool = $e->no_display()
  
  =item $bool = no_display($f)
  
  Check if the event or facets should be rendered or hidden.
  
  =item ($max, $directive, $reason) = $e->sets_plan()
  
  =item ($max, $directive, $reason) = sets_plan($f)
  
  Check if the event or facets set a plan, and return the plan details.
  
  =item $id = $e->subtest_id()
  
  =item $id = subtest_id($f)
  
  Get the subtest id, if any.
  
  =item $string = $e->summary()
  
  =item $string = summary($f)
  
  Get the summary of the event or facets hash, if any.
  
  =item $undef_or_int = $e->terminate()
  
  =item $undef_or_int = terminate($f)
  
  Check if the event or facets should result in process termination, if so the
  exit code is returned (which could be 0). undef is returned if no termination
  is requested.
  
  =item $uuid = $e->uuid()
  
  =item $uuid = uuid($f)
  
  Get the UUID of the facets or event.
  
  B<Note:> This will fall back to C<< $e->SUPER::uuid() >> if a cycle is
  detected and an event is used as the argument.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_FACETS2LEGACY

$fatpacked{"Test2/Util/HashBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_HASHBASE';
  package Test2::Util::HashBase;
  use strict;
  use warnings;
  
  our $VERSION = '1.302136';
  
  #################################################################
  #                                                               #
  #  This is a generated file! Do not modify this file directly!  #
  #  Use hashbase_inc.pl script to regenerate this file.          #
  #  The script is part of the Object::HashBase distribution.     #
  #  Note: You can modify the version number above this comment   #
  #  if needed, that is fine.                                     #
  #                                                               #
  #################################################################
  
  {
      no warnings 'once';
      $Test2::Util::HashBase::HB_VERSION = '0.006';
      *Test2::Util::HashBase::ATTR_SUBS = \%Object::HashBase::ATTR_SUBS;
      *Test2::Util::HashBase::ATTR_LIST = \%Object::HashBase::ATTR_LIST;
      *Test2::Util::HashBase::VERSION   = \%Object::HashBase::VERSION;
      *Test2::Util::HashBase::CAN_CACHE = \%Object::HashBase::CAN_CACHE;
  }
  
  
  require Carp;
  {
      no warnings 'once';
      $Carp::Internal{+__PACKAGE__} = 1;
  }
  
  BEGIN {
      # these are not strictly equivalent, but for out use we don't care
      # about order
      *_isa = ($] >= 5.010 && require mro) ? \&mro::get_linear_isa : sub {
          no strict 'refs';
          my @packages = ($_[0]);
          my %seen;
          for my $package (@packages) {
              push @packages, grep !$seen{$_}++, @{"$package\::ISA"};
          }
          return \@packages;
      }
  }
  
  my %STRIP = (
      '^' => 1,
      '-' => 1,
  );
  
  sub import {
      my $class = shift;
      my $into  = caller;
  
      # Make sure we list the OLDEST version used to create this class.
      my $ver = $Test2::Util::HashBase::HB_VERSION || $Test2::Util::HashBase::VERSION;
      $Test2::Util::HashBase::VERSION{$into} = $ver if !$Test2::Util::HashBase::VERSION{$into} || $Test2::Util::HashBase::VERSION{$into} > $ver;
  
      my $isa = _isa($into);
      my $attr_list = $Test2::Util::HashBase::ATTR_LIST{$into} ||= [];
      my $attr_subs = $Test2::Util::HashBase::ATTR_SUBS{$into} ||= {};
  
      my %subs = (
          ($into->can('new') ? () : (new => \&_new)),
          (map %{$Test2::Util::HashBase::ATTR_SUBS{$_} || {}}, @{$isa}[1 .. $#$isa]),
          (
              map {
                  my $p = substr($_, 0, 1);
                  my $x = $_;
                  substr($x, 0, 1) = '' if $STRIP{$p};
                  push @$attr_list => $x;
                  my ($sub, $attr) = (uc $x, $x);
                  $sub => ($attr_subs->{$sub} = sub() { $attr }),
                      $attr => sub { $_[0]->{$attr} },
                        $p eq '-' ? ("set_$attr" => sub { Carp::croak("'$attr' is read-only") })
                      : $p eq '^' ? ("set_$attr" => sub { Carp::carp("set_$attr() is deprecated"); $_[0]->{$attr} = $_[1] })
                      : ("set_$attr" => sub { $_[0]->{$attr} = $_[1] }),
              } @_
          ),
      );
  
      no strict 'refs';
      *{"$into\::$_"} = $subs{$_} for keys %subs;
  }
  
  sub attr_list {
      my $class = shift;
  
      my $isa = _isa($class);
  
      my %seen;
      my @list = grep { !$seen{$_}++ } map {
          my @out;
  
          if (0.004 > ($Test2::Util::HashBase::VERSION{$_} || 0)) {
              Carp::carp("$_ uses an inlined version of Test2::Util::HashBase too old to support attr_list()");
          }
          else {
              my $list = $Test2::Util::HashBase::ATTR_LIST{$_};
              @out = $list ? @$list : ()
          }
  
          @out;
      } reverse @$isa;
  
      return @list;
  }
  
  sub _new {
      my $class = shift;
  
      my $self;
  
      if (@_ == 1) {
          my $arg = shift;
          my $type = ref($arg);
  
          if ($type eq 'HASH') {
              $self = bless({%$arg}, $class)
          }
          else {
              Carp::croak("Not sure what to do with '$type' in $class constructor")
                  unless $type eq 'ARRAY';
  
              my %proto;
              my @attributes = attr_list($class);
              while (@$arg) {
                  my $val = shift @$arg;
                  my $key = shift @attributes or Carp::croak("Too many arguments for $class constructor");
                  $proto{$key} = $val;
              }
  
              $self = bless(\%proto, $class);
          }
      }
      else {
          $self = bless({@_}, $class);
      }
  
      $Test2::Util::HashBase::CAN_CACHE{$class} = $self->can('init')
          unless exists $Test2::Util::HashBase::CAN_CACHE{$class};
  
      $self->init if $Test2::Util::HashBase::CAN_CACHE{$class};
  
      $self;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::HashBase - Build hash based classes.
  
  =head1 SYNOPSIS
  
  A class:
  
      package My::Class;
      use strict;
      use warnings;
  
      # Generate 3 accessors
      use Test2::Util::HashBase qw/foo -bar ^baz/;
  
      # Chance to initialize defaults
      sub init {
          my $self = shift;    # No other args
          $self->{+FOO} ||= "foo";
          $self->{+BAR} ||= "bar";
          $self->{+BAZ} ||= "baz";
      }
  
      sub print {
          print join ", " => map { $self->{$_} } FOO, BAR, BAZ;
      }
  
  Subclass it
  
      package My::Subclass;
      use strict;
      use warnings;
  
      # Note, you should subclass before loading HashBase.
      use base 'My::Class';
      use Test2::Util::HashBase qw/bat/;
  
      sub init {
          my $self = shift;
  
          # We get the constants from the base class for free.
          $self->{+FOO} ||= 'SubFoo';
          $self->{+BAT} ||= 'bat';
  
          $self->SUPER::init();
      }
  
  use it:
  
      package main;
      use strict;
      use warnings;
      use My::Class;
  
      # These are all functionally identical
      my $one   = My::Class->new(foo => 'MyFoo', bar => 'MyBar');
      my $two   = My::Class->new({foo => 'MyFoo', bar => 'MyBar'});
      my $three = My::Class->new(['MyFoo', 'MyBar']);
  
      # Accessors!
      my $foo = $one->foo;    # 'MyFoo'
      my $bar = $one->bar;    # 'MyBar'
      my $baz = $one->baz;    # Defaulted to: 'baz'
  
      # Setters!
      $one->set_foo('A Foo');
  
      #'-bar' means read-only, so the setter will throw an exception (but is defined).
      $one->set_bar('A bar');
  
      # '^baz' means deprecated setter, this will warn about the setter being
      # deprecated.
      $one->set_baz('A Baz');
  
      $one->{+FOO} = 'xxx';
  
  =head1 DESCRIPTION
  
  This package is used to generate classes based on hashrefs. Using this class
  will give you a C<new()> method, as well as generating accessors you request.
  Generated accessors will be getters, C<set_ACCESSOR> setters will also be
  generated for you. You also get constants for each accessor (all caps) which
  return the key into the hash for that accessor. Single inheritance is also
  supported.
  
  =head1 THIS IS A BUNDLED COPY OF HASHBASE
  
  This is a bundled copy of L<Object::HashBase>. This file was generated using
  the
  C</home/exodist/perl5/perlbrew/perls/main/bin/hashbase_inc.pl>
  script.
  
  =head1 METHODS
  
  =head2 PROVIDED BY HASH BASE
  
  =over 4
  
  =item $it = $class->new(%PAIRS)
  
  =item $it = $class->new(\%PAIRS)
  
  =item $it = $class->new(\@ORDERED_VALUES)
  
  Create a new instance.
  
  HashBase will not export C<new()> if there is already a C<new()> method in your
  packages inheritance chain.
  
  B<If you do not want this method you can define your own> you just have to
  declare it before loading L<Test2::Util::HashBase>.
  
      package My::Package;
  
      # predeclare new() so that HashBase does not give us one.
      sub new;
  
      use Test2::Util::HashBase qw/foo bar baz/;
  
      # Now we define our own new method.
      sub new { ... }
  
  This makes it so that HashBase sees that you have your own C<new()> method.
  Alternatively you can define the method before loading HashBase instead of just
  declaring it, but that scatters your use statements.
  
  The most common way to create an object is to pass in key/value pairs where
  each key is an attribute and each value is what you want assigned to that
  attribute. No checking is done to verify the attributes or values are valid,
  you may do that in C<init()> if desired.
  
  If you would like, you can pass in a hashref instead of pairs. When you do so
  the hashref will be copied, and the copy will be returned blessed as an object.
  There is no way to ask HashBase to bless a specific hashref.
  
  In some cases an object may only have 1 or 2 attributes, in which case a
  hashref may be too verbose for your liking. In these cases you can pass in an
  arrayref with only values. The values will be assigned to attributes in the
  order the attributes were listed. When there is inheritance involved the
  attributes from parent classes will come before subclasses.
  
  =back
  
  =head2 HOOKS
  
  =over 4
  
  =item $self->init()
  
  This gives you the chance to set some default values to your fields. The only
  argument is C<$self> with its indexes already set from the constructor.
  
  B<Note:> Test2::Util::HashBase checks for an init using C<< $class->can('init') >>
  during construction. It DOES NOT call C<can()> on the created object. Also note
  that the result of the check is cached, it is only ever checked once, the first
  time an instance of your class is created. This means that adding an C<init()>
  method AFTER the first construction will result in it being ignored.
  
  =back
  
  =head1 ACCESSORS
  
  =head2 READ/WRITE
  
  To generate accessors you list them when using the module:
  
      use Test2::Util::HashBase qw/foo/;
  
  This will generate the following subs in your namespace:
  
  =over 4
  
  =item foo()
  
  Getter, used to get the value of the C<foo> field.
  
  =item set_foo()
  
  Setter, used to set the value of the C<foo> field.
  
  =item FOO()
  
  Constant, returns the field C<foo>'s key into the class hashref. Subclasses will
  also get this function as a constant, not simply a method, that means it is
  copied into the subclass namespace.
  
  The main reason for using these constants is to help avoid spelling mistakes
  and similar typos. It will not help you if you forget to prefix the '+' though.
  
  =back
  
  =head2 READ ONLY
  
      use Test2::Util::HashBase qw/-foo/;
  
  =over 4
  
  =item set_foo()
  
  Throws an exception telling you the attribute is read-only. This is exported to
  override any active setters for the attribute in a parent class.
  
  =back
  
  =head2 DEPRECATED SETTER
  
      use Test2::Util::HashBase qw/^foo/;
  
  =over 4
  
  =item set_foo()
  
  This will set the value, but it will also warn you that the method is
  deprecated.
  
  =back
  
  =head1 SUBCLASSING
  
  You can subclass an existing HashBase class.
  
      use base 'Another::HashBase::Class';
      use Test2::Util::HashBase qw/foo bar baz/;
  
  The base class is added to C<@ISA> for you, and all constants from base classes
  are added to subclasses automatically.
  
  =head1 GETTING A LIST OF ATTRIBUTES FOR A CLASS
  
  Test2::Util::HashBase provides a function for retrieving a list of attributes for an
  Test2::Util::HashBase class.
  
  =over 4
  
  =item @list = Test2::Util::HashBase::attr_list($class)
  
  =item @list = $class->Test2::Util::HashBase::attr_list()
  
  Either form above will work. This will return a list of attributes defined on
  the object. This list is returned in the attribute definition order, parent
  class attributes are listed before subclass attributes. Duplicate attributes
  will be removed before the list is returned.
  
  B<Note:> This list is used in the C<< $class->new(\@ARRAY) >> constructor to
  determine the attribute to which each value will be paired.
  
  =back
  
  =head1 SOURCE
  
  The source code repository for HashBase can be found at
  F<http://github.com/Test-More/HashBase/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_HASHBASE

$fatpacked{"Test2/Util/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TRACE';
  package Test2::Util::Trace;
  require Test2::EventFacet::Trace;
  @ISA = ('Test2::EventFacet::Trace');
  
  our $VERSION = '1.302136';
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test2::Util::Trace - Legacy wrapper fro L<Test2::EventFacet::Trace>.
  
  =head1 DESCRIPTION
  
  All the functionality for this class has been moved to
  L<Test2::EventFacet::Trace>.
  
  =head1 SOURCE
  
  The source code repository for Test2 can be found at
  F<http://github.com/Test-More/test-more/>.
  
  =head1 MAINTAINERS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item Chad Granum E<lt>exodist@cpan.orgE<gt>
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2018 Chad Granum E<lt>exodist@cpan.orgE<gt>.
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  =cut
TEST2_UTIL_TRACE

$fatpacked{"Types/Serialiser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER';
  =head1 NAME
  
  Types::Serialiser - simple data types for common serialisation formats
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  This module provides some extra datatypes that are used by common
  serialisation formats such as JSON or CBOR. The idea is to have a
  repository of simple/small constants and containers that can be shared by
  different implementations so they become interoperable between each other.
  
  =cut
  
  package Types::Serialiser;
  
  use common::sense; # required to suppress annoying warnings
  
  our $VERSION = '1.0';
  
  =head1 SIMPLE SCALAR CONSTANTS
  
  Simple scalar constants are values that are overloaded to act like simple
  Perl values, but have (class) type to differentiate them from normal Perl
  scalars. This is necessary because these have different representations in
  the serialisation formats.
  
  =head2 BOOLEANS (Types::Serialiser::Boolean class)
  
  This type has only two instances, true and false. A natural representation
  for these in Perl is C<1> and C<0>, but serialisation formats need to be
  able to differentiate between them and mere numbers.
  
  =over 4
  
  =item $Types::Serialiser::true, Types::Serialiser::true
  
  This value represents the "true" value. In most contexts is acts like
  the number C<1>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::true>) or the constant form (C<Types::Serialiser::true>).
  
  The constant is represented as a reference to a scalar containing C<1> -
  implementations are allowed to directly test for this.
  
  =item $Types::Serialiser::false, Types::Serialiser::false
  
  This value represents the "false" value. In most contexts is acts like
  the number C<0>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::false>) or the constant form (C<Types::Serialiser::false>).
  
  The constant is represented as a reference to a scalar containing C<0> -
  implementations are allowed to directly test for this.
  
  =item $is_bool = Types::Serialiser::is_bool $value
  
  Returns true iff the C<$value> is either C<$Types::Serialiser::true> or
  C<$Types::Serialiser::false>.
  
  For example, you could differentiate between a perl true value and a
  C<Types::Serialiser::true> by using this:
  
     $value && Types::Serialiser::is_bool $value
  
  =item $is_true = Types::Serialiser::is_true $value
  
  Returns true iff C<$value> is C<$Types::Serialiser::true>.
  
  =item $is_false = Types::Serialiser::is_false $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::false>.
  
  =back
  
  =head2 ERROR (Types::Serialiser::Error class)
  
  This class has only a single instance, C<error>. It is used to signal
  an encoding or decoding error. In CBOR for example, and object that
  couldn't be encoded will be represented by a CBOR undefined value, which
  is represented by the error value in Perl.
  
  =over 4
  
  =item $Types::Serialiser::error, Types::Serialiser::error
  
  This value represents the "error" value. Accessing values of this type
  will throw an exception.
  
  The constant is represented as a reference to a scalar containing C<undef>
  - implementations are allowed to directly test for this.
  
  =item $is_error = Types::Serialiser::is_error $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::error>.
  
  =back
  
  =cut
  
  BEGIN {
     # for historical reasons, and to avoid extra dependencies in JSON::PP,
     # we alias *Types::Serialiser::Boolean with JSON::PP::Boolean.
     package JSON::PP::Boolean;
  
     *Types::Serialiser::Boolean:: = *JSON::PP::Boolean::;
  }
  
  {
     # this must done before blessing to work around bugs
     # in perl < 5.18 (it seems to be fixed in 5.18).
     package Types::Serialiser::BooleanBase;
  
     use overload
        "0+"     => sub { ${$_[0]} },
        "++"     => sub { $_[0] = ${$_[0]} + 1 },
        "--"     => sub { $_[0] = ${$_[0]} - 1 },
        fallback => 1;
  
     @Types::Serialiser::Boolean::ISA = Types::Serialiser::BooleanBase::;
  }
  
  our $true  = do { bless \(my $dummy = 1), Types::Serialiser::Boolean:: };
  our $false = do { bless \(my $dummy = 0), Types::Serialiser::Boolean:: };
  our $error = do { bless \(my $dummy    ), Types::Serialiser::Error::   };
  
  sub true  () { $true  }
  sub false () { $false }
  sub error () { $error }
  
  sub is_bool  ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_true  ($) {  $_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_false ($) { !$_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_error ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Error::   }
  
  package Types::Serialiser::Error;
  
  sub error {
     require Carp;
     Carp::croak ("caught attempt to use the Types::Serialiser::error value");
  };
  
  use overload
     "0+"     => \&error,
     "++"     => \&error,
     "--"     => \&error,
     fallback => 1;
  
  =head1 NOTES FOR XS USERS
  
  The recommended way to detect whether a scalar is one of these objects
  is to check whether the stash is the C<Types::Serialiser::Boolean> or
  C<Types::Serialiser::Error> stash, and then follow the scalar reference to
  see if it's C<1> (true), C<0> (false) or C<undef> (error).
  
  While it is possible to use an isa test, directly comparing stash pointers
  is faster and guaranteed to work.
  
  For historical reasons, the C<Types::Serialiser::Boolean> stash is
  just an alias for C<JSON::PP::Boolean>. When printed, the classname
  with usually be C<JSON::PP::Boolean>, but isa tests and stash pointer
  comparison will normally work correctly (i.e. Types::Serialiser::true ISA
  JSON::PP::Boolean, but also ISA Types::Serialiser::Boolean).
  
  =head1 A GENERIC OBJECT SERIALIATION PROTOCOL
  
  This section explains the object serialisation protocol used by
  L<CBOR::XS>. It is meant to be generic enough to support any kind of
  generic object serialiser.
  
  This protocol is called "the Types::Serialiser object serialisation
  protocol".
  
  =head2 ENCODING
  
  When the encoder encounters an object that it cannot otherwise encode (for
  example, L<CBOR::XS> can encode a few special types itself, and will first
  attempt to use the special C<TO_CBOR> serialisation protocol), it will
  look up the C<FREEZE> method on the object.
  
  Note that the C<FREEZE> method will normally be called I<during> encoding,
  and I<MUST NOT> change the data structure that is being encoded in any
  way, or it might cause memory corruption or worse.
  
  If it exists, it will call it with two arguments: the object to serialise,
  and a constant string that indicates the name of the data model. For
  example L<CBOR::XS> uses C<CBOR>, and the L<JSON> and L<JSON::XS> modules
  (or any other JSON serialiser), would use C<JSON> as second argument.
  
  The C<FREEZE> method can then return zero or more values to identify the
  object instance. The serialiser is then supposed to encode the class name
  and all of these return values (which must be encodable in the format)
  using the relevant form for Perl objects. In CBOR for example, there is a
  registered tag number for encoded perl objects.
  
  The values that C<FREEZE> returns must be serialisable with the serialiser
  that calls it. Therefore, it is recommended to use simple types such as
  strings and numbers, and maybe array references and hashes (basically, the
  JSON data model). You can always use a more complex format for a specific
  data model by checking the second argument, the data model.
  
  The "data model" is not the same as the "data format" - the data model
  indicates what types and kinds of return values can be returned from
  C<FREEZE>. For example, in C<CBOR> it is permissible to return tagged CBOR
  values, while JSON does not support these at all, so C<JSON> would be a
  valid (but too limited) data model name for C<CBOR::XS>. similarly, a
  serialising format that supports more or less the same data model as JSON
  could use C<JSON> as data model without losing anything.
  
  =head2 DECODING
  
  When the decoder then encounters such an encoded perl object, it should
  look up the C<THAW> method on the stored classname, and invoke it with the
  classname, the constant string to identify the data model/data format, and
  all the return values returned by C<FREEZE>.
  
  =head2 EXAMPLES
  
  See the C<OBJECT SERIALISATION> section in the L<CBOR::XS> manpage for
  more details, an example implementation, and code examples.
  
  Here is an example C<FREEZE>/C<THAW> method pair:
  
     sub My::Object::FREEZE {
        my ($self, $model) = @_;
  
        ($self->{type}, $self->{id}, $self->{variant})
     }
  
     sub My::Object::THAW {
        my ($class, $model, $type, $id, $variant) = @_;
  
        $class->new (type => $type, id => $id, variant => $variant)
     }
  
  =head1 BUGS
  
  The use of L<overload> makes this module much heavier than it should be
  (on my system, this module: 4kB RSS, overload: 260kB RSS).
  
  =head1 SEE ALSO
  
  Currently, L<JSON::XS> and L<CBOR::XS> use these types.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER

$fatpacked{"Types/Serialiser/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER_ERROR';
  =head1 NAME
  
  Types::Serialiser::Error - dummy module for Types::Serialiser
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules that assume that class name equals module name. See
  L<Types::Serialiser> for more info about this class.
  
  =cut
  
  use Types::Serialiser ();
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER_ERROR

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  package YAML;
  our $VERSION = '1.13';
  
  use YAML::Mo;
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  use strict; use warnings;
  package YAML::Any;
  our $VERSION = '1.13';
  
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::croak(@_);
  }
  
  1;
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo);
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0],
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) =
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      require YAML;
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} =
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) =
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash.
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
  
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 0 if $_[0] eq '-';
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  
  use YAML::Mo;
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
  
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  
  use YAML::Mo;
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)}
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
       YAML_PARSE_ERR_NO_ANCHOR
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';
  my $LIT_CHAR_RX = "\\$LIT_CHAR";
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS')
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE')
        if length($self->stream) and
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) =
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) =
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE');
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface);
  }
  
  # Morph a node to it's explicit type
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
  
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
  
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      # https://rt.cpan.org/Public/Bug/Display.html?id=90593
      if ($self->inline =~ /^"((?:(?:\\"|[^"]){0,32766}){0,32766})"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:(?:''|[^']){0,32766}){0,32766})'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or
                  $self->die('YAML_PARSE_ERR_NONSPACE_INDENTATION');
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
  
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos;
  
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
  
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  
  use YAML::Mo;
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict; use warnings;
  package YAML::Marshall;
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo; $VERSION = '0.88';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict; use warnings;
  package YAML::Node;
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
          $self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
          $self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
          $self = tied(*{$_[0]});
      }
      else {
          $self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
                      ($type eq 'HASH') ? 'mapping' :
                      $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
          yaml_scalar->new($self, $_[1]);
          return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{TAG} = YAML::Tag->new($value);
          return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{KEYS} = $value;
          return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}};
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
          return (grep {$_ eq $key} @{$self->{KEYS}})
                 ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
          $self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
          $self->{HASH}{$key} = $value;
      }
      else {
          if (not grep {$_ eq $key} @{$self->{KEYS}}) {
              push(@{$self->{KEYS}}, $key);
          }
          $self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
          $return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
          $return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
          if ($self->{KEYS}[$i] eq $key) {
              splice(@{$self->{KEYS}}, $i, 1);
          }
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict; use warnings;
  package YAML::Tag;
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  
  use YAML::Mo;
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      }
      elsif ($type eq 'GLOB') {
          # blessed glob support is minimal, and will not round-trip
          # initial aim: to not cause an error
          return YAML::Type::glob->yaml_dump($value, $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      # $_[0] remains as the glob
      my $tag = pop @_ if 2==@_;
  
      $tag = '!perl/glob:' unless defined $tag;
      my $ynode = YAML::Node->new({}, $tag);
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value;
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0;
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
YAML_TYPES

$fatpacked{"ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OK';
  package ok;
  our $VERSION = '1.302136';
  
  use strict;
  use Test::More ();
  
  sub import {
      shift;
  
      if (@_) {
          goto &Test::More::pass if $_[0] eq 'ok';
          goto &Test::More::use_ok;
      }
  
      # No argument list - croak as if we are prototyped like use_ok()
      my (undef, $file, $line) = caller();
      ($file =~ /^\(eval/) or die "Not enough arguments for 'use ok' at $file line $line\n";
  }
  
  
  __END__
  
  =encoding UTF-8
  
  =head1 NAME
  
  ok - Alternative to Test::More::use_ok
  
  =head1 SYNOPSIS
  
      use ok 'Some::Module';
  
  =head1 DESCRIPTION
  
  With this module, simply change all C<use_ok> in test scripts to C<use ok>,
  and they will be executed at C<BEGIN> time.
  
  Please see L<Test::use::ok> for the full description.
  
  =head1 CC0 1.0 Universal
  
  To the extent possible under law, 唐鳳 has waived all copyright and related
  or neighboring rights to L<Test-use-ok>.
  
  This work is published from Taiwan.
  
  L<http://creativecommons.org/publicdomain/zero/1.0>
  
  =cut
OK

$fatpacked{"private-Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PRIVATE-ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.15009";
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  sub import {
      shift;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      Error::subs->import(@_);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
  
      unless (@_) {
         $LAST = undef;
         return;
      }
  
      my $pkg = shift;
      return unless ref($pkg);
  
      undef $ERROR{$pkg} if defined $ERROR{$pkg};
  }
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  # Allow error propagation, ie
  #
  # $ber->encode(...) or
  #    return Error->prior($ber)->associate($ldap);
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
  
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  
  sub blessed {
  	my $item = shift;
  	local $@; # don't kill an outer $@
  	ref $item and eval { $item->can('can') };
  }
  
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->());
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN);
  			my $ok = eval {
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = defined($Error::THROWN)
  				    ? $Error::THROWN : $@;
                  $err = $Error::ObjectifyCallback->({'text' =>$err})
                      unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
  	    my $ok = eval {
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = defined($Error::THROWN)
  			? $Error::THROWN : $@;
  
          $err = $Error::ObjectifyCallback->({'text' =>$err})
              unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
      local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = defined($Error::THROWN) ? $Error::THROWN : $@
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
  	unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
  
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple -text => "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to its constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =over 4
  
  =item Error::Simple
  
  This class can be used to hold simple error strings and values. Its
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this information will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  =back
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overridden by the user.
  
  It accepts a single argument which is a hash reference to named parameters.
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  =head1 MAINTAINER
  
  Shlomi Fish <shlomif@iglu.org.il>
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =cut
PRIVATE-ERROR

$fatpacked{"x86_64-linux/JSON/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_JSON_XS';
  =head1 NAME
  
  JSON::XS - JSON serialising/deserialising, done correctly and fast
  
  =encoding utf-8
  
  JSON::XS - 正しくて高速な JSON シリアライザ/デシリアライザ
             (http://fleur.hio.jp/perldoc/mix/lib/JSON/XS.html)
  
  =head1 SYNOPSIS
  
   use JSON::XS;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::XS->new->ascii->pretty->allow_nonref;
   $pretty_printed_unencoded = $coder->encode ($perl_scalar);
   $perl_scalar = $coder->decode ($unicode_json_text);
  
   # Note that JSON version 2.0 and above will automatically use JSON::XS
   # if available, at virtually no speed overhead either, so you should
   # be able to just:
   
   use JSON;
  
   # and do the same things, except that you have a pure-perl fallback now.
  
  =head1 DESCRIPTION
  
  This module converts Perl data structures to JSON and vice versa. Its
  primary goal is to be I<correct> and its secondary goal is to be
  I<fast>. To reach the latter goal it was written in C.
  
  Beginning with version 2.0 of the JSON module, when both JSON and
  JSON::XS are installed, then JSON will fall back on JSON::XS (this can be
  overridden) with no overhead due to emulation (by inheriting constructor
  and methods). If JSON::XS is not available, it will fall back to the
  compatible JSON::PP module as backend, so using JSON instead of JSON::XS
  gives you a portable JSON API that can be fast when you need and doesn't
  require a C compiler when that is a problem.
  
  As this is the n-th-something JSON module on CPAN, what was the reason
  to write yet another JSON module? While it seems there are many JSON
  modules, none of them correctly handle all corner cases, and in most cases
  their maintainers are unresponsive, gone missing, or not listening to bug
  reports for other reasons.
  
  See MAPPING, below, on how JSON::XS maps perl values to JSON values and
  vice versa.
  
  =head2 FEATURES
  
  =over 4
  
  =item * correct Unicode handling
  
  This module knows how to handle Unicode, documents how and when it does
  so, and even documents what "correct" means.
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  =item * fast
  
  Compared to other JSON modules and other serialisers such as Storable,
  this module usually compares favourably in terms of speed, too.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an object
  oriented interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format
  possible (nice for simple line-based protocols), a pure-ASCII format
  (for when your transport is not 8-bit clean, still supports the whole
  Unicode range), or a pretty-printed format (for when you want to read that
  stuff). Or you can combine those features in whatever way you like.
  
  =back
  
  =cut
  
  package JSON::XS;
  
  use common::sense;
  
  our $VERSION = 3.01;
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(encode_json decode_json);
  
  use Exporter;
  use XSLoader;
  
  use Types::Serialiser ();
  
  =head1 FUNCTIONAL INTERFACE
  
  The following convenience methods are provided by this module. They are
  exported by default:
  
  =over 4
  
  =item $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
     $json_text = JSON::XS->new->utf8->encode ($perl_scalar)
  
  Except being faster.
  
  =item $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
     $perl_scalar = JSON::XS->new->utf8->decode ($json_text)
  
  Except being faster.
  
  =back
  
  
  =head1 A FEW NOTES ON UNICODE AND PERL
  
  Since this often leads to confusion, here are a few very clear words on
  how Unicode works in Perl, modulo bugs.
  
  =over 4
  
  =item 1. Perl strings can store characters with ordinal values > 255.
  
  This enables you to store Unicode characters as single characters in a
  Perl string - very natural.
  
  =item 2. Perl does I<not> associate an encoding with your strings.
  
  ... until you force it to, e.g. when matching it against a regex, or
  printing the scalar to a file, in which case Perl either interprets your
  string as locale-encoded text, octets/binary, or as Unicode, depending
  on various settings. In no case is an encoding stored together with your
  data, it is I<use> that decides encoding, not any magical meta data.
  
  =item 3. The internal utf-8 flag has no meaning with regards to the
  encoding of your string.
  
  Just ignore that flag unless you debug a Perl bug, a module written in
  XS or want to dive into the internals of perl. Otherwise it will only
  confuse you, as, despite the name, it says nothing about how your string
  is encoded. You can have Unicode strings with that flag set, with that
  flag clear, and you can have binary data with that flag set and that flag
  clear. Other possibilities exist, too.
  
  If you didn't know about that flag, just the better, pretend it doesn't
  exist.
  
  =item 4. A "Unicode String" is simply a string where each character can be
  validly interpreted as a Unicode code point.
  
  If you have UTF-8 encoded data, it is no longer a Unicode string, but a
  Unicode string encoded in UTF-8, giving you a binary string.
  
  =item 5. A string containing "high" (> 255) character values is I<not> a UTF-8 string.
  
  It's a fact. Learn to live with it.
  
  =back
  
  I hope this helps :)
  
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =over 4
  
  =item $json = new JSON::XS
  
  Creates a new JSON::XS object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::XS->new->utf8->space_after->encode ({a => [1,2]})
     => {"a": [1, 2]}
  
  =item $json = $json->ascii ([$enable])
  
  =item $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON::XS->new->ascii (1)->encode ([chr 0x10401])
    => ["\ud801\udc01"]
  
  =item $json = $json->latin1 ([$enable])
  
  =item $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =item $json = $json->utf8 ([$enable])
  
  =item $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this
  document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  =item $json = $json->pretty ([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Example, pretty-print some simple structure:
  
     my $json = JSON::XS->new->pretty(1)->encode ({a => [1,2]})
     =>
     {
        "a" : [
           1,
           2
        ]
     }
  
  =item $json = $json->indent ([$enable])
  
  =item $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =item $json = $json->space_before ([$enable])
  
  =item $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =item $json = $json->space_after ([$enable])
  
  =item $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =item $json = $json->relaxed ([$enable])
  
  =item $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =item $json = $json->canonical ([$enable])
  
  =item $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =item $json = $json->allow_nonref ([$enable])
  
  =item $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON::XS->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =item $json = $json->allow_unknown ([$enable])
  
  =item $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =item $json = $json->allow_blessed ([$enable])
  
  =item $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->convert_blessed ([$enable])
  
  =item $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =item $json = $json->allow_tags ([$enable])
  
  =item $enabled = $json->allow_tags
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<FREEZE> method on
  the object's class. If found, it will be used to serialise the object into
  a nonstandard tagged JSON value (that JSON decoders cannot decode).
  
  It also causes C<decode> to parse such tagged JSON values and deserialise
  them via a call to the C<THAW> method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion, and tagged JSON values will cause a parse error
  in C<decode>, as if tags were not part of the grammar.
  
  =item $json = $json->filter_json_object ([$coderef->($hashref)])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::XS->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]')
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =item $json = $json->filter_json_single_key_object ($key [=> $coderef->($value)])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::XS
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =item $json = $json->shrink ([$enable])
  
  =item $enabled = $json->get_shrink
  
  Perl usually over-allocates memory a bit when allocating space for
  strings. This flag optionally resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  The actual definition of what shrink does might change in future versions,
  but it will always try to save space at the expense of time.
  
  If C<$enable> is true (or missing), the string returned by C<encode> will
  be shrunk-to-fit, while all strings generated by C<decode> will also be
  shrunk-to-fit.
  
  If C<$enable> is false, then the normal perl allocation algorithms are used.
  If you work with your data, then this is likely to be faster.
  
  In the future, this setting might control other things, such as converting
  strings that look like integers or floats into integers or floats
  internally (there is no difference on the Perl level), saving space.
  
  =item $json = $json->max_depth ([$maximum_nesting_depth])
  
  =item $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing.
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json = $json->max_size ([$maximum_string_size])
  
  =item $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See SECURITY CONSIDERATIONS, below, for more info on why this is useful.
  
  =item $json_text = $json->encode ($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =item $perl_scalar = $json->decode ($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =item ($perl_scalar, $characters) = $json->decode_prefix ($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON::XS->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =back
  
  
  =head1 INCREMENTAL PARSING
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  JSON::XS will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =over 4
  
  =item [void, scalar or list context] = $json->incr_parse ([$string])
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
     my @objs = JSON::XS->new->incr_parse ("[5][7][1,2]");
  
  =item $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =item $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =item $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =back
  
  =head2 LIMITATIONS
  
  All options that affect decoding are supported, except
  C<allow_nonref>. The reason for this is that it cannot be made to work
  sensibly: JSON objects and arrays are self-delimited, i.e. you can
  concatenate them back to back and still decode them perfectly. This does
  not hold true for JSON numbers, however.
  
  For example, is the string C<1> a single JSON number, or is it simply the
  start of C<12>? Or is C<12> a single JSON number, or the concatenation
  of C<1> and C<2>? In neither case you can tell, and this is why JSON::XS
  takes the conservative route and disallows this case.
  
  =head2 EXAMPLES
  
  Some examples will make all this clearer. First, a simple example that
  works similarly to C<decode_prefix>: We want to decode the JSON object at
  the start of a string and identify the portion after the JSON object:
  
     my $text = "[1,2,3] hello";
  
     my $json = new JSON::XS;
  
     my $obj = $json->incr_parse ($text)
        or die "expected JSON object or array at beginning of string";
  
     my $tail = $json->incr_text;
     # $tail now contains " hello"
  
  Easy, isn't it?
  
  Now for a more complicated example: Imagine a hypothetical protocol where
  you read some requests from a TCP stream, and each request is a JSON
  array, without any separation between them (in fact, it is often useful to
  use newlines as "separators", as these get interpreted as whitespace at
  the start of the JSON text, which makes it possible to test said protocol
  with C<telnet>...).
  
  Here is how you'd do it (it is trivial to write this in an event-based
  manner):
  
     my $json = new JSON::XS;
  
     # read some data from the socket
     while (sysread $socket, my $buf, 4096) {
  
        # split and decode as many requests as possible
        for my $request ($json->incr_parse ($buf)) {
           # act on the $request
        }
     }
  
  Another complicated example: Assume you have a string with JSON objects
  or arrays, all separated by (optional) comma characters (e.g. C<[1],[2],
  [3]>). To parse them, we have to skip the commas between the JSON texts,
  and here is where the lvalue-ness of C<incr_text> comes in useful:
  
     my $text = "[1],[2], [3]";
     my $json = new JSON::XS;
  
     # void context, so no parsing done
     $json->incr_parse ($text);
  
     # now extract as many objects as possible. note the
     # use of scalar context so incr_text can be called.
     while (my $obj = $json->incr_parse) {
        # do something with $obj
  
        # now skip the optional comma
        $json->incr_text =~ s/^ \s* , //x;
     }
  
  Now lets go for a very complex example: Assume that you have a gigantic
  JSON array-of-objects, many gigabytes in size, and you want to parse it,
  but you cannot load it into memory fully (this has actually happened in
  the real world :).
  
  Well, you lost, you have to implement your own JSON parser. But JSON::XS
  can still help you: You implement a (very simple) array parser and let
  JSON decode the array elements, which are all full JSON objects on their
  own (this wouldn't work if the array elements could be JSON numbers, for
  example):
  
     my $json = new JSON::XS;
  
     # open the monster
     open my $fh, "<bigfile.json"
        or die "bigfile: $!";
  
     # first parse the initial "["
     for (;;) {
        sysread $fh, my $buf, 65536
           or die "read error: $!";
        $json->incr_parse ($buf); # void context, so no parsing
  
        # Exit the loop once we found and removed(!) the initial "[".
        # In essence, we are (ab-)using the $json object as a simple scalar
        # we append data to.
        last if $json->incr_text =~ s/^ \s* \[ //x;
     }
  
     # now we have the skipped the initial "[", so continue
     # parsing all the elements.
     for (;;) {
        # in this loop we read data until we got a single JSON object
        for (;;) {
           if (my $obj = $json->incr_parse) {
              # do something with $obj
              last;
           }
  
           # add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
        # in this loop we read data until we either found and parsed the
        # separating "," between elements, or the final "]"
        for (;;) {
           # first skip whitespace
           $json->incr_text =~ s/^\s*//;
  
           # if we find "]", we are done
           if ($json->incr_text =~ s/^\]//) {
              print "finished.\n";
              exit;
           }
  
           # if we find ",", we can continue with the next element
           if ($json->incr_text =~ s/^,//) {
              last;
           }
  
           # if we find anything else, we have a parse error!
           if (length $json->incr_text) {
              die "parse error near ", $json->incr_text;
           }
  
           # else add more data
           sysread $fh, my $buf, 65536
              or die "read error: $!";
           $json->incr_parse ($buf); # void context, so no parsing
        }
  
  This is a complex example, but most of the complexity comes from the fact
  that we are trying to be correct (bear with me if I am wrong, I never ran
  the above example :).
  
  
  
  =head1 MAPPING
  
  This section describes how JSON::XS maps Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserve object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, JSON::XS will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, JSON::XS only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<Types::Serialiser::true> and
  C<Types::Serialiser::false>, respectively. They are overloaded to act
  almost exactly like the numbers C<1> and C<0>. You can check whether
  a scalar is a JSON boolean by using the C<Types::Serialiser::is_bool>
  function (after C<use Types::Serialier>, of course).
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =item tagged values (C<< (I<tag>)I<value> >>).
  
  Another nonstandard extension to the JSON syntax, enabled with the
  C<allow_tags> setting, are tagged values. In this implementation, the
  I<tag> must be a perl package/class name encoded as a JSON string, and the
  I<value> must be a JSON array encoding optional constructor arguments.
  
  See L<OBJECT SERIALISATION>, below, for details.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. JSON::XS can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same datastructure will
  serialise to the same JSON text (given same settings and version of
  JSON::XS), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON.
  
  Since C<JSON::XS> uses the boolean model from L<Types::Serialiser>, you
  can also C<use Types::Serialiser> and then use C<Types::Serialiser::false>
  and C<Types::Serialiser::true> to improve readability.
  
     use Types::Serialiser;
     encode_json [\0, Types::Serialiser::true]      # yields [false,true]
  
  =item Types::Serialiser::true, Types::Serialiser::false
  
  These special values from the L<Types::Serialiser> module become JSON true
  and JSON false values, respectively. You can also use C<\1> and C<\0>
  directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a JSON string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a JSON number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As JSON cannot directly represent Perl objects, you have to choose between
  a pure JSON representation (without the ability to deserialise the object
  automatically again), and a nonstandard extension to the JSON syntax,
  tagged values.
  
  =head3 SERIALISATION
  
  What happens when C<JSON::XS> encounters a Perl object depends on the
  C<allow_blessed>, C<convert_blessed> and C<allow_tags> settings, which are
  used in this order:
  
  =over 4
  
  =item 1. C<allow_tags> is enabled and the object has a C<FREEZE> method.
  
  In this case, C<JSON::XS> uses the L<Types::Serialiser> object
  serialisation protocol to create a tagged JSON value, using a nonstandard
  extension to the JSON syntax.
  
  This works by invoking the C<FREEZE> method on the object, with the first
  argument being the object to serialise, and the second argument being the
  constant string C<JSON> to distinguish it from other serialisers.
  
  The C<FREEZE> method can return any number of values (i.e. zero or
  more). These values and the paclkage/classname of the object will then be
  encoded as a tagged JSON value in the following format:
  
     ("classname")[FREEZE return values...]
  
  e.g.:
  
     ("URI")["http://www.google.com/"]
     ("MyDate")[2013,10,29]
     ("ImageData::JPEG")["Z3...VlCg=="]
  
  For example, the hypothetical C<My::Object> C<FREEZE> method might use the
  objects C<type> and C<id> members to encode the object:
  
     sub My::Object::FREEZE {
        my ($self, $serialiser) = @_;
  
        ($self->{type}, $self->{id})
     }
  
  =item 2. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fatc that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 3. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 4. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  C<JSON::XS> throws an exception.
  
  =back
  
  =head3 DESERIALISATION
  
  For deserialisation there are only two cases to consider: either
  nonstandard tagging was used, in which case C<allow_tags> decides,
  or objects cannot be automatically be deserialised, in which
  case you can use postprocessing or the C<filter_json_object> or
  C<filter_json_single_key_object> callbacks to get some real objects our of
  your JSON.
  
  This section only considers the tagged value case: I a tagged JSON object
  is encountered during decoding and C<allow_tags> is disabled, a parse
  error will result (as if tagged values were not part of the grammar).
  
  If C<allow_tags> is enabled, C<JSON::XS> will look up the C<THAW> method
  of the package/classname used during serialisation (it will not attempt
  to load the package as a Perl module). If there is no such method, the
  decoding will fail with an error.
  
  Otherwise, the C<THAW> method is invoked with the classname as first
  argument, the constant string C<JSON> as second argument, and all the
  values from the JSON array (the values originally returned by the
  C<FREEZE> method) as remaining arguments.
  
  The method must then return the object. While technically you can return
  any Perl scalar, you might have to enable the C<enable_nonref> setting to
  make that work in all cases, so better return an actual blessed reference.
  
  As an example, let's implement a C<THAW> function that regenerates the
  C<My::Object> from the C<FREEZE> example earlier:
  
     sub My::Object::THAW {
        my ($class, $serialiser, $type, $id) = @_;
  
        $class->new (type => $type, id => $id)
     }
  
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  
  =head2 JSON and ECMAscript
  
  JSON syntax is based on how literals are represented in javascript (the
  not-standardised predecessor of ECMAscript) which is presumably why it is
  called "JavaScript Object Notation".
  
  However, JSON is not a subset (and also not a superset of course) of
  ECMAscript (the standard) or javascript (whatever browsers actually
  implement).
  
  If you want to use javascript's C<eval> function to "parse" JSON, you
  might run into parse errors for valid JSON texts, or the resulting data
  structure might not be queryable:
  
  One of the problems is that U+2028 and U+2029 are valid characters inside
  JSON strings, but are not allowed in ECMAscript string literals, so the
  following Perl fragment will not output something that can be guaranteed
  to be parsable by javascript's C<eval>:
  
     use JSON::XS;
  
     print encode_json [chr 0x2028];
  
  The right fix for this is to use a proper JSON parser in your javascript
  programs, and not rely on C<eval> (see for example Douglas Crockford's
  F<json2.js> parser).
  
  If this is not an option, you can, as a stop-gap measure, simply encode to
  ASCII-only JSON:
  
     use JSON::XS;
  
     print JSON::XS->new->ascii->encode ([chr 0x2028]);
  
  Note that this will enlarge the resulting JSON text quite a bit if you
  have many non-ASCII characters. You might be tempted to run some regexes
  to only escape U+2028 and U+2029, e.g.:
  
     # DO NOT USE THIS!
     my $json = JSON::XS->new->utf8->encode ([chr 0x2028]);
     $json =~ s/\xe2\x80\xa8/\\u2028/g; # escape U+2028
     $json =~ s/\xe2\x80\xa9/\\u2029/g; # escape U+2029
     print $json;
  
  Note that I<this is a bad idea>: the above only works for U+2028 and
  U+2029 and thus only for fully ECMAscript-compliant parsers. Many existing
  javascript implementations, however, have issues with other characters as
  well - using C<eval> naively simply I<will> cause problems.
  
  Another problem is that some javascript implementations reserve
  some property names for their own purposes (which probably makes
  them non-ECMAscript-compliant). For example, Iceweasel reserves the
  C<__proto__> property name for its own purposes.
  
  If that is a problem, you could parse try to filter the resulting JSON
  output for these property strings, e.g.:
  
     $json =~ s/"__proto__"\s*:/"__proto__renamed":/g;
  
  This works because C<__proto__> is not valid outside of strings, so every
  occurrence of C<"__proto__"\s*:> must be a string used as property name.
  
  If you know of other incompatibilities, please let me know.
  
  
  =head2 JSON and YAML
  
  You often hear that JSON is a subset of YAML. This is, however, a mass
  hysteria(*) and very far from the truth (as of the time of this writing),
  so let me state it clearly: I<in general, there is no way to configure
  JSON::XS to output a data structure as valid YAML> that works in all
  cases.
  
  If you really must use JSON::XS to generate YAML, you should use this
  algorithm (subject to change in future versions):
  
     my $to_yaml = JSON::XS->new->utf8->space_after (1);
     my $yaml = $to_yaml->encode ($ref) . "\n";
  
  This will I<usually> generate JSON texts that also parse as valid
  YAML. Please note that YAML has hardcoded limits on (simple) object key
  lengths that JSON doesn't have and also has different and incompatible
  unicode character escape syntax, so you should make sure that your hash
  keys are noticeably shorter than the 1024 "stream characters" YAML allows
  and that you do not have characters with codepoint values outside the
  Unicode BMP (basic multilingual page). YAML also does not allow C<\/>
  sequences in strings (which JSON::XS does not I<currently> generate, but
  other JSON generators might).
  
  There might be other incompatibilities that I am not aware of (or the YAML
  specification has been changed yet again - it does so quite often). In
  general you should not try to generate YAML with a JSON generator or vice
  versa, or try to parse JSON with a YAML parser or vice versa: chances are
  high that you will run into severe interoperability problems when you
  least expect it.
  
  =over 4
  
  =item (*)
  
  I have been pressured multiple times by Brian Ingerson (one of the
  authors of the YAML specification) to remove this paragraph, despite him
  acknowledging that the actual incompatibilities exist. As I was personally
  bitten by this "JSON is YAML" lie, I refused and said I will continue to
  educate people about these issues, so others do not run into the same
  problem again and again. After this, Brian called me a (quote)I<complete
  and worthless idiot>(unquote).
  
  In my opinion, instead of pressuring and insulting people who actually
  clarify issues with YAML and the wrong statements of some of its
  proponents, I would kindly suggest reading the JSON spec (which is not
  that difficult or long) and finally make YAML compatible to it, and
  educating users about the changes, instead of spreading lies about the
  real compatibility for many I<years> and trying to silence people who
  point out that it isn't true.
  
  Addendum/2009: the YAML 1.2 spec is still incompatible with JSON, even
  though the incompatibilities have been documented (and are known to Brian)
  for many years and the spec makes explicit claims that YAML is a superset
  of JSON. It would be so easy to fix, but apparently, bullying people and
  corrupting userdata is so much easier.
  
  =back
  
  
  =head2 SPEED
  
  It seems that JSON::XS is surprisingly fast, as shown in the following
  tables. They have been generated with the help of the C<eg/bench> program
  in the JSON::XS distribution, to make it easy to compare on your own
  system.
  
  First comes a comparison between various modules using
  a very short single-line JSON string (also available at
  L<http://dist.schmorp.de/misc/json/short.json>).
  
     {"method": "handleMessage", "params": ["user1",
     "we were just talking"], "id": null, "array":[1,11,234,-5,1e5,1e7,
     1,  0]}
  
  It shows the number of encodes/decodes per second (JSON::XS uses
  the functional interface, while JSON::XS/2 uses the OO interface
  with pretty-printing and hashkey sorting enabled, JSON::XS/3 enables
  shrink. JSON::DWIW/DS uses the deserialise function, while JSON::DWIW::FJ
  uses the from_json method). Higher is better:
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |  86302.551 | 102300.098 |
     JSON::DWIW/FJ |  86302.551 |  75983.768 |
     JSON::PP      |  15827.562 |   6638.658 |
     JSON::Syck    |  63358.066 |  47662.545 |
     JSON::XS      | 511500.488 | 511500.488 |
     JSON::XS/2    | 291271.111 | 388361.481 |
     JSON::XS/3    | 361577.931 | 361577.931 |
     Storable      |  66788.280 | 265462.278 |
     --------------+------------+------------+
  
  That is, JSON::XS is almost six times faster than JSON::DWIW on encoding,
  about five times faster on decoding, and over thirty to seventy times
  faster than JSON's pure perl implementation. It also compares favourably
  to Storable for small amounts of data.
  
  Using a longer test string (roughly 18KB, generated from Yahoo! Locals
  search API (L<http://dist.schmorp.de/misc/json/long.json>).
  
     module        |     encode |     decode |
     --------------|------------|------------|
     JSON::DWIW/DS |   1647.927 |   2673.916 |
     JSON::DWIW/FJ |   1630.249 |   2596.128 |
     JSON::PP      |    400.640 |     62.311 |
     JSON::Syck    |   1481.040 |   1524.869 |
     JSON::XS      |  20661.596 |   9541.183 |
     JSON::XS/2    |  10683.403 |   9416.938 |
     JSON::XS/3    |  20661.596 |   9400.054 |
     Storable      |  19765.806 |  10000.725 |
     --------------+------------+------------+
  
  Again, JSON::XS leads by far (except for Storable which non-surprisingly
  decodes a bit faster).
  
  On large strings containing lots of high Unicode characters, some modules
  (such as JSON::PC) seem to decode faster than JSON::XS, but the result
  will be broken due to missing (or wrong) Unicode handling. Others refuse
  to decode or encode properly, so it was impossible to prepare a fair
  comparison table for that case.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  When you are using JSON in a protocol, talking to untrusted potentially
  hostile creatures requires relatively few measures.
  
  First of all, your JSON decoder should be secure, that is, should not have
  any buffer overflows. Obviously, this module should ensure that and I am
  trying hard on making that true, but you never know.
  
  Second, you need to avoid resource-starving attacks. That means you should
  limit the size of JSON texts you accept, or make sure then when your
  resources run out, that's just fine (e.g. by using a separate process that
  can crash safely). The size of a JSON text in octets or characters is
  usually a good indication of the size of the resources required to decode
  it into a Perl structure. While JSON::XS can check the size of the JSON
  text, it might be too late when you already have it in memory, so you
  might want to check the size before you accept the string.
  
  Third, JSON::XS recurses using the C stack when decoding objects and
  arrays. The C stack is a limited resource: for instance, on my amd64
  machine with 8MB of stack size I can decode around 180k nested arrays but
  only 14k nested JSON objects (due to perl itself recursing deeply on croak
  to free the temporary). If that is exceeded, the program crashes. To be
  conservative, the default nesting limit is set to 512. If your process
  has a smaller stack, you should adjust this setting accordingly with the
  C<max_depth> method.
  
  Something else could bomb you, too, that I forgot to think of. In that
  case, you get to keep the pieces. I am always open for hints, though...
  
  Also keep in mind that JSON::XS might leak contents of your Perl data
  structures in its error messages, so when you serialise sensitive
  information you might want to make sure that exceptions thrown by JSON::XS
  will not end up in front of untrusted eyes.
  
  If you are using JSON::XS to return packets to consumption
  by JavaScript scripts in a browser you should have a look at
  L<http://blog.archive.jpsykes.com/47/practical-csrf-and-json-security/> to
  see whether you are vulnerable to some common attack vectors (which really
  are browser design bugs, but it is still you who will have to deal with
  it, as major browser developers care only for features, not about getting
  security right).
  
  
  =head1 INTEROPERABILITY WITH OTHER MODULES
  
  C<JSON::XS> uses the L<Types::Serialiser> module to provide boolean
  constants. That means that the JSON true and false values will be
  comaptible to true and false values of iother modules that do the same,
  such as L<JSON::PP> and L<CBOR::XS>.
  
  
  =head1 THREADS
  
  This module is I<not> guaranteed to be thread safe and there are no
  plans to change this until Perl gets thread support (as opposed to the
  horribly slow so-called "threads" which are simply slow and bloated
  process simulations - use fork, it's I<much> faster, cheaper, better).
  
  (It might actually work, but you have been warned).
  
  
  =head1 THE PERILS OF SETLOCALE
  
  Sometimes people avoid the Perl locale support and directly call the
  system's setlocale function with C<LC_ALL>.
  
  This breaks both perl and modules such as JSON::XS, as stringification of
  numbers no longer works correctly (e.g. C<$x = 0.1; print "$x"+1> might
  print C<1>, and JSON::XS might output illegal JSON as JSON::XS relies on
  perl to stringify numbers).
  
  The solution is simple: don't call C<setlocale>, or use it for only those
  categories you need, such as C<LC_MESSAGES> or C<LC_CTYPE>.
  
  If you need C<LC_NUMERIC>, you should enable it only around the code that
  actually needs it (avoiding stringification of numbers), and restore it
  afterwards.
  
  
  =head1 BUGS
  
  While the goal of this module is to be correct, that unfortunately does
  not mean it's bug-free, only that I think its design is bug-free. If you
  keep reporting bugs they will be fixed swiftly, though.
  
  Please refrain from using rt.cpan.org or any other bug reporting
  service. I put the contact address into my modules for a reason.
  
  =cut
  
  BEGIN {
     *true    = \$Types::Serialiser::true;
     *true    = \&Types::Serialiser::true;
     *false   = \$Types::Serialiser::false;
     *false   = \&Types::Serialiser::false;
     *is_bool = \&Types::Serialiser::is_bool;
  
     *JSON::XS::Boolean:: = *Types::Serialiser::Boolean::;
  }
  
  XSLoader::load "JSON::XS", $VERSION;
  
  =head1 SEE ALSO
  
  The F<json_xs> command line utility for quick experiments.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
X86_64-LINUX_JSON_XS

$fatpacked{"x86_64-linux/JSON/XS/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_JSON_XS_BOOLEAN';
  =head1 NAME
  
  JSON::XS::Boolean - dummy module providing JSON::XS::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules. It's only needed for compatibility with data serialised
  (by other modules such as Storable) that was decoded by JSON::XS versions
  before 3.0.
  
  Since 3.0, JSON::PP::Boolean has replaced it. Support for
  JSON::XS::Boolean will be removed in a future release.
  
  =cut
  
  use JSON::XS ();
  
  1;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
X86_64-LINUX_JSON_XS_BOOLEAN

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.47";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of the all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.47";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/PerlIO/utf8_strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PERLIO_UTF8_STRICT';
  package PerlIO::utf8_strict;
  $PerlIO::utf8_strict::VERSION = '0.006';
  use strict;
  use warnings;
  
  use XSLoader;
  
  XSLoader::load(__PACKAGE__, __PACKAGE__->VERSION);
  
  1;
  
  #ABSTRACT: Fast and correct UTF-8 IO
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  PerlIO::utf8_strict - Fast and correct UTF-8 IO
  
  =head1 VERSION
  
  version 0.006
  
  =head1 SYNOPSIS
  
   open my $fh, '<:utf8_strict', $filename;
  
  =head1 DESCRIPTION
  
  This module provides a fast and correct UTF-8 PerlIO layer. Unlike perl's default C<:utf8> layer it checks the input for correctness.
  
  =head1 LAYER ARGUMENTS
  
  =over 4
  
  =item allow_noncharacters
  
  =item allow_surrogates
  
  =back
  
  =head1 EXPORT
  
  PerlIO::utf8_strict exports no subroutines or symbols, just a perl layer C<utf8_strict>
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Can't decode ill-formed UTF-8 octet sequence <%s>
  
  (F) Encountered an ill-formed UTF-8 octet sequence. <%s> contains a hexadecimal 
  representation of the maximal subpart of the ill-formed subsequence.
  
  =item Can't interchange noncharacter code point U+%.4X
  
  (F) Noncharacters is permanently reserved for internal use and that should 
  never be interchanged. Noncharacters consist of the values U+nFFFE and U+nFFFF 
  (where n is from 0 to 10^16) and the values U+FDD0..U+FDEF.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Leon Timmermans <leont@cpan.org>
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Leon Timmermans, Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX_PERLIO_UTF8_STRICT

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.47";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.73;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\xc0";
     # use strict, use utf8; use feature;
     $^H |= 0x1c820fc0;
     @^H{qw(feature_say feature_fc feature___SUB__ feature_evalbytes feature_switch feature_unicode feature_state)} = (1) x 7;
  }
  
  1
X86_64-LINUX_COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

# -*- cperl -*-

use Test::More;
use Git;
use File::Slurper qw(read_text);
use JSON;
use Term::ANSIColor qw(:constants);
use Capture::Tiny qw(capture_merged);
use YAML qw(LoadFile);

use v5.14; # For say

unless ( $ENV{'TRAVIS_PULL_REQUEST'} =~ /\d/ ) {
  plan skip_all => "Check relevant only for PRs";
}

my $repo = Git->repository ( Directory => '.' );
my $diff = $repo->command('diff','HEAD^1','HEAD');
my $diff_regex = qr/a\/proyectos.md/;
my $github;

SKIP: {
  my ($this_hito) = ($diff =~ $diff_regex);
  skip "No hay envío de proyecto", 10 unless defined $this_hito;
  my $diag=<<EOC;

"Failed test" indica que no se cumple la condición indicada
Hay que corregir el envío y volver a hacer el pull request,
aumentando en uno el número de la versión del hito en el
fichero correspondiente.

EOC
  diag $diag;
  my @files = split(/diff --git/,$diff);
  my ($diff_hito) = grep( /$diff_regex/, @files);
  my @lines = split("\n",$diff_hito);
  my @adds = grep(/^\+[^+]/,@lines);
  cmp_ok $#adds, "==", 0, "Sólo se añade una línea";
  my $url_repo;
  if ( $adds[0] =~ /\(http/ ) {
    ($url_repo) = ($adds[0] =~ /\((https\S+)\)/);
  } else {
    ($url_repo) = ($adds[0] =~ /^\+.+(https\S+)\b/s);
  }
  ok $url_repo, "Detectado un enlace a repo en $adds[0]";
  my ($version) = @adds[0] =~ /(v\d+\.\d+\.\d+)/;
  diag(check( "Encontrado URL del repo $url_repo con versión $version" ));
  my ($user,$name) = ($url_repo=~ /github.com\/(\S+)\/(.+)/);
  my $repo_dir = "/tmp/$user-$name";
  unless (-d $repo_dir) {
    mkdir($repo_dir);
    `git clone $url_repo $repo_dir`;
  } else {
    chdir $repo_dir;
    `git pull`
  }
  my $student_repo =  Git->repository ( Directory => $repo_dir );
  my ($output, @result ) =  capture_merged { $student_repo->command("checkout", $version) };
  unlike $output, qr/returned error/, "Repositorio tag-eado correctamente";

  my @repo_files = $student_repo->command("ls-files");
  my $README =  read_text( "$repo_dir/README.md"); # Lo necesito en versiones 3 y 4

  my ($this_version) = ( $version =~ /^v(\d+)/ );

  my $config;

  if ( $this_hito >= 1 ) {
    diag( check ("Tests para hito 1") );
    if ( ok( -e "$repo_dir/agil.yaml", "Está el fichero de configuración «agil.yaml»") ) {
      $config = LoadFile("$repo_dir/agil.yaml");
      ok( $config, "Fichero de configuración para corrección agil.yaml cargado correctamente" );
      ok( $config->{'personas'}, "Lista de personas presente en el fichero" );
    }
  }

  if ($this_version >= 2 ) {
    diag( check( "Tests para hito 2") );
    like( $README, qr/[Ss]oluci.n/, "Se menciona una solución en el README");
  }

  if ($this_version >= 3 ) {
    diag( check( "Tests para hito 3") );
    like( $README, qr/[lL]og/, "Se menciona un logger en el README");
  }

  if ( $this_version >= 6 ) {
    diag( check( "Tests para hito 6") );
    file_present( $config->{'excepciones'}, \@repo_files, "con excepciones" );
  }

  if ( $this_version >= 7 ) {
    diag( check( "Tests para hito 7") );
    file_present( $config->{'taskfile'}, \@repo_files, "con gestor de tareas" );
    ok( $config->{'lenguaje'}, "Se ha declarado el lenguaje de programación" );
  }

  my $runner = $config->{'runner'};
  if ( $this_version >= 8) {
    diag( check( "Tests para hito 8") );
    ok( $runner, check( "La clave runner $runner en el fichero de configuración en este tag" ) );
    like( $README, qr/$runner\s+test/, check("«$runner test» en el README"));
  }

  if ( $this_version >= 9 ) {
    diag( check( "Tests para hito 9") );
    file_present( '.travis.yml', \@repo_files, "de CI" );
    travis_pass( $README, $user, $name );
  }

  if ( $this_version >= 10 ) {
    diag( check( "Tests para hito 10") );
    like( $README, qr/$runner\s+coverage/, check("«$runner coverage» en el README"));
    codecov_pass( $README );
  }

  if ( $this_version >= 11 ) {
    diag( check( "Tests para hito 11") );
    like( $README, qr/$runner\s+run/, check("«$runner run» en el README"));
    codecov_pass( $README );
  }

  if ( $this_version >= 12 ) {
    diag( check( "Tests para hito 12") );
    file_present( $config->{'dateador'}, \@repo_files, "dateador" );
  }
}

done_testing;

sub check {
  return BOLD.GREEN ."✔ ".RESET.join(" ",@_);
}

sub file_present {
  my ($file, $ls_files_ref, $name ) = @_;
  my @files = (ref($file) eq 'ARRAY')?@$file:($file);
  for my $file (@files ) {
    ok( grep( /$file/, @$ls_files_ref ), "Fichero $name → $file presente" );
  }

}

sub config_file {
  my ($ls_files_ref, $repo_dir) = @_;
  file_present( "agil.yaml", $ls_files_ref, "de configuración" );
  return LoadFile("$repo_dir/agil.yaml");
}

sub language_checks {
  my ($language, $ls_files_ref) = @_;
  if ($language =~ /python/i ) {
    file_present( "pyproject.toml", $ls_files_ref, "Python" );
  } elsif ( $language =~ /Typescript/i || $language =~ /node/i ) {
    file_present( "package.json", $ls_files_ref, "JS" );
  }
}

sub travis_domain {
  my ($README, $user, $name) = @_;
  my ($domain) = ($README =~ /.Build Status..https:\/\/travis-ci.(\w+)\/$user\/$name\.svg.+$name\)/i);
  return $domain;
}

sub travis_status {
  my $README = shift;
  my ($build_status) = ($README =~ /Build Status..([^\)]+)\)/);
  my $status_svg = `curl -L -s $build_status`;
  return $status_svg =~ /passing/?"Passing":"Fail";
}

sub travis_pass {
  my ($README, $user, $name ) = @_;
  my $travis_domain = travis_domain( $README, $user, $name );
  ok( $travis_domain =~ /(com|org)/ , "Está presente el badge de Travis con enlace al repo correcto");
  if ( $travis_domain =~ /(com|org)/ ) {
    is( travis_status($README), 'Passing', "Los tests deben pasar en Travis");
  }
}

sub codecov_pass {
  my $README = shift;
  my $codecov_perc = codecov_perc( $README );
  cmp_ok $codecov_perc, ">", 85, "Porcentaje de cobertura OK";
  
}

sub codecov_perc {
  my $README =  shift;
  my ($codecov_status ) = ($README =~ /\((https:\/\/codecov\.io\/\S+badge\.svg)/ );
  ok( $codecov_status, "Badge de codecov detectado" );
  my $codecov_svg = `curl -L -s $codecov_status`;
  ok( $codecov_svg, "Badge de codecov descargado" );
  my ($codecov_perc) = ($codecov_svg =~ /(\d+)%<\/text/);
  ok( $codecov_perc, "Porcentaje de cobertura es $codecov_perc" );
  return $codecov_perc;
}
